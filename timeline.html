<!DOCTYPE html>
<html lang="en">

	<!-- -----
	 Be sure to set your actual API key in place of "YOUR_API_KEY" (line 20)
	 
	 Version: May 11, 2025
	 Full details here:
	 https://github.com/kurupted/google-maps-timeline-viewer/
	 
	----  -->
	
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Google Maps Timeline Viewer</title>
    
    <!-- Google Maps importLibrary loader -->
	<script>
		window.GOOGLE_MAPS_API_KEY = "YOUR_API_KEY"; // Replace YOUR_API_KEY with your actual key

		(g => {
		  var h, a, k, p = "The Google Maps JavaScript API", c = "google", l = "importLibrary", q = "__ib__", m = document, b = window;
		  b = b[c] || (b[c] = {});
		  var d = b.maps || (b.maps = {}), r = new Set, e = new URLSearchParams, 
			  u = () => h || (h = new Promise(async (f, n) => {
				await (a = m.createElement("script"));
				e.set("libraries", [...r] + "");
				for (k in g) e.set(k.replace(/[A-Z]/g, t => "_" + t[0].toLowerCase()), g[k]);
				e.set("callback", c + ".maps." + q);
				// Use the globally stored API key
				if (g.key) { // Check if a key was passed in the config object
					 e.set("key", g.key);
				}
				a.src = `https://maps.${c}apis.com/maps/api/js?` + e;
				d[q] = f;
				a.onerror = () => h = n(Error(p + " could not load."));
				a.nonce = m.querySelector("script[nonce]")?.nonce || "";
				m.head.append(a);
			  }));
		  d[l] ? console.warn(p + " only loads once. Ignoring:", g) : d[l] = (f, ...n) => r.add(f) && u().then(() => d[l](f, ...n))
		})
		({ key: window.GOOGLE_MAPS_API_KEY,
			v: "beta",
			libraries: "places" });
	</script>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.29.1/moment.min.js"></script>
    <style>
        body, html {
            height: 100%;
            margin: 0;
            font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, 'Open Sans', 'Helvetica Neue', sans-serif;
            background-color: #f8f9fa;
            overflow: hidden; /* Prevent body scroll */
        }
        a {
            color: #007bff;
            text-decoration:none;
        }
        a:hover {
            text-decoration:underline;
        }
        #container {
            display: flex;
            height: 100%;
            position: relative;
        }

        /* --- Sidebar Styles --- */
        #sidebar {
            width: 350px;
            background-color: #ffffff;
            border-right: 1px solid #dee2e6;
            display: flex;
            flex-direction: column; /* Stack elements vertically */
            height: 100%; /* Ensure sidebar takes full height */
            overflow: hidden; /* Prevent sidebar itself from scrolling */
            position: relative; /* Ensure sidebar stays in flow */
            z-index: 60; /* Keep sidebar above summary view background if needed */
        }

        /* --- Control Sections (Non-scrolling) --- */
        #controls-container,
        #layerOptions,
        #datePickerContainer,
        #icon-buttons-container,
        #go-container {
            padding: 10px 12px;
            border-bottom: 1px solid #e9ecef;
            flex-shrink: 0; /* Prevent these sections from shrinking */
            background-color: #ffffff; /* Ensure background */
        }
        #controls-container {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .control-btn {
            flex-grow:1;
            padding: 10px 15px;
            background-color: #5A95F5;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: background-color 0.2s ease, box-shadow 0.2s ease;
            text-align: center;
        }
        .control-btn:hover:not(:disabled) {
            background-color: #4a85e5;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .control-btn:disabled {
            background: #ced4da;
            cursor: not-allowed;
            color: #6c757d;
        }

        /* --- Layer Options --- */
        #layerOptions {
            display: none; /* Initially hidden */
        }
         #layerOptionsHeader {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        #layerOptions h4 {
            margin-top: 0;
            margin-bottom: 10px;
            font-weight: 500;
        }
        #layerOptions label {
            display: block;
            margin-bottom: 8px;
            font-size: 14px;
        }
        .layer-option {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
        }
        .layer-checkbox {
            margin-right: 8px;
        }
         #closeLayerBtn {
            padding: 4px 10px;
            font-size: 12px;
            cursor: pointer;
            background-color: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            color: #495057;
        }
        #closeLayerBtn:hover {
            background-color: #e9ecef;
        }
        #activityFilters {
            margin-left: 20px;
            padding-top: 5px;
        }

        /* --- Date Picker --- */
        #datePickerContainer {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 6px;
        }
        #startDatePicker, #endDatePicker {
            flex: 1;
            padding: 8px 10px;
            border: 1px solid #ced4da;
            border-radius: 4px;
            font-size: 12px;
            background-color: #fff;
        }
        #startDatePicker:disabled, #endDatePicker:disabled {
             background-color: #e9ecef;
             cursor: not-allowed;
        }
        #datePickerContainer span {
            color: #6c757d;
        }
        #dateToSpan {
            font-size: 10px;
        }
        #prevDayBtn, #nextDayBtn {
            background: #f8f9fa;
            border: 1px solid #ced4da;
            border-radius: 4px;
            padding: 2px 4px;
            cursor: pointer;
            font-size: 10px;
            color: #495057;
            transition: all 0.2s ease;
        }
        #prevDayBtn:hover:not(:disabled), #nextDayBtn:hover:not(:disabled) {
            background: #e9ecef;
            color: #343a40;
        }
        #prevDayBtn:disabled, #nextDayBtn:disabled {
            background: #e9ecef;
            color: #adb5bd;
            cursor: not-allowed;
        }

        /* --- Icon Buttons --- */
        #icon-buttons-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding-top: 8px;
            padding-bottom: 8px;
            min-height: 30px;
        }
        #icon-buttons-left, #icon-buttons-right {
            display: flex;
            gap: 2px;
        }
        .icon-btn {
            background: none;
            border: none;
            font-size: 14px;
            cursor: pointer;
            color: #6c757d;
            border-radius: 4px;
            transition: background-color 0.2s ease, color 0.2s ease;
            display: flex; /* Align icon and text */
			align-items: center; /* Vertically center icon and text */
			gap: 6px; /* Space between icon and text */
			padding: 5px 8px;
        }
        .icon-btn:hover:not(:disabled) {
            background-color: #e9ecef;
            color: #343a40;
        }
         .icon-btn:disabled {
            color: #adb5bd;
            cursor: not-allowed;
        }
        .icon-btn.active { /* Style for the active view button */
            background-color: #dde4ed; /* A slightly different background */
            color: #0056b3; /* A distinct color */
        }

        /* --- Go Button --- */
        #go-container {
            display: flex;
            align-items: center;
            justify-content: center;
            padding-top: 5px;
        }
        #goBtn {
            flex-grow: 1;
            padding: 12px 20px;
            background-color: #48a765;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 15px;
            font-weight: 500;
            transition: background-color 0.2s ease, box-shadow 0.2s ease;
        }
        #goBtn:hover:not(:disabled) {
             background-color: #218838;
             box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        #goBtn:disabled {
            background: #ced4da;
            color: #6c757d;
            cursor: not-allowed;
        }
         #goBtn:disabled:hover {
            background: #ced4da;
            box-shadow: none;
        }

        /* --- Timeline (Scrollable Area) --- */
        #timeline {
            flex-grow: 1; /* Allow timeline to fill remaining vertical space */
            overflow-y: auto; /* Make ONLY the timeline scrollable */
            padding: 10px 12px;
            padding-top:0px;
            background-color: #f8f9fa;
        }
        /* --- Sticky Date Header --- */
        #timeline .date-header{
            display: flex;
            align-items: center;
            margin-bottom: 10px;
            padding: 8px 10px;
            background-color: #cccccc;
            position: sticky; /* Enable sticky behavior */
            top: 0; /* Stick to the top of the #timeline container */
            z-index: 10; /* Ensure it stays above timeline items */
            font-weight: 600;
            border-bottom: 1px solid #dee2e6;
            font-size: 14px;
            color: #192027;
            cursor: pointer; /* Show clickable cursor */
            transition: background-color 0.2s ease;
        }
        #timeline .date-header:hover {
            background-color: #bbbbbb; /* Slightly darker on hover */
        }

        .timeline-item {
            display: flex;
            align-items: flex-start;
            margin-bottom: 8px;
            padding: 8px;
            background-color: #ffffff;
            border: 1px solid #e9ecef;
            border-radius: 5px;
            cursor: pointer;
            position: relative;
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
        }
        .timeline-item:hover {
            border-color: #adb5bd;
        }
        .timeline-icon-container {
            width: 32px;
            text-align: center;
            padding-right: 10px;
            padding-top: 2px;
            flex-shrink: 0;
            font-size: 24px;
        }
        .timeline-icon-svg {
			width: 24px;
			height: 24px;
			display: inline-block;
        }
        .timeline-item-details {
            flex-grow: 1;
        }
         .timeline-item-details strong {
             font-weight: 500;
             font-size: 15px;
             color: #343a40;
         }
        .timeline-item-details div {
            font-size: 14px;
            line-height: 1.4;
            color: #495057;
        }
        .timeline-item-time {
             display: block;
             font-size: 12px;
             color: #6c757d;
             margin-top: 2px;
             margin-bottom: 4px;
        }
        /* Specific style for distance */
        .timeline-item-details .distance {
            font-size: 12px;
            color: #6c757d;
        }
        .place-visit-item {
             background-color: #FFFAF0 !important; /* Light yellow background */
             border-left: 4px solid #ffc107; /* Yellow border */
             padding-left: 10px;
        }
        /* Adjust Activity Segment border */
        .timeline-item:not(.place-visit-item) { /* Target activity segments */
            border-left: 4px solid var(--activity-color, #6c757d); /* Use CSS variable for color */
            padding-left: 10px;
        }
        .highlighted {
        	border-color-top: #007bff !important;
			border-color-right: #007bff !important;
			border-color-bottom: #007bff !important;
            box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.35);
        }
        .confirmed-checkmark {
            position: absolute;
            bottom: 5px;
            right: 8px;
            font-size: 12px;
            opacity: 0.3;
            color: #28a745;
        }
        .highlighted .confirmed-checkmark{
            opacity: 0.6;
        }

        
        /* --- Bottom Sidebar Elements (Non-scrolling) --- */
        #status-bar-container { /* New container for data source and API calls */
            display: flex;
            justify-content: space-between; /* Align items to ends */
            align-items: center; /* Vertically align items */
            font-size: 11px;
            padding: 8px 12px;
            color: #6c757d;
            border-top: 1px solid #e9ecef;
            flex-shrink: 0;
            background-color: #ffffff;
        }
        #data-source-indicator {
            text-align: left; /* Align text to the left */
            flex-grow: 1; /* Allow it to take available space */
        }
        #api-call-counter {
            font-weight: bold;
            color: #343a40;
            text-align: right;
        }
        #cache-controls {
            display: inline-block;
            padding: 0px 0px;
            padding-top: 3px;
            background-color: #ffffff;
        }
        .cache-btn {
            padding: 4px 6px;
            font-size: 10px;
            background-color: #e9ecef;
            color: #495057;
            border: 1px solid #ced4da;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }
        .cache-btn:hover:not(:disabled) {
            background-color: #dde4ed;
        }
        .cache-btn:disabled {
            background-color: #f8f9fa;
            color: #adb5bd;
            cursor: not-allowed;
        }
        #disableApiBtn.active {
			background-color: #f2bcb8;
        }
        #about-container {
             margin-top: auto; /* Pushes About link to the very bottom */
             font-size: 11px;
             padding: 8px 12px;
             padding-top: 0; /* Remove extra top padding */
             color: #6c757d;
             text-align: center;
             border-top: 1px solid #e9ecef;
             flex-shrink: 0;
             background-color: #ffffff;
        }


        /* --- Map Styles --- */
        #map {
            flex-grow: 1;
            height: 100%;
            position: relative; /* Needed for absolute positioning of summary view */
            transition: opacity 0.3s ease; /* Smooth map fade */
        }
        /* --- Advanced Marker (if needed, seems okay) --- */
        .advanced-marker { display: flex; flex-direction: column; align-items: center; }
        .marker-icon { font-size: 24px; }
        .marker-label { font-size: 12px; white-space: nowrap; }

        /* --- Info Window Photo Placeholder --- */
        .photo-placeholder {
            width: 200px;
            height: 150px;
            background-color: #eee;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #aaa;
            font-size: 12px;
            border-radius: 3px;
            margin-top: 5px;
            text-align: center; /* Center text */
        }
        .photo-container img {
             max-width: 200px;
             max-height: 150px;
             margin-top: 5px;
             border-radius: 3px;
             display: block; /* Ensure img takes block space */
        }

        /* --- Summary View Styles --- */
        #summaryView,
        #howToMessage {
            position: absolute; /* Position over the map area */
            top: 0;
            left: 351px; /* Sidebar width (350px) + border (1px) */
            right: 0;
            bottom: 0;
            background-color: #f8f9fa; /* Match sidebar scroll background */
            z-index: 50; /* Above map, below loading overlay */
            padding: 20px;
            padding-left:40px;
            overflow-y: auto; /* Scroll if content overflows */
            border-left: 1px solid #dee2e6; /* Match sidebar border */
            font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
        }
        #summary-controls {
            text-align: right;
            margin-bottom: 10px;
        }
        #closeSummaryBtn {
            background: none;
            border: 1px solid #ccc;
            border-radius: 50%;
            cursor: pointer;
            font-size: 16px;
            line-height: 1;
            width: 24px;
            height: 24px;
            color: #666;
            padding: 0;
        }
        #closeSummaryBtn:hover {
            background-color: #eee;
            border-color: #aaa;
        }
        #summaryView h4 {
             margin-top: 15px;
             margin-bottom: 8px;
             border-bottom: 1px solid #e0e0e0;
             padding-bottom: 5px;
             font-weight: 500;
             color: #333;
        }
         #summaryView h4:first-of-type {
             margin-top: 0;
         }
        #summary-selected-dates,
        #summary-years, /* Apply flexbox to the direct container of year items */
        #summary-months {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }
        #summary-months {
            display: none; /* Hide months initially */
        }
        #backToYearsBtn {
            display: none; /* Hide back button initially */
            margin-bottom: 15px;
            padding: 5px 10px;
            font-size: 12px;
            cursor: pointer;
            background-color: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            color: #495057;
        }
        #backToYearsBtn:hover {
            background-color: #e9ecef;
        }

        .summary-selected-item,
        .summary-year-item,
        .summary-month-item {
            border: 1px solid #ced4da;
            padding: 10px;
            border-radius: 5px;
            background-color: #ffffff;
            cursor: default; /* Default cursor for selected/year/month */
            transition: background-color 0.2s ease, border-color 0.2s ease, width 0.3s ease, opacity 0.3s ease; /* Added opacity transition */
            min-width: 170px; /* Ensure items have some width */
            font-size: 13px;
            box-sizing: border-box; /* Include padding/border in width */
            opacity: 1; /* Ensure visible by default */
        }
        /* Allow click cursor only for year/month items */
        .summary-year-item, .summary-month-item {
             cursor: pointer;
        }
        .summary-year-item:hover, .summary-month-item:hover {
             border-color: #adb5bd;
             background-color: #f1f3f4;
        }
        .summary-year-item.is-selected-year { /* Style for the expanded year */
            border-color: #007bff;
            background-color: #e7f1ff;
            font-weight: bold;
            width: 100%; /* Expand to full width */
            cursor: default; /* No pointer cursor when expanded */
            opacity: 1; /* Ensure selected year is fully visible */
        }
        .summary-year-item.is-selected-year:hover { /* Override hover when expanded */
             border-color: #007bff;
             background-color: #e7f1ff;
        }

        /* Hide non-selected years when one is expanded */
        #summaryView.expanded-year-active #summary-years .summary-year-item:not(.is-selected-year) {
            /* display: none; */ /* Replaced with opacity for smoother transition */
            opacity: 0;
            pointer-events: none; /* Prevent interaction with hidden items */
            height: 0; /* Collapse height */
            padding: 0; /* Remove padding */
            margin: 0; /* Remove margin */
            border: none; /* Remove border */
            overflow: hidden; /* Hide content */
        }
        /* Show months and back button when a year is expanded */
        #summaryView.expanded-year-active #summary-months,
        #summaryView.expanded-year-active #backToYearsBtn {
            display: flex; /* Or block, depending on desired layout */
        }

        .summary-selected-item strong,
        .summary-year-item strong,
        .summary-month-item strong {
            display: block;
            font-size: 16px;
            margin-bottom: 5px;
            color: #0056b3;
        }
        .summary-month-item strong {
             color: #1a73e8;
        }
        .summary-selected-item strong { /* Specific style for selected date title */
             color: #28a745; /* Green */
        }
        .summary-details {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 12px;
            color: #495057;
            margin-top: 3px;
        }
        .summary-details span {
            text-align: right;
        }
        /* Common style for activity lists */
        .summary-selected-item ul,
        .summary-year-item ul,
        .summary-month-item ul {
            list-style: none;
            padding: 0;
            margin: 8px 0 0 0;
            font-size: 11px;
            color: #6c757d;
        }
        /* Style for multi-column activity list in expanded year */
        .summary-year-item.is-selected-year ul {
            column-count: 3;
            column-gap: 20px;
        }
        .summary-year-item.is-selected-year ul li,
        .summary-year-item.is-selected-year .summary-details {
            max-width: 170px;
        }
        @media (max-width: 600px) { /* Use 1 column on smaller screens */
             .summary-year-item.is-selected-year ul {
                 column-count: 1;
             }
        }

        .summary-selected-item ul li,
        .summary-year-item ul li,
        .summary-month-item ul li {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 2px; /* Consistent spacing */
            break-inside: avoid-column; /* Prevent list items from breaking across columns */
        }
        /* Common style for distance values in lists */
        .summary-selected-item li span,
        .summary-year-item li span,
        .summary-month-item li span {
             color: #343a40;
             font-weight: 500;
        }

        /* Style to hide map when summary is shown */
        #map.hidden {
            opacity: 0;
            pointer-events: none; /* Prevent interaction with hidden map */
        }
        /* --- Loading Overlay --- */
        #loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            display: none; /* Initially hidden */
            z-index: 1000; /* Ensure above summary view */
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 1.2em;
        }
        #loading-spinner {
            border: 8px solid #f3f3f3;
            border-top: 8px solid #5A95F5;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1.5s linear infinite;
            margin-bottom: 15px;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="sidebar">
            <div id="controls-container">
                <button id="folderPicker" class="control-btn">Choose Folder</button>
                <button id="layerBtn" class="control-btn" disabled>Layers</button>
                <button id="fitMapBtn" class="control-btn" disabled>Fit Map</button>
            </div>

            <div id="layerOptions" style="display: none;">
                <div id="layerOptionsHeader">
                    <h4>View Options</h4>
                    <button id="closeLayerBtn">Close</button>
                </div>
                <label>
                    <input type="checkbox" id="showVisits" class="layer-checkbox" checked> Show Visits
                </label>
                <label>
                    <input type="checkbox" id="showActivities" class="layer-checkbox" checked> Show Activities
                </label>
                <div id="activityFilters" style="margin-left: 20px;">
                        <!-- Activity filters will be populated here -->
                    </div>
            </div>

            <div id="datePickerContainer">
                <button id="prevDayBtn" disabled>&lt;</button>
                <input type="date" id="startDatePicker" disabled>
                <span id="dateToSpan">to</span>
                <input type="date" id="endDatePicker" disabled>
                <button id="nextDayBtn" disabled>&gt;</button>
            </div>

            <div id="icon-buttons-container">
				<div id="icon-buttons-left">
                    <button id="mapBtn" class="icon-btn active" title="Show Map" disabled>
                        <span role="img" aria-label="Map">🗺️</span> Map
                    </button>
                    <button id="summaryBtn" class="icon-btn" title="Show Summary" disabled>
                        <span role="img" aria-label="Summary">📊</span> Summary
                    </button>
                </div>
                <div id="icon-buttons-right">
                    </div>
            </div>

            <div id="go-container">
                <button id="goBtn" class="control-btn" disabled>GO</button>
            </div>

            <div id="loading-overlay">
                <div id="loading-spinner"></div>
                <span>Loading data...</span>
            </div>

            <div id="timeline"></div>

			<div id="status-bar-container">
                <span id="data-source-indicator">No data loaded. Use "Choose Folder".</span>
                <div style="text-align:right;">
					<span id="api-call-counter">API Calls: 0</span>
					<div id="cache-controls">
						<button id="disableApiBtn" class="cache-btn">Disable API</button>
						<button id="saveCacheBtn" class="cache-btn" disabled>Save Data</button>
					</div>
                </div>
            </div>

            

        </div>

        <div id="summaryView" style="display: none;">
            <div id="summary-controls">
                <button id="closeSummaryBtn" title="Close Summary">&times;</button>
             </div>
             <h4>Selected Date(s) Summary</h4>
             <div id="summary-selected-dates">
                 <p>Calculating...</p>
             </div><br>
             <h4>Yearly Summary</h4>
             <div id="summary-years-container">
                 <div id="summary-years">
                     <p>Calculating...</p>
                 </div>
                 <button id="backToYearsBtn">← Back to Years</button>
             </div><br>
             <h4>Monthly Summary <span id="summary-selected-year"></span></h4>
             <div id="summary-months">
                  <p>Select a year above.</p>
             </div>
        </div>

        <div id="map" class=""></div>

        <div id="howToMessage">
            <h3>How to use:</h3>
            First, complete the initial setup as explained on the <a href="https://github.com/kurupted/google-maps-timeline-viewer/" target="_blank">Github project page</a>.<br><br>
            Click "Choose Folder" on the left and navigate to the folder that contains your Timeline data.<br>
            <h4>For Google Takeout data:</h4>
            The folder structure should be "Takeout\Location History (Timeline)\Semantic Location History".<br>
            Navigate into the "Semantic Location History" folder, and then click "Select Folder" on the dialog.<br>
            (Do not navigate into one of the yearly subfolders.)<br>
            <h4>For On-Device exported data:</h4>
            Simply choose the folder that contains your exported Timeline.json file.<br>
            (On non-English systems, the filename may be different -- rename the file to Timeline.json)<br>
            If you have a previously saved "TimelinePlaceCache.json" file, be sure it's in the same folder. This can speed up loading and reduce API calls.
            <br><br><br><br>
            After the data has loaded, use the date picker to choose a date or date range that contains timeline data.<br>
        </div>
    </div>

    <script>
        // --- Global Variables ---
        let map;
        let markers = [];
        let polylines = [];
        let infoWindows = [];
        let selectedPolyline = null;
        let timelineData = {}; // Stores parsed timeline data, keyed by YYYY_MONTH
        let activityTypes = new Set(); // Keep track of unique raw activity types found
        let placeDetailsCache = {}; // Cache for storing Place Details results
        let globalIndex = 0; // Global counter for unique data-index across map/timeline
        let uiEnabled = false; // Flag to track if UI is enabled (data loaded)
        let placeApiCallCount = 0; // Counter for Place API calls
        let apiCallsDisabled = false;

        // Summary View Globals
        let allYearlySummaries = null; // Calculated yearly summaries
        let allMonthlySummaries = null; // Calculated monthly summaries
        let selectedSummaryYear = null; // Track which year's months are shown
        let summaryViewVisible = false; // Track summary view state

        // --- Activity Type Mapping ---
        // Groups similar activity types for display and filtering
        const activityGroupMapping = {
            'DRIVING': ['IN_VEHICLE', 'IN_PASSENGER_VEHICLE', 'DRIVE'],
            'TAXI': ['IN_TAXI'],
            'MOTORCYCLING': ['MOTORCYCLING'],
            'CYCLING': ['ON_BICYCLE', 'CYCLING', 'BICYCLE'],
            'WALKING': ['ON_FOOT', 'WALKING', 'WALKING_NORDIC', 'WALK'],
            'HIKING': ['HIKING'],
            'RUNNING': ['RUNNING'],
            'BUS': ['IN_BUS'],
            'SUBWAY': ['IN_SUBWAY'],
            'TRAIN': ['IN_TRAIN'],
            'TRAM': ['IN_TRAM'],
            'FERRY': ['IN_FERRY'],
            'STATIONARY': ['STILL'],
            'FLYING': ['FLYING'],
            'CABLECAR': ['IN_CABLECAR'],
            'FUNICULAR': ['IN_FUNICULAR'],
            'GONDOLA_LIFT': ['IN_GONDOLA_LIFT'],
            'WHEELCHAIR': ['IN_WHEELCHAIR'],
            'SNOWMOBILE': ['SNOWMOBILE'],
            'BOATING': ['BOATING'],
            'CATCHING_POKEMON': ['CATCHING_POKEMON'],
            'HORSEBACK_RIDING': ['HORSEBACK_RIDING'],
            'KAYAKING': ['KAYAKING'],
            'KITESURFING': ['KITESURFING'],
            'PARAGLIDING': ['PARAGLIDING'],
            'ROWING': ['ROWING'],
            'SAILING': ['SAILING'],
            'SKATEBOARDING': ['SKATEBOARDING'],
            'SKATING': ['SKATING'],
            'SKIING': ['SKIING'],
            'SLEDDING': ['SLEDDING'],
            'SNOWBOARDING': ['SNOWBOARDING'],
            'SNOWSHOEING': ['SNOWSHOEING'],
            'SURFING': ['SURFING'],
            'SWIMMING': ['SWIMMING'],
            'UNKNOWN': ['UNKNOWN', 'UNKNOWN_ACTIVITY_TYPE', 'TILTING']
        };

        // Reverse mapping for easy lookup: RawType -> GroupName
        const rawToGroupMapping = {};
        for (const groupName in activityGroupMapping) {
            activityGroupMapping[groupName].forEach(rawType => {
                rawToGroupMapping[rawType] = groupName;
            });
        }
        // Function to get the grouped activity type from a raw type
        function getGroupedActivityType(rawType) {
            return rawToGroupMapping[rawType] || 'UNKNOWN'; // Default to UNKNOWN if not found
        }
        
        // --- Place Type to Color/Icon Mapping (for sidebar) ---
        const placeTypeStyles = {
            'restaurant': { color: '#FFA500', icon: '🍽️' }, // Orange
            'cafe': { color: '#D2691E', icon: '☕' }, // Chocolate
            'bar': { color: '#FF4500', icon: '🍹' }, // OrangeRed
            'store': { color: '#4682B4', icon: '🛍️' }, // SteelBlue
            'grocery_or_supermarket': { color: '#32CD32', icon: '🛒' }, // LimeGreen
            'park': { color: '#228B22', icon: '🌳' }, // ForestGreen
            'lodging': { color: '#800080', icon: '🏨' }, // Purple (Hotel)
            'transit_station': { color: '#A9A9A9', icon: '🚉' }, // DarkGray
            // Add more types as needed
            'default': { color: '#707070', icon: '📍' } // Default
        };

        function getPlaceStyle(placeTypes) {
            if (placeTypes && placeTypes.length > 0) {
                for (const type of placeTypes) {
                    if (placeTypeStyles[type]) {
                        return placeTypeStyles[type];
                    }
                }
            }
            return placeTypeStyles['default'];
        }

        // --- Map Initialization ---
		let AdvancedMarkerElement;
		let Place;
		let GoogleMap; // Renamed to avoid conflict with built-in Map

		async function initMap() {
		  try {
			// First import the maps library
			const { Map } = await google.maps.importLibrary("maps");
			GoogleMap = Map;
			map = new GoogleMap(document.getElementById('map'), {
			  center: { lat: 25.034170, lng: 121.564560 },
			  zoom: 12,
			  mapId: "TIMELINE_MAP"
			});
			
			// Then import other libraries we need
			const markerModule = await google.maps.importLibrary("marker");
			AdvancedMarkerElement = markerModule.AdvancedMarkerElement;
			
			const placesModule = await google.maps.importLibrary("places");
			Place = placesModule.Place;
			
			console.log("Map and libraries loaded successfully");
		  } catch (error) {
			console.error("Error initializing map libraries:", error);
			// Check if the error is due to API key issues specifically
            if (error.message && (error.message.includes("ApiNotActivatedMapError") || error.message.includes("InvalidKeyMapError") || error.message.includes("ProjectNotLinkedToBillingError") )) {
                 alert("Failed to load Google Maps: API Key issue. Please check your API key, ensure the Maps JavaScript API is enabled, and that your project is linked to a billing account.");
            } else {
                 alert("Failed to load Google Maps libraries. Please check your internet connection and API key settings.");
            }
		  }
		}

        // --- UI Helper Functions ---

        // Get appropriate emoji icon for an activity type (uses grouped type)
        function getActivityIcon(activityType) {
            let group = (activityType in activityGroupMapping) ? activityType : getGroupedActivityType(activityType);
            switch (group) {
                case 'DRIVING': return '🚗';
                case 'TAXI': return '🚕';
                case 'MOTORCYCLING': return '🏍️';
                case 'CYCLING': return '🚴';
                case 'WALKING': return '🚶';
                case 'RUNNING': return '🏃';
                case 'HIKING': return '🥾';
                case 'BUS': return '🚌';
                case 'SUBWAY': return '🚇';
                case 'TRAIN': return '🚆';
                case 'TRAM': return '🚊';
                case 'FERRY': return '⛴️';
                case 'STATIONARY': return '🛑';
                case 'FLYING': return '✈️';
                case 'CABLECAR': return '🚠';
                case 'FUNICULAR': return '🚞';
                case 'GONDOLA_LIFT': return '🚡';
                case 'WHEELCHAIR': return '♿';
                case 'SNOWMOBILE': return '🚜'; // Using tractor as placeholder
                case 'BOATING': return '🚤';
                case 'CATCHING_POKEMON': return '👾'; // Using alien monster
                case 'HORSEBACK_RIDING': return '🐎';
                case 'KAYAKING': return '🛶';
                case 'KITESURFING': return '🪁'; // Using kite as placeholder
                case 'PARAGLIDING': return '🪂';
                case 'ROWING': return '🚣';
                case 'SAILING': return '⛵';
                case 'SKATEBOARDING': return '🛹';
                case 'SKATING': return '⛸️';
                case 'SKIING': return '⛷️';
                case 'SLEDDING': return '🛷';
                case 'SNOWBOARDING': return '🏂';
                case 'SNOWSHOEING': return '❄️'; // Using snowflake
                case 'SURFING': return '🏄';
                case 'SWIMMING': return '🏊';
                case 'UNKNOWN':
                    switch (activityType) { case 'TILTING': return '📱'; default: return '❓'; }
                default: return '❓';
            }
        }

        // Get color associated with an activity type (uses grouped type)
        function getActivityColor(activityType) {
            const group = getGroupedActivityType(activityType);
            switch (group) {
                case 'DRIVING': return '#4285F4'; // Google Blue
                case 'TAXI': return '#FFEB3B'; // Yellow
                case 'MOTORCYCLING': return '#1E90FF'; // Dodger Blue
                case 'CYCLING': return '#0F9D58'; // Google Green
                case 'WALKING': return '#DB4437'; // Google Red
                case 'RUNNING': return '#DB4437'; // Google Red
                case 'HIKING': return '#0F9D58'; // Google Green (for nature)
                case 'BUS': return '#9C27B0'; // Purple
                case 'SUBWAY': case 'TRAIN': case 'TRAM': case 'FERRY': return '#673AB7'; // Deep Purple
                case 'STATIONARY': return '#757575'; // Grey
                case 'FLYING': return '#03A9F4'; // Light Blue
                case 'CABLECAR': case 'FUNICULAR': case 'GONDOLA_LIFT': case 'WHEELCHAIR': return '#607D8B'; // Blue Grey
                case 'BOATING': case 'KAYAKING': case 'ROWING': case 'SAILING': case 'SURFING': case 'SWIMMING': return '#00BCD4'; // Cyan
                case 'CATCHING_POKEMON': return '#FFEB3B'; // Yellow
                case 'HORSEBACK_RIDING': return '#795548'; // Brown
                case 'KITESURFING': case 'PARAGLIDING': return '#87CEEB'; // Sky Blue
                case 'SKATEBOARDING': case 'SKATING': return '#FF9800'; // Orange
                case 'SKIING': case 'SLEDDING': case 'SNOWBOARDING': case 'SNOWSHOEING': case 'SNOWMOBILE': return '#B0E0E6'; // Powder Blue
                case 'UNKNOWN': default: return '#9E9E9E'; // Darker Grey
            }
        }

        // Format activity type name for display (uses grouped type where appropriate)
        function formatActivityType(activityType) {
            // Fallback to specific formatting for raw types
            switch (activityType) {
				case 'IN_VEHICLE': case 'DRIVE': return 'Driving';
                case 'IN_PASSENGER_VEHICLE': return 'In a Vehicle';
                case 'IN_TAXI': return 'In a Taxi';
                case 'MOTORCYCLING': return 'Motorcycling';
                case 'ON_BICYCLE': case 'CYCLING': case 'BICYCLE': return 'Biking';
                case 'ON_FOOT': case 'WALKING': case 'WALK': return 'Walking';
                case 'WALKING_NORDIC': return 'Nordic Walking';
                case 'HIKING': return 'Hiking';
                case 'RUNNING': return 'Running';
                case 'IN_BUS': return 'On a Bus';
                case 'IN_SUBWAY': return 'On the Subway';
                case 'IN_TRAIN': return 'On a Train';
                case 'IN_TRAM': return 'On a Tram';
                case 'IN_FERRY': return 'On a Ferry';
                case 'STILL': return 'Stationary';
                case 'FLYING': return 'On a Plane';
                case 'IN_CABLECAR': return 'On a Cable Car';
                case 'IN_FUNICULAR': return 'On a Funicular';
                case 'IN_GONDOLA_LIFT': return 'On a Gondola';
                case 'IN_WHEELCHAIR': return 'In a Wheelchair';
                case 'SNOWMOBILE': return 'On a Snowmobile';
                case 'BOATING': return 'Boating';
                case 'CATCHING_POKEMON': return 'Catching Pokémon';
                case 'HORSEBACK_RIDING': return 'Horseback Riding';
                case 'KAYAKING': return 'Kayaking';
                case 'KITESURFING': return 'Kitesurfing';
                case 'PARAGLIDING': return 'Paragliding';
                case 'ROWING': return 'Rowing';
                case 'SAILING': return 'Sailing';
                case 'SKATEBOARDING': return 'Skateboarding';
                case 'SKATING': return 'Skating';
                case 'SKIING': return 'Skiing';
                case 'SLEDDING': return 'Sledding';
                case 'SNOWBOARDING': return 'Snowboarding';
                case 'SNOWSHOEING': return 'Snowshoeing';
                case 'SURFING': return 'Surfing';
                case 'SWIMMING': return 'Swimming';
                case 'UNKNOWN': case 'UNKNOWN_ACTIVITY_TYPE': return 'Unknown Activity';
                case 'TILTING': return 'Device Tilt';
                default:
					 const group = getGroupedActivityType(activityType);
					// Use group name if it's not UNKNOWN
					if (group !== 'UNKNOWN' && group !== activityType) {
						return group.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
					}else{
						return activityType ? activityType.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase()) : 'Unknown Activity';
					}
            }
        }

        // --- API Call Counter ---
        function incrementApiCallCount() {
            placeApiCallCount++;
            updateApiCallDisplay();
        }

        function updateApiCallDisplay() {
            const counterElement = document.getElementById('api-call-counter');
            if (counterElement) {
                counterElement.textContent = `API Calls: ${placeApiCallCount}`;
            }
        }

        // --- Timeline Rendering ---

        // Creates a single timeline item element for the sidebar
        function createTimelineItem(item, index, currentDate) {
            const timelineItem = document.createElement('div');
            timelineItem.className = 'timeline-item';
            timelineItem.dataset.index = index; // Use the global index
			// --- DEBUG START: Add raw data ---
			/*try {
				// Select the relevant part of the item (visit or activity)
				const rawData = item;
				const jsonString = JSON.stringify(rawData);
				timelineItem.dataset.rawJson = escapeHtml(jsonString); // Add as data attribute
			} catch (e) {
				console.error("Error stringifying or escaping raw data for item:", item, e);
				timelineItem.dataset.rawJson = escapeHtml('{"error": "Could not serialize data"}'); // Add error indicator
			}*/
			// --- DEBUG END: Add raw data ---

            // Check if a date header needs to be added for this date
            const existingHeader = document.querySelector(`.date-header[data-date="${currentDate}"]`);
            if (!existingHeader) {
                const dateHeader = document.createElement('div');
                dateHeader.className = 'date-header';
                dateHeader.dataset.date = currentDate;
                dateHeader.textContent = moment(currentDate).format('dddd, MMMM DD, YYYY'); // Format date nicely
                                  dateHeader.style.cursor = 'pointer'; // Make it look clickable
                                  // Add click event to select this specific day
                                  dateHeader.addEventListener('click', () => {
                                      // Set both date pickers to this specific date
                                      const formattedDate = moment(currentDate).format('YYYY-MM-DD');
                                      document.getElementById('startDatePicker').value = formattedDate;
                                      document.getElementById('endDatePicker').value = formattedDate;
                                      // Load this specific day
                                      const selectedDate = new Date(formattedDate);
                                      loadTimelineDataInDateRange(selectedDate, selectedDate);
                                  });
                // Insert header before the first item of the day or at the end if no items yet
                const firstItemOfDay = document.querySelector(`.timeline-item[data-item-date="${currentDate}"]`);
                if (firstItemOfDay) {
                    document.getElementById('timeline').insertBefore(dateHeader, firstItemOfDay);
                } else {
                    document.getElementById('timeline').appendChild(dateHeader);
                }
            }

            let startTimestamp, endTimestamp;
            let locationName = 'Unknown Location'; // Default name
            let placeTypesForStyle = []; // For sidebar icon styling

            // Populate based on place visit or activity segment
            if (item.visit) { // Handle iOS 'visit' structure
                const visitData = item.visit; // This is the sub-object
                startTimestamp = item.startTime;
                endTimestamp = item.endTime;
                
                // Derive name for iOS visit, prioritizing semanticType "Home" or "Work"
                if (visitData.topCandidate?.semanticType?.toUpperCase() === "HOME") {
                    locationName = "Home";
                } else if (visitData.topCandidate?.semanticType?.toUpperCase() === "WORK") {
                    locationName = "Work";
                } else {
                    locationName = visitData.topCandidate?.name || visitData.topCandidate?.semanticType || 'Unknown Location';
                }
                // For iOS, we don't have 'types' directly in this initial object for styling,
                // it will be fetched later if placeId exists.
                // Default to a generic visit icon for now, will be updated by updateSidebarItem
                const defaultPlaceStyle = getPlaceStyle([]);

                timelineItem.classList.add('place-visit-item');
                timelineItem.innerHTML = `
                     <span class="timeline-icon-container" style="border-color: ${defaultPlaceStyle.color};">${defaultPlaceStyle.icon}</span>
                     <div class="timeline-item-details">
                         <strong class="nametag">${locationName}</strong><br>
                         <span class="timeline-item-time">${moment(startTimestamp).format('hh:mm A')} - ${moment(endTimestamp).format('hh:mm A')}</span>
                     </div>
                 `;
                timelineItem.style.setProperty('--activity-color', defaultPlaceStyle.color);

            } else if (item.placeVisit) { // Handle standard 'placeVisit' structure
                const placeVisit = item.placeVisit;
                startTimestamp = placeVisit.duration.startTimestamp;
                endTimestamp = placeVisit.duration.endTimestamp;

                if (placeVisit.location.semanticType === "TYPE_HOME" || placeVisit.location.name?.toLowerCase() === "home") {
                    locationName = "Home";
                } else if (placeVisit.location.semanticType === "TYPE_WORK" || placeVisit.location.name?.toLowerCase() === "work") {
                    locationName = "Work";
                } else {
                    locationName = placeVisit.location.name || 'Unknown Location';
                }
                placeTypesForStyle = placeVisit.location.placeTypes || []; // Google Takeout might have this
                const placeStyle = getPlaceStyle(placeTypesForStyle);

                timelineItem.classList.add('place-visit-item');
                timelineItem.innerHTML = `
                     <span class="timeline-icon-container" style="border-color: ${placeStyle.color};">${placeStyle.icon}</span>
                     <div class="timeline-item-details">
                         <strong class="nametag">${locationName}</strong><br>
                         <span class="timeline-item-time">${moment(startTimestamp).format('hh:mm A')} - ${moment(endTimestamp).format('hh:mm A')}</span>
                     </div>
                 `;
                 timelineItem.style.setProperty('--activity-color', placeStyle.color);

            } else if (item.activitySegment) { // Handle 'activitySegment' (standard and transformed iOS)
                const activitySegment = item.activitySegment;
                startTimestamp = activitySegment.duration.startTimestamp;
                endTimestamp = activitySegment.duration.endTimestamp;
                const distanceMeters = activitySegment.distance || (activitySegment.simplifiedRawPath && activitySegment.simplifiedRawPath.distanceMeters) || (activitySegment.waypointPath && activitySegment.waypointPath.distanceMeters) || 0;
                const distanceKm = distanceMeters / 1000;
                const activityType = activitySegment.activityType || (activitySegment.activities && activitySegment.activities[0]?.activityType) || (activitySegment.waypointPath && activitySegment.waypointPath.travelMode) || 'UNKNOWN';
                const formattedType = formatActivityType(activityType);
                const activityColor = getActivityColor(activityType);
                timelineItem.innerHTML = `
                     <span class="timeline-icon-container" style="border-color: ${activityColor};">${getActivityIcon(activityType)}</span>
                     <div class="timeline-item-details">
                         <strong>${formattedType}</strong><br>
                         <span class="timeline-item-time">${moment(startTimestamp).format('hh:mm A')} - ${moment(endTimestamp).format('hh:mm A')}</span>
                         <span class="distance">Distance: ${distanceKm.toFixed(2)} km</span>
                     </div>
                 `;
                 timelineItem.style.setProperty('--activity-color', activityColor);
            }

            // Store timestamps and date context on the element
            timelineItem.dataset.startTimestamp = startTimestamp;
            timelineItem.dataset.endTimestamp = endTimestamp;
            timelineItem.dataset.itemDate = currentDate;

            // Add confirmed checkmark if applicable
            if ((item.placeVisit && item.placeVisit.editConfirmationStatus === "CONFIRMED") ||
                (item.activitySegment && item.activitySegment.editConfirmationStatus === "CONFIRMED") ||
                (item.visit && item.visit.editConfirmationStatus === "CONFIRMED")) { // Added check for iOS format
                const checkmark = document.createElement('span');
                checkmark.className = 'confirmed-checkmark';
                checkmark.textContent = '✔️';
                timelineItem.appendChild(checkmark);
            }

            return timelineItem;
        }


        // Clears the timeline sidebar
        function clearTimeline() {
            document.getElementById('timeline').innerHTML = '';
        }

        // --- Map Rendering ---

        // Clears all markers, polylines, and info windows from the map
        function clearMap() {
            markers.forEach(marker => marker.map = null);
            markers = [];
            polylines.forEach(polyline => polyline.setMap(null));
            polylines = [];
            infoWindows.forEach(infoWindow => infoWindow.close());
            infoWindows = [];
            deselectPolyline(); // Also deselect any highlighted polyline
        }
        
        // Helper to parse "geo:lat,lng" strings
        function parseGeoString(geoStr) {
            if (typeof geoStr === 'string' && geoStr.startsWith('geo:')) {
                const parts = geoStr.substring(4).split(',');
                if (parts.length === 2) {
                    const lat = parseFloat(parts[0]);
                    const lng = parseFloat(parts[1]);
                    if (!isNaN(lat) && !isNaN(lng)) {
                        return { lat, lng };
                    }
                }
            }
            return null;
        }

        // Renders a place visit marker (handles both standard and iOS formats)
        function renderPlaceVisit(itemData, index) {
            let locationName, placeId, lat, lng, startTimestamp, endTimestamp, originalVisitData, semanticTypeStr;

            // Adapt based on data structure (standard vs. iOS)
            if (itemData.placeVisit) { // Standard format
                const placeVisit = itemData.placeVisit;
                semanticTypeStr = placeVisit.location.semanticType; // e.g., "TYPE_HOME"
                if (semanticTypeStr === "TYPE_HOME" || placeVisit.location.name?.toLowerCase() === "home") {
                    locationName = "Home";
                } else if (semanticTypeStr === "TYPE_WORK" || placeVisit.location.name?.toLowerCase() === "work") {
                    locationName = "Work";
                } else {
                    locationName = placeVisit.location.name;
                }
                placeId = placeVisit.location.placeId;
                lat = placeVisit.location.latitudeE7 / 1e7;
                lng = placeVisit.location.longitudeE7 / 1e7;
                startTimestamp = placeVisit.duration.startTimestamp;
                endTimestamp = placeVisit.duration.endTimestamp;
                originalVisitData = placeVisit; 
            } else if (itemData.visit) { // iOS format (itemData is the raw timeline object)
                 const visit = itemData.visit; // The 'visit' sub-object
                 semanticTypeStr = visit.topCandidate?.semanticType; // e.g., "Home", "Work"
                 if (semanticTypeStr?.toUpperCase() === "HOME") {
                    locationName = "Home";
                 } else if (semanticTypeStr?.toUpperCase() === "WORK") {
                    locationName = "Work";
                 } else {
                    locationName = visit.topCandidate?.name || visit.topCandidate?.semanticType;
                 }
                 placeId = visit.topCandidate?.placeID;
                 
                 const geoCoords = parseGeoString(visit.topCandidate?.placeLocation);
                 if (geoCoords) {
                    lat = geoCoords.lat;
                    lng = geoCoords.lng;
                 } else if (visit.location?.latitudeE7 && visit.location?.longitudeE7) { // Fallback if geo: parsing fails or not present
                    lat = visit.location.latitudeE7 / 1e7;
                    lng = visit.location.longitudeE7 / 1e7;
                 } else if (visit.centerLatE7 && visit.centerLngE7) { // Another fallback
                    lat = visit.centerLatE7 / 1e7;
                    lng = visit.centerLngE7 / 1e7;
                 }

                 startTimestamp = itemData.startTime;
                 endTimestamp = itemData.endTime;
                 // Create a pseudo-standard structure for consistency downstream
                 originalVisitData = {
                     location: { 
                        name: locationName, 
                        placeId: placeId, 
                        latitudeE7: lat ? lat * 1e7 : undefined, 
                        longitudeE7: lng ? lng * 1e7 : undefined,
                        semanticType: semanticTypeStr // Store the original semantic type
                    },
                     duration: { startTimestamp: startTimestamp, endTimestamp: endTimestamp }
                 };
            } else {
                 console.warn("Unrecognized place visit structure:", itemData);
                 return; 
            }

            const fallbackName = locationName || (lat && lng ? `Location (${lat.toFixed(4)}, ${lng.toFixed(4)})` : 'Unknown Location');

            // Attempt to fetch Place Details if placeId exists and not cached
            if (placeId && !isNaN(lat) && !isNaN(lng)) {
                if (placeDetailsCache[placeId]) {
                    // Use cached details
                    console.log(`Using cached details for placeId: ${placeId}`);
                    renderPlaceDetails(placeDetailsCache[placeId], originalVisitData, index);
                } else if (apiCallsDisabled) {
                    console.log(`API calls disabled. Rendering basic marker for placeId: ${placeId}`);
                    renderBasicMarker(lat, lng, fallbackName, originalVisitData, index);
                    updateSidebarItem(index, fallbackName, null); // Update sidebar with basic info
                } else {
                    // Fetch details using the new API
                    console.log(`Fetching details for placeId: ${placeId}`);
                    fetchPlaceDetails(placeId, fallbackName, originalVisitData, index);
                }
            } else if (!isNaN(lat) && !isNaN(lng)) {
                // No placeId or invalid coords, render a basic marker immediately
                console.log(`Rendering basic marker for: ${fallbackName}`);
                renderBasicMarker(lat, lng, fallbackName, originalVisitData, index);
                // Update sidebar with basic info
                updateSidebarItem(index, fallbackName, null);
            } else {
                 console.warn(`Skipping marker render due to invalid coordinates for: ${fallbackName}`);
            }
        }


        // Renders a simple marker when no Place ID is available or fetch fails
        function renderBasicMarker(lat, lng, name, placeVisit, index) {
            const position = { lat, lng };

            // Check if marker library is loaded
            if (!google.maps.marker || !google.maps.marker.AdvancedMarkerElement) {
                console.error("AdvancedMarkerElement class not loaded.");
                return;
            }
			
			// Create a basic PinElement for a more consistent look with other markers
            const PinElement = google.maps.marker.PinElement;
            let markerContent = null;
            if (PinElement) {
                try {
                    const pinElement = new PinElement({
                        background: '#FF0000', // Red for generic
                        borderColor: '#A00000',
                        glyph: '', // No glyph for basic
                        scale: 0.8 // Slightly smaller
                    });
                    markerContent = pinElement.element;
                } catch(e) {
                    console.warn("Could not create PinElement for basic marker, using default.", e);
                }
            }

            const marker = new AdvancedMarkerElement({
                    position: position,
                    map: map,
                    title: name,
                    content: markerContent // Use PinElement or default if null
                });
                markers.push(marker); 

            // Create InfoWindow content (without photo initially)
                const infoWindowContent = `
                     <div style="max-width: 250px;">
                         <h3 style="margin: 5px 0;">${name}</h3>
                         <p style="margin: 3px 0; font-size: 0.9em;">Lat: ${lat.toFixed(6)}, Lng: ${lng.toFixed(6)}</p>
                         <div class="photo-container" data-place-id="basic-${index}">
                              <div class="photo-placeholder">No photo available</div>
                         </div>
                         <p style="margin: 5px 0; font-size: 0.85em;">${moment(placeVisit.duration.startTimestamp).format("MMM DD, YYYY hh:mm A")} - ${moment(placeVisit.duration.endTimestamp).format("hh:mm A")}</p>
                     <p style="margin-top: 5px; font-size: 0.85em;"><a href="https://maps.google.com/?q=${lat},${lng}" target="_blank">View on Google Maps</a></p>
                     </div>`;

                const infoWindow = new google.maps.InfoWindow({ content: infoWindowContent });
                infoWindow.placeId = null; // No place ID for basic marker
            infoWindow.photoFetched = true; // Mark as "fetched" since there's no photo to fetch
                infoWindows.push(infoWindow);

                // Add listeners
                const sidebarItem = document.querySelector(`.timeline-item[data-index="${index}"]`);
                addMarkerClickListener(marker, infoWindow, index);
                if (sidebarItem) {
                    addSidebarItemClickListener(sidebarItem, index, marker, infoWindow);
                }
        }

        // Fetches place details using the new Place.fetchFields method
        async function fetchPlaceDetails(placeId, fallbackName, placeVisit, index) {
        
            if (apiCallsDisabled) {
                console.log("API calls disabled. Skipping fetchPlaceDetails, rendering basic marker.");
                const lat = placeVisit.location.latitudeE7 / 1e7;
                const lng = placeVisit.location.longitudeE7 / 1e7;
                renderBasicMarker(lat, lng, fallbackName, placeVisit, index);
                updateSidebarItem(index, fallbackName, null, []);
                return;
            }
			
            // Define the fields to fetch (excluding 'photos')
            const fields = [
                'id',                   // Basic identifier
                'displayName',          // New name field
                'formattedAddress',     // New address field
                'location',             // New geometry field (lat/lng)
                'svgIconMaskURI',          // New icon URL field
                'iconBackgroundColor',  // New icon background color field
                'googleMapsURI',
                'types'
            ];

            try {
                const place = new Place({
				  id: placeId,
				  requestedLanguage: "en", // optional
				});

				await place.fetchFields({
				  fields: fields
				});
                incrementApiCallCount(); // Increment API counter for basic details

                //console.log("Place details fetched successfully:", place);
                // Cache the result
                placeDetailsCache[placeId] = place;
                // Render the marker and info window with the fetched details
                renderPlaceDetails(place, placeVisit, index);

            } catch (error) {
                console.warn(`Error fetching place details with fetchFields for placeId ${placeId}:`, error);
                // Fallback to basic marker if details fetch fails
                const lat = placeVisit.location.latitudeE7 / 1e7;
                const lng = placeVisit.location.longitudeE7 / 1e7;
                renderBasicMarker(lat, lng, fallbackName, placeVisit, index);
                updateSidebarItem(index, fallbackName, null, []); // Update sidebar with fallback name
            }
        }


        // Updates the corresponding sidebar item's name and icon
        function updateSidebarItem(index, locationName, svgIconMaskURI, placeTypes) {
            const sidebarItem = document.querySelector(`.timeline-item[data-index="${index}"]`);
            if (sidebarItem && sidebarItem.classList.contains('place-visit-item')) { // Only update place visit items
                const nametag = sidebarItem.querySelector('.nametag');
                if (nametag) nametag.textContent = locationName;

                const iconContainer = sidebarItem.querySelector('.timeline-icon-container');
                if (iconContainer) {
                    let finalIconHtml;
                    let finalBorderColor;

                    if (svgIconMaskURI && !svgIconMaskURI.includes('generic')) {
                        // Try to use Google's icon if available, potentially with a background color derived from types
                        const styleFromTypes = getPlaceStyle(placeTypes);
                        finalIconHtml = `<span class="timeline-icon-svg" style="mask: url('${svgIconMaskURI}') no-repeat center / contain; -webkit-mask: url('${svgIconMaskURI}') no-repeat center / contain; background-color: ${styleFromTypes.color}">`;
                        finalBorderColor = styleFromTypes.color; // Use color from type for border
                    } else {
                        // Fallback to type-based emoji and color
                        const placeStyle = getPlaceStyle(placeTypes);
                        finalIconHtml = placeStyle.icon;
                        finalBorderColor = placeStyle.color;
                    }
                    iconContainer.innerHTML = finalIconHtml;
                    iconContainer.style.borderColor = finalBorderColor;
                    sidebarItem.style.setProperty('--activity-color', finalBorderColor); // Update CSS var for the vertical line
                }
            }
        }

		// Renders the marker and InfoWindow using fetched Place Details (new API)
		async function renderPlaceDetails(place, placeVisit, index) {
            // Determine the display name, prioritizing "Home" or "Work" if applicable
            let displayName = place.displayName;
            const originalSemanticType = placeVisit.location.semanticType; // From original data (e.g., TYPE_HOME or "Home")
            if (originalSemanticType) {
                const upperSemanticType = originalSemanticType.toUpperCase();
                if (upperSemanticType === "HOME" || upperSemanticType === "TYPE_HOME") {
                    displayName = "Home";
                } else if (upperSemanticType === "WORK" || upperSemanticType === "TYPE_WORK") {
                    displayName = "Work";
                }
            }
            const locationName = displayName || placeVisit.location.name || 'Unknown Location';
            const position = place.location; 
            const placeId = place.id; // Use place.id

            // --- Create Marker ---
            const PinElement = google.maps.marker.PinElement;
            if (!AdvancedMarkerElement || !PinElement) {
                 console.error("Marker library classes (AdvancedMarkerElement, PinElement) not loaded.");
                 return;
            }

            let markerContent;
            // Use PinElement if icon data is available
            if (place.svgIconMaskURI && !place.svgIconMaskURI.includes('generic') && place.iconBackgroundColor) {
                try {
                    const pinGlyph = document.createElement('img');
                    pinGlyph.src = place.svgIconMaskURI;
                    pinGlyph.style.width = '18px';
                    pinGlyph.style.height = '18px';
                    //pinGlyph.style.filter = 'invert(100%) sepia(0%) saturate(0%) hue-rotate(0deg) brightness(200%) contrast(100%)'; // Make glyph white

                    const pinElement = new PinElement({
                        background: place.iconBackgroundColor,
                        glyph: pinGlyph, // Use the img element as glyph
                        glyphColor: '#FFFFFF', // Glyph color might not be needed if using image
                        borderColor: '#505050', // Example border color
                        scale: 1.0
                    });
                    markerContent = pinElement.element;
				} catch (e) {
                    console.warn("Could not create PinElement with image glyph, using default marker:", e);
                    // Fallback: create a simpler PinElement without glyph if image fails
                    const fallbackPin = new PinElement({ background: place.iconBackgroundColor || '#4285F4', scale: 0.8 });
                    markerContent = fallbackPin.element;
                }
            } else {
                 // Fallback if no icon URI or background color - use a generic colored pin
                 const fallbackPin = new PinElement({ background: '#ce5140', scale: 0.9 }); // Default
                 markerContent = fallbackPin.element;
            }

            // Create the Advanced Marker
            const marker = new AdvancedMarkerElement({
                position: position,
                map: map,
                content: markerContent, // Use PinElement if created, otherwise default
                title: locationName,
            });
            markers.push(marker);

            // --- Prepare InfoWindow content ---
			let mapsLink;
			try {
				if (place.googleMapsURI) {
					mapsLink = `<a href="${place.googleMapsURI}" target="_blank">View on Google Maps</a>`;
				} else if (position && typeof position.lat === 'function' && typeof position.lng === 'function') {
					mapsLink = `<a href="https://maps.google.com/?q=${position.lat()},${position.lng()}" target="_blank">View on Google Maps</a>`;
				} else if (position && 'lat' in position && 'lng' in position) {
					mapsLink = `<a href="https://maps.google.com/?q=${position.lat},${position.lng}" target="_blank">View on Google Maps</a>`;
				} else {
					throw new Error("No valid location for fallback maps link");
				}
			} catch (e) {
				console.warn("Could not create link, 1:", place);
				console.warn("Could not create link, 2:", e);
			}

            // Always start with the placeholder
            const photoHtml = `<div class="photo-placeholder">Loading photo...</div>`;


            // Use new field names in content
            const infoWindowContent = `
            <div style="max-width: 250px;">
                <h3 style="margin: 5px 0;">${locationName}</h3>
                <p style="margin: 3px 0; font-size: 0.9em;">${place.formattedAddress || ""}</p>
                <div class="photo-container" data-place-id="${placeId}">
                   ${photoHtml}
                </div>
                <p style="margin: 5px 0; font-size: 0.85em;">${moment(placeVisit.duration.startTimestamp).format("MMM DD, YYYY hh:mm A")} - ${moment(placeVisit.duration.endTimestamp).format("hh:mm A")}</p>
                <p style="margin-top: 5px; font-size: 0.85em;">${mapsLink}</p>
            </div>`;

            const infoWindow = new google.maps.InfoWindow({ content: infoWindowContent });
            infoWindow.placeId = placeId; // Store place ID
            infoWindow.photoFetched = false; // Mark photo as NOT fetched initially
            infoWindows.push(infoWindow);

            // Update sidebar item appearance using new svgIconMaskURI
            updateSidebarItem(index, locationName, place.svgIconMaskURI, place.types || []);

            // Add listeners
            const sidebarItem = document.querySelector(`.timeline-item[data-index="${index}"]`);
            addMarkerClickListener(marker, infoWindow, index);
            if (sidebarItem) {
                addSidebarItemClickListener(sidebarItem, index, marker, infoWindow);
            }
		}


        // Renders an activity segment as a polyline on the map
        function renderActivitySegment(activitySegment, index) {
            let path = [];
            const startLat = activitySegment.startLocation?.latitudeE7 / 1e7 || activitySegment.startLocation?.lat; // Support direct lat/lng too
            const startLng = activitySegment.startLocation?.longitudeE7 / 1e7 || activitySegment.startLocation?.lng;
            const endLat = activitySegment.endLocation?.latitudeE7 / 1e7 || activitySegment.endLocation?.lat;
            const endLng = activitySegment.endLocation?.longitudeE7 / 1e7 || activitySegment.endLocation?.lng;

            // Add start point if valid
            if (!isNaN(startLat) && !isNaN(startLng)) path.push({ lat: startLat, lng: startLng });

            // Handle intermediate points from various possible path sources
            let intermediatePoints = activitySegment.simplifiedRawPath?.points || 
                                     activitySegment.timelinePath?.points || 
                                     activitySegment.waypointPath?.waypoints || 
                                     activitySegment.path; // For directly provided path in transformed iOS data
            if (intermediatePoints) {
                intermediatePoints.forEach(point => {
                    const pLat = point.latE7 !== undefined ? point.latE7 / 1e7 : point.lat;
                    const pLng = point.lngE7 !== undefined ? point.lngE7 / 1e7 : point.lng;
                    if (!isNaN(pLat) && !isNaN(pLng)) path.push({ lat: pLat, lng: pLng });
                });
            }

             // Add end point if valid and different from last intermediate point
             if (!isNaN(endLat) && !isNaN(endLng)) {
                 const lastPoint = path[path.length - 1];
                 if (!lastPoint || lastPoint.lat !== endLat || lastPoint.lng !== endLng) {
                     path.push({ lat: endLat, lng: endLng });
                 }
             }

            // Only render if we have at least two points
            if (path.length < 2) {
                 console.log(`Skipping polyline render for index ${index}: Not enough points (${path.length})`);
                 return;
            }

            const activityType = activitySegment.activityType || (activitySegment.activities && activitySegment.activities[0]?.activityType) || (activitySegment.waypointPath && activitySegment.waypointPath.travelMode) || 'UNKNOWN';

            const polyline = new google.maps.Polyline({
                path: path,
                geodesic: true,
                strokeColor: getActivityColor(activityType),
                strokeOpacity: 0.8, // Slightly less opaque for better visibility if overlapping
                strokeWeight: 5, // Default weight
                map: map,
                clickable: true,
                zIndex: 0 // Default zIndex
            });
            polyline.set('originalColor', getActivityColor(activityType)); // Store original color
            polylines.push(polyline); // Keep track

            // Add listeners
            const sidebarItem = document.querySelector(`.timeline-item[data-index="${index}"]`);
            addPolylineClickListener(polyline, sidebarItem, path);
            if (sidebarItem) {
                addSidebarItemClickListener(sidebarItem, index, null, null, polyline, path);
            }
        }

        // --- Map Interaction ---

        // Fetches *only* the photo for an InfoWindow if not already fetched
        async function fetchPhotoForInfoWindow(infoWindow) {
        
			// If API calls are disabled, skip photo fetch
            if (apiCallsDisabled) {
                console.log("API calls disabled. Skipping photo fetch.");
                if (infoWindow && !infoWindow.photoFetched) { // Still update placeholder if not fetched
                    try {
                        const contentNode = document.createElement('div');
                        contentNode.innerHTML = infoWindow.getContent();
                        const photoContainer = contentNode.querySelector(`.photo-container`);
                        if (photoContainer) {
                            photoContainer.innerHTML = '<div class="photo-placeholder">Photos disabled</div>';
                            infoWindow.setContent(contentNode.innerHTML);
                        }
                        infoWindow.photoFetched = true; // Mark as "fetched" (or known unavailable/disabled)
                    } catch (e) { console.error("Error updating infowindow content when API disabled:", e); }
                }
                return;
            }
  
            // Skip if no placeId or photo already fetched/failed
            if (!infoWindow || !infoWindow.placeId || infoWindow.photoFetched) {
                console.log(`Skipping photo fetch for placeId: ${infoWindow?.placeId}. Reason: No placeId or photo already fetched/failed.`);
                // Ensure placeholder shows 'No photo available' if there's no placeId and it hasn't been marked fetched yet
                if (infoWindow && !infoWindow.placeId && !infoWindow.photoFetched) {
                     try {
                        const contentNode = document.createElement('div');
                        contentNode.innerHTML = infoWindow.getContent();
                        const photoContainer = contentNode.querySelector(`.photo-container`);
                        if (photoContainer) {
                            photoContainer.innerHTML = '<div class="photo-placeholder">No photo available</div>';
                            infoWindow.setContent(contentNode.innerHTML);
                        }
                        infoWindow.photoFetched = true; // Mark as fetched (or known unavailable)
                     } catch (e) { console.error("Error updating basic marker infowindow content:", e); }
                }
                return;
            }
            console.log(`Fetching photo for placeId: ${infoWindow.placeId}`);
            const fields = ['photos']; // Request only photos
            try {
                incrementApiCallCount(); // Increment counter for photo fetch
				const place = new Place({
				  id: infoWindow.placeId,
				  requestedLanguage: "en", // optional
				});
				await place.fetchFields({
				  fields: fields
				});
                
                let photoHtml;
                if (place.photos && place.photos.length > 0) {
                    try {
                        const photoUri = place.photos[0].getURI({ maxWidth: 200, maxHeight: 150 });
                        photoHtml = `<img src="${photoUri}" alt="Place photo">`;
                        console.log(`Photo found for ${infoWindow.placeId}`);
                    } catch (e) {
                        console.warn("Error getting photo URI:", e);
                        photoHtml = '<div class="photo-placeholder">Error loading photo</div>';
                    }
                } else {
                    photoHtml = '<div class="photo-placeholder">No photo available</div>';
                    console.log(`No photo found for ${infoWindow.placeId}`);
                }
                // Update the InfoWindow content with the photo or 'no photo' message
                const contentNode = document.createElement('div');
                // IMPORTANT: Get the *current* content in case it was closed/reopened quickly
                contentNode.innerHTML = infoWindow.getContent();
                const photoContainer = contentNode.querySelector(`.photo-container[data-place-id="${infoWindow.placeId}"]`);
                if (photoContainer) {
                    photoContainer.innerHTML = photoHtml;
                    // *** Crucial Step: Update the actual InfoWindow object's content ***
                    infoWindow.setContent(contentNode.innerHTML);
                } else {
                    console.warn("Could not find photo container in InfoWindow content for update, placeId:", infoWindow.placeId);
                }
            } catch (error) {
                console.warn(`Error fetching photos for placeId ${infoWindow.placeId}:`, error);
                // Update placeholder to show error
                try {
                    const contentNode = document.createElement('div');
                    contentNode.innerHTML = infoWindow.getContent();
                    const photoContainer = contentNode.querySelector(`.photo-container[data-place-id="${infoWindow.placeId}"]`);
                    if (photoContainer) {
                        photoContainer.innerHTML = '<div class="photo-placeholder">Error loading photo</div>';
                        infoWindow.setContent(contentNode.innerHTML);
                    }
                } catch (e) { console.error("Error updating infowindow content after photo fetch error:", e); }
            } finally {
                // Mark as fetched regardless of success or failure to prevent re-fetching
                infoWindow.photoFetched = true;
            }
        }

	    // Adds click listener to a marker to open InfoWindow and highlight sidebar
        function addMarkerClickListener(marker, infoWindow, index) {
          marker.addListener('click', async () => {
            if (!marker.map) return; // Don't do anything if marker isn't on map

            // Close other info windows
            infoWindows.forEach(iw => { if (iw !== infoWindow) iw.close(); });

            // Debug info
            console.log(`Marker clicked: Index=${index}, placeId=${infoWindow.placeId}, photoFetched=${infoWindow.photoFetched}`);

            // Fetch photo only if it hasn't been fetched yet
            await fetchPhotoForInfoWindow(infoWindow); // Wait for photo fetch/update
            // Open this info window (content will be updated if photo was fetched)

            infoWindow.open({ map: map, anchor: marker });

            // Highlight corresponding sidebar item
            highlightSidebarItem(index);

            // Deselect any selected polyline
            deselectPolyline();
          });
        }


        // Adds click listener to a polyline to highlight it and the sidebar item
        function addPolylineClickListener(polyline, timelineItem, path) {
            polyline.addListener('click', (e) => { // e is PolyMouseEvent
                if (!polyline.getMap()) return; // Ignore clicks if not on map

                const index = timelineItem ? timelineItem.dataset.index : null;
                if (index !== null) highlightSidebarItem(index);

                selectPolyline(polyline); // Select clicked polyline

                infoWindows.forEach(iw => iw.close()); // Close any open info windows

                // Scroll sidebar item into view
                if (timelineItem) {
                    timelineItem.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }
            });
        }

        // Adds click listener to a sidebar item to interact with the map
        function addSidebarItemClickListener(sidebarItem, index, marker, infoWindow, polyline, path) {
            if (!sidebarItem) return;

            sidebarItem.addEventListener('click', async () => {
                highlightSidebarItem(index); // Highlight this item

                if (marker && infoWindow && marker.map) {
                    // --- Place Visit Click ---
                    map.setCenter(marker.position);
                    map.setZoom(Math.max(map.getZoom(), 15)); // Zoom in if necessary

                    // Close other info windows
                    infoWindows.forEach(iw => { if (iw !== infoWindow) iw.close(); });

                    // Fetch photo only if it hasn't been fetched yet
                    await fetchPhotoForInfoWindow(infoWindow); // Wait for photo fetch/update

                    // Open this info window
                    infoWindow.open({ map: map, anchor: marker });

                    deselectPolyline(); // Deselect any polyline

                } else if (polyline && path?.length > 0 && polyline.getMap()) {
                    // --- Activity Segment Click ---
                    const bounds = new google.maps.LatLngBounds();
                    path.forEach(point => bounds.extend(point));
                    map.fitBounds(bounds, 30); // Fit map to polyline bounds with padding

                    selectPolyline(polyline); // Select this polyline

                    infoWindows.forEach(iw => iw.close()); // Close info windows
                }
            });
        }

        // Highlights a specific sidebar item and scrolls it into view
        function highlightSidebarItem(index) {
            const timelineItems = document.querySelectorAll('.timeline-item');
            document.getElementById('layerOptions').style.display = 'none'; // Hide layer options when an item is clicked

            timelineItems.forEach((item) => {
                if (item.dataset.index === String(index)) {
                    item.classList.add('highlighted');
                    // Scroll into view if not already visible
                    if (!isElementInViewport(item)) {
                        item.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    }
                } else {
                    item.classList.remove('highlighted');
                }
            });
        }

        // Helper function to check if an element is within the timeline's viewport
        function isElementInViewport (el) {
            if (!el) return false;
            const rect = el.getBoundingClientRect();
            const timeline = document.getElementById('timeline'); // Check against timeline scroll container
            const timelineRect = timeline.getBoundingClientRect();

            return (
                rect.top >= timelineRect.top &&
                rect.bottom <= timelineRect.bottom
            );
        }

        // Highlights a polyline (thicker, arrows)
        function selectPolyline(polyline) {
            if (selectedPolyline === polyline) return; // Already selected

            deselectPolyline(); // Deselect previous first

            // Enhance the selected polyline
            polyline.setOptions({
                strokeWeight: 7,
                // Add direction arrows
                icons: [{
                    icon: {
                        path: google.maps.SymbolPath.FORWARD_CLOSED_ARROW,
                        scale: 5, // Size of the arrow
                        strokeColor: '#000',
                        strokeWeight: 2
                    },
                    offset: '50%', // Position in the middle of segments
                    repeat: '90px' // Spacing between arrows
                }],
                zIndex: 1 // Bring to front
            });
            selectedPolyline = polyline;
        }

        // Restores the appearance of the previously selected polyline
        function deselectPolyline() {
            if (selectedPolyline) {
                // Restore original appearance
                selectedPolyline.setOptions({
                    icons: [], // Remove arrows
                    strokeWeight: 5, // Restore original weight
                    strokeOpacity: 0.8,
                    zIndex: 0 // Restore default zIndex
                });
                selectedPolyline = null;
            }
        }

        // Adjusts map bounds to fit all currently visible markers and polylines
        function fitMapToData() {
            if (!uiEnabled || (markers.length === 0 && polylines.length === 0)) return;

            const bounds = new google.maps.LatLngBounds();
            let itemCount = 0;

            // Extend bounds for visible markers
            markers.forEach(marker => {
                if (marker.map && marker.position) { // Check if marker is actually on the map and has position
                    bounds.extend(marker.position);
                    itemCount++;
                }
            });

            // Extend bounds for visible polylines
            polylines.forEach(polyline => {
                if (polyline.getMap()) { // Check if polyline is actually on the map
                    polyline.getPath().forEach(point => bounds.extend(point));
                    itemCount++;
                }
            });

            // Fit map if there are items
            if (itemCount > 0) {
                if (itemCount === 1 && markers.length === 1 && markers[0].map && markers[0].position) {
                    // Single marker: center and set zoom
                    map.setCenter(bounds.getCenter());
                    map.setZoom(15);
                } else if (bounds.getNorthEast().equals(bounds.getSouthWest())) {
                    // Multiple items at the exact same point
                    map.setCenter(bounds.getCenter());
                    map.setZoom(16); // Zoom slightly closer for identical points
                } else {
                    map.fitBounds(bounds, 50); // Fit multiple items with padding (e.g., 50px)
                }
            }
            // If itemCount is 0, do nothing (map remains as is)
        }


        // Helper function to escape HTML special characters for attributes. Used w debug
		function escapeHtml(unsafe) {
			if (!unsafe) return '';
			// Ensure it's a string before replacing
			const str = String(unsafe);
			return str
				 .replace(/&/g, "&amp;")
				 .replace(/</g, "&lt;")
				 .replace(/>/g, "&gt;")
				 .replace(/"/g, "&quot;")
				 .replace(/'/g, "&#039;");
		 }


        // --- Data Loading and Processing ---

        // Loads and renders timeline data for a single date, applying filters
        async function loadTimelineDataForDate(selectedDate) {
            if (!uiEnabled) return;

            const localSelectedDate = moment(selectedDate); // Use local time for date matching
            const year = localSelectedDate.year();
            const month = localSelectedDate.format('MMMM').toUpperCase(); // Use uppercase month name as key
            const dataKey = `${year}_${month}`;

            if (timelineData[dataKey] && timelineData[dataKey].timelineObjects) {
                const selectedDateStr = localSelectedDate.format('YYYY-MM-DD'); // For data attribute

                const relevantData = timelineData[dataKey].timelineObjects.filter(item => {
                    // Determine start/end times consistently across formats
                    let itemStartTime, itemEndTime;
                    if (item.placeVisit) { // Standard format
                        itemStartTime = item.placeVisit.duration?.startTimestamp;
                        itemEndTime = item.placeVisit.duration?.endTimestamp;
                    } else if (item.activitySegment) { // Standard format
                        itemStartTime = item.activitySegment.duration?.startTimestamp;
                        itemEndTime = item.activitySegment.duration?.endTimestamp;
                    } else if (item.visit || item.activity){ // iOS format (check start/end Time at top level)
                        itemStartTime = item.startTime;
                        itemEndTime = item.endTime;
                    }

                    // Skip if timestamps are missing
                    if (!itemStartTime || !itemEndTime) return false;

                    const itemStartMoment = moment(itemStartTime);
                    const itemEndMoment = moment(itemEndTime);

                    // Check if the item overlaps with the selected date
                    if (!itemStartMoment.isSame(localSelectedDate, 'day') &&
                        !itemEndMoment.isSame(localSelectedDate, 'day') &&
                        !(itemStartMoment.isBefore(localSelectedDate, 'day') && itemEndMoment.isAfter(localSelectedDate, 'day'))) {
                        return false; // Does not overlap with the selected date
                    }

                    // Apply layer filters
                    if ((item.placeVisit || item.visit) && !document.getElementById('showVisits').checked) return false; // Check both visit types
                    // Check for activitySegment OR the iOS top-level activity
                    const currentActivitySegment = item.activitySegment || (item.activity ? item : null);
                    if (currentActivitySegment) { // If it's an activity type
                        if (!document.getElementById('showActivities').checked) return false;
                        
                        // Use activityType from activitySegment or directly from iOS item.activity.topCandidate.type
                        const activityType = currentActivitySegment.activitySegment?.activityType || // Standard
                                             (currentActivitySegment.activitySegment?.activities && currentActivitySegment.activitySegment.activities[0]?.activityType) || // Standard with activities array
                                             (currentActivitySegment.activitySegment?.waypointPath && currentActivitySegment.activitySegment.waypointPath.travelMode) || // Standard waypoint
                                             currentActivitySegment.activity?.topCandidate?.type || // iOS
                                             'UNKNOWN';
                        const groupedType = getGroupedActivityType(activityType);
                        const filterCheckbox = document.getElementById(`filter-${groupedType}`);
                        if (filterCheckbox && !filterCheckbox.checked) return false;
                    }

                    return true; // Item is relevant
                });

                // Sort data for the day chronologically
                relevantData.sort((a, b) => {
                    // Determine start times consistently
                    const timeA = moment(a.placeVisit?.duration?.startTimestamp || a.activitySegment?.duration?.startTimestamp || a.startTime);
                    const timeB = moment(b.placeVisit?.duration?.startTimestamp || b.activitySegment?.duration?.startTimestamp || b.startTime);
                    return timeA - timeB;
                });

                // Process and render the relevant data
                let firstLocationSet = false;
                relevantData.forEach((item, localIndex) => {
                    // Center map on the first item of the day
                    if (!firstLocationSet) {
                        let latLng;
                        if (item.placeVisit) {
                            latLng = { lat: item.placeVisit.location.latitudeE7 / 1e7, lng: item.placeVisit.location.longitudeE7 / 1e7 };
                        } else if (item.visit) { // iOS visit
                            const geo = parseGeoString(item.visit.topCandidate?.placeLocation);
                            if (geo) latLng = geo;
                            else if (item.visit.centerLatE7 && item.visit.centerLngE7) latLng = {lat: item.visit.centerLatE7 / 1e7, lng: item.visit.centerLngE7 / 1e7};
                        } else if (item.activitySegment) { // Standard activity
                            if (item.activitySegment.startLocation) {
                                latLng = { lat: item.activitySegment.startLocation.latitudeE7 / 1e7, lng: item.activitySegment.startLocation.longitudeE7 / 1e7 };
                            }
                        } else if (item.activity) { // iOS activity
                            const geo = parseGeoString(item.activity.start);
                            if (geo) latLng = geo;
                        }
                        if (latLng && !isNaN(latLng.lat) && !isNaN(latLng.lng)) {
                            map.setCenter(latLng);
                            map.setZoom(15); // Reasonable zoom for a single location/start point
                            firstLocationSet = true;
                        }
                    }

                    // Create timeline item in sidebar
                    const timelineItem = createTimelineItem(item, globalIndex, selectedDateStr);
                    document.getElementById('timeline').appendChild(timelineItem);

                    // Render corresponding map elements (marker or polyline)
					if (item.placeVisit || item.visit) { 
                        renderPlaceVisit(item, globalIndex); // Pass the whole item
                    } else if (item.activitySegment) { // Standard activity segment
                        renderActivitySegment(item.activitySegment, globalIndex);
                    } else if (item.activity) { // Transformed iOS activity now looks like an activitySegment
                        // This case should be handled by readFilesFromDirectory transforming iOS activities
                        // into the { activitySegment: ... } structure.
                        // If an item with a direct 'activity' property reaches here, it means transformation might have been missed
                        // or the structure is unexpected. For now, we assume it's already transformed.
                        console.warn("Direct iOS activity object encountered in loadTimelineDataForDate. Expected transformed activitySegment.", item);
                    }
                    globalIndex++; // Increment global index for unique identification
                });
            }
            // No else needed, if data for the month isn't loaded, nothing happens for this date.
        }


        // Loads data for a range of dates, clearing previous data first
        async function loadTimelineDataInDateRange(startDate, endDate, showRangeWarning = true) {
             // Ensure map is visible when loading data range
             if (summaryViewVisible) {
                 document.getElementById('summaryView').style.display = 'none';
                 document.getElementById('map').classList.remove('hidden');
                 summaryViewVisible = false;
                 updateViewToggleButtons(); // Update button state
             }

            if (!uiEnabled) return;
            
			// the main check is with the GO button. other calls (like filter changes) don't need another warning
			// this only creates a console warning atm
			if (showRangeWarning) {
				const startMoment = moment.utc(startDate);
				const endMoment = moment.utc(endDate);
				const dayDifference = endMoment.diff(startMoment, 'days');
				if (dayDifference > 62) {
					console.log("Date range warning check in loadTimelineDataInDateRange, difference:", dayDifference);
				}
			}

            clearMap();
            clearTimeline();
            globalIndex = 0; // Reset index for new range
            //placeDetailsCache = {}; // Clear place details cache for new range
            updateApiCallDisplay();

            const startMoment = moment.utc(startDate).startOf('day'); // Use UTC start of day
            const endMoment = moment.utc(endDate).endOf('day'); // Use UTC end of day for comparison

            document.getElementById('loading-overlay').style.display = "flex"; // Show loading spinner

            const promises = [];
            let currentDate = startMoment.clone();

            // Iterate through each day in the range
            while (currentDate.isSameOrBefore(endMoment, 'day')) {
                // Add the promise to load data for the current date
                // No need to await here, just push the async function call
                promises.push(loadTimelineDataForDate(currentDate.toDate()));
                currentDate.add(1, 'days');
            }

            try {
                // Wait for all daily data loads (including async rendering) to complete
                await Promise.all(promises);
            } catch (error) {
                console.error("Error loading data for date range:", error);
                // Potentially show an error message to the user
            } finally {
                // Hide loading spinner regardless of success or failure
                document.getElementById('loading-overlay').style.display = "none";
                document.getElementById('howToMessage').style.display = "none"; // Hide initial message
                document.getElementById('map').classList.remove('hidden'); // Ensure map is visible
                fitMapToData(); // Fit map to the loaded data bounds
                console.log(`Finished loading range. Total API Calls: ${placeApiCallCount}`);
            }
        }

        // --- Summary Calculation & Display ---

        // Calculates yearly and monthly summaries from the loaded timelineData
        function calculateSummaries() {
            console.log("Calculating summaries...");
            const yearly = {};
            const monthly = {};
            const kmConversion = 0.001; // Meters to kilometers

            for (const key in timelineData) {
                if (!timelineData[key].timelineObjects) continue;

                const parts = key.split('_'); // e.g., "2023_JANUARY"
                if (parts.length < 2) continue;

                const yearStr = parts[0];
                const monthStr = parts[1]; // Uppercase month name
                const year = parseInt(yearStr, 10);

                // Convert month name to index (0-11)
                let monthIndex = moment().month(monthStr).format("M") - 1;
                if (monthIndex < 0) continue; // Skip invalid month names

                if (isNaN(year)) continue; // Skip invalid keys

                // Initialize summary objects if they don't exist
                if (!yearly[year]) {
                    yearly[year] = { visits: 0, distanceKm: 0, distanceByActivity: {} };
                }
                if (!monthly[year]) {
                    monthly[year] = {};
                }
                if (!monthly[year][monthIndex]) {
                    monthly[year][monthIndex] = { visits: 0, distanceKm: 0, distanceByActivity: {} };
                }

                // Process each item in the month's data
                timelineData[key].timelineObjects.forEach(item => {
                    if (item.placeVisit || item.visit) { // Count both visit types
                        yearly[year].visits++;
                        monthly[year][monthIndex].visits++;
                    } else if (item.activitySegment) {
                        const segment = item.activitySegment;
                        const distanceMeters = segment.distance || segment.simplifiedRawPath?.distanceMeters || segment.waypointPath?.distanceMeters || 0;
                        const distanceKm = distanceMeters * kmConversion;

                        if (distanceKm > 0) {
							const activityType = segment.activityType || (segment.activities && segment.activities.activityType) || (segment.waypointPath && segment.waypointPath.travelMode) || 'UNKNOWN';
                            const groupedType = getGroupedActivityType(activityType);

                            // Add to yearly summary
                            yearly[year].distanceKm += distanceKm;
                            yearly[year].distanceByActivity[groupedType] = (yearly[year].distanceByActivity[groupedType] || 0) + distanceKm;

                            // Add to monthly summary
                            monthly[year][monthIndex].distanceKm += distanceKm;
                            monthly[year][monthIndex].distanceByActivity[groupedType] = (monthly[year][monthIndex].distanceByActivity[groupedType] || 0) + distanceKm;
                        }
                    }
                });
            }

            allYearlySummaries = yearly;
            allMonthlySummaries = monthly;
            console.log("Summaries calculated:", allYearlySummaries, allMonthlySummaries);
        }

        // Calculates summary specifically for the selected date range
        function calculateSelectedDatesSummary(startDate, endDate) {
            const summary = { visits: 0, distanceKm: 0, distanceByActivity: {} };
            const startMoment = moment.utc(startDate).startOf('day');
            const endMoment = moment.utc(endDate).endOf('day');
            const kmConversion = 0.001;

            let currentDate = startMoment.clone();
            while (currentDate.isSameOrBefore(endMoment, 'day')) {
                const year = currentDate.year();
                const monthKey = currentDate.format('MMMM').toUpperCase();
                const dataKey = `${year}_${monthKey}`;

                if (timelineData[dataKey] && timelineData[dataKey].timelineObjects) {
                    timelineData[dataKey].timelineObjects.forEach(item => {
                         // Determine start/end times consistently
                         let itemStartTime, itemEndTime;
                         if (item.placeVisit) {
                             itemStartTime = item.placeVisit.duration?.startTimestamp;
                             itemEndTime = item.placeVisit.duration?.endTimestamp;
                         } else if (item.activitySegment) {
                             itemStartTime = item.activitySegment.duration?.startTimestamp;
                             itemEndTime = item.activitySegment.duration?.endTimestamp;
                         } else if (item.visit || item.activity) { // iOS top-level
                             itemStartTime = item.startTime;
                             itemEndTime = item.endTime;
                         }
                         if (!itemStartTime || !itemEndTime) return; // Skip if no time

                         const itemStartMoment = moment(itemStartTime);
                         const itemEndMoment = moment(itemEndTime);

                         // Check if the item overlaps with the *current processing day* within the selected range
                         if (!itemStartMoment.isSame(currentDate, 'day') &&
                             !itemEndMoment.isSame(currentDate, 'day') &&
                             !(itemStartMoment.isBefore(currentDate, 'day') && itemEndMoment.isAfter(currentDate, 'day'))) {
                             return; // Skip items not overlapping this specific day
                         }

                         // Item overlaps the current day, add its stats
                         if (item.placeVisit || item.visit ) { // Count both visit types
                             summary.visits++;
                         } else if (item.activitySegment) {
                             const segment = item.activitySegment;
                             const distanceMeters = segment.distance || segment.simplifiedRawPath?.distanceMeters || segment.waypointPath?.distanceMeters || 0;
                             const distanceKm = distanceMeters * kmConversion;
                             if (distanceKm > 0) {
                                 summary.distanceKm += distanceKm;
                                 const activityType = segment.activityType || (segment.activities && segment.activities[0]?.activityType) || (segment.waypointPath && segment.waypointPath.travelMode) || 'UNKNOWN';
                                 const groupedType = getGroupedActivityType(activityType);
                                 summary.distanceByActivity[groupedType] = (summary.distanceByActivity[groupedType] || 0) + distanceKm;
                             }
                         }
                     });
                }
                currentDate.add(1, 'days');
            }
            return summary;
        }

        // Displays the summary for the currently selected date range
        function displaySelectedDatesSummary(startDate, endDate) {
            const container = document.getElementById('summary-selected-dates');
            container.innerHTML = ''; // Clear previous

            const summaryData = calculateSelectedDatesSummary(startDate, endDate);

            const startStr = moment(startDate).format('MMM DD, YYYY');
            const endStr = moment(endDate).format('MMM DD, YYYY');
            const title = startStr === endStr ? startStr : `${startStr} to ${endStr}`;

            const item = document.createElement('div');
            item.className = 'summary-selected-item'; // Use a specific class

            let activityHtml = '<ul>';
            const sortedActivities = Object.keys(summaryData.distanceByActivity).sort((a, b) => summaryData.distanceByActivity[b] - summaryData.distanceByActivity[a]);

            if (sortedActivities.length > 0) {
                sortedActivities.forEach(activityGroup => {
                    const formattedName = activityGroup.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                    const icon = getActivityIcon(activityGroup);
                    activityHtml += `<li>${icon} ${formattedName}: <span>${summaryData.distanceByActivity[activityGroup].toLocaleString(undefined, { minimumFractionDigits: 1, maximumFractionDigits: 1 })} km</span></li>`;
                });
            } else if (summaryData.distanceKm > 0) {
                 activityHtml += '<li>No distance breakdown available</li>';
            } else {
                 activityHtml += '<li>No distance recorded</li>';
            }
            activityHtml += '</ul>';

            item.innerHTML = `
                 <strong>${title}</strong>
                 <div class="summary-details">Visits: <span>${summaryData.visits.toLocaleString()}</span></div>
                 <div class="summary-details">Total Dist: <span>${summaryData.distanceKm.toLocaleString(undefined, { minimumFractionDigits: 1, maximumFractionDigits: 1 })} km</span></div>
                 ${activityHtml}
             `;
            container.appendChild(item);
        }

        // Displays the yearly summary items
        function displayYearSummary() {
            const yearContainer = document.getElementById('summary-years'); // Target the inner div
            const summaryView = document.getElementById('summaryView');
            yearContainer.innerHTML = ''; // Clear previous years

            if (!allYearlySummaries || Object.keys(allYearlySummaries).length === 0) {
                yearContainer.innerHTML = '<p>No summary data available.</p>';
                document.getElementById('summary-months').style.display = 'none';
                document.getElementById('summary-selected-year').textContent = '';
                document.getElementById('backToYearsBtn').style.display = 'none';
                summaryView.classList.remove('expanded-year-active');
                return;
            }

            const sortedYears = Object.keys(allYearlySummaries).map(Number).sort((a, b) => b - a); // Sort descending

            sortedYears.forEach(year => {
                const data = allYearlySummaries[year];
                const item = document.createElement('div');
                item.className = 'summary-year-item';
                item.dataset.year = year;

                // Generate activity breakdown HTML for the year
                let activityHtml = '<ul>';
                const sortedActivities = Object.keys(data.distanceByActivity || {}).sort((a, b) => data.distanceByActivity[b] - data.distanceByActivity[a]);

                if (sortedActivities.length > 0) {
                    sortedActivities.forEach(activityGroup => {
                        const formattedName = activityGroup.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                        const icon = getActivityIcon(activityGroup);
                        activityHtml += `<li>${icon} ${formattedName}: <span>${data.distanceByActivity[activityGroup].toLocaleString(undefined, { minimumFractionDigits: 1, maximumFractionDigits: 1 })} km</span></li>`;
                    });
                } else if (data.distanceKm > 0) {
                     activityHtml += '<li>No distance breakdown available</li>';
                } else {
                     activityHtml += '<li>No distance recorded</li>';
                }
                activityHtml += '</ul>';

                item.innerHTML = `
                     <strong>${year}</strong>
                     <div class="summary-details">Visits: <span>${data.visits.toLocaleString()}</span></div>
                     <div class="summary-details">Total Dist: <span>${data.distanceKm.toLocaleString(undefined, { minimumFractionDigits: 1, maximumFractionDigits: 1 })} km</span></div>
                     ${activityHtml}
                 `;

                // --- Year Click Listener ---
                item.addEventListener('click', () => {
                    // Mark this year as selected and expand it
                    yearContainer.querySelectorAll('.summary-year-item').forEach(el => el.classList.remove('is-selected-year'));
                    item.classList.add('is-selected-year');

                    // Add class to parent to control visibility via CSS
                    summaryView.classList.add('expanded-year-active');

                    // Show months for this year
                    displayMonthSummary(year);

                    // Scroll to the top of the summary view might be helpful
                    summaryView.scrollTop = 0;
                });
                // --- End Year Click Listener ---

                yearContainer.appendChild(item);
            });

            // Initially, ensure the view is not in expanded mode
            summaryView.classList.remove('expanded-year-active');
            document.getElementById('summary-months').style.display = 'none';
            document.getElementById('backToYearsBtn').style.display = 'none';
        }

        // Displays the monthly summary items for a given year
        function displayMonthSummary(year) {
            selectedSummaryYear = year; // Store the currently selected year
            document.getElementById('summary-selected-year').textContent = '('+year+')'; // Update header
            const container = document.getElementById('summary-months');
            container.innerHTML = ''; // Clear previous months

            if (!allMonthlySummaries || !allMonthlySummaries[year] || Object.keys(allMonthlySummaries[year]).length === 0) {
                container.innerHTML = `<p>No monthly data available for ${year}.</p>`;
                return;
            }

            // Sort months chronologically (0-11)
            const sortedMonths = Object.keys(allMonthlySummaries[year]).map(Number).sort((a, b) => a - b);

            sortedMonths.forEach(monthIndex => {
                const data = allMonthlySummaries[year][monthIndex];
                const monthName = moment().month(monthIndex).format("MMMM"); // Get month name
                const item = document.createElement('div');
                item.className = 'summary-month-item';
                item.dataset.year = year;
                item.dataset.month = monthIndex;

                // Generate activity breakdown HTML
                let activityHtml = '<ul>';
                const sortedActivities = Object.keys(data.distanceByActivity).sort((a,b) => data.distanceByActivity[b] - data.distanceByActivity[a]); // Sort by distance desc

                if (sortedActivities.length > 0) {
                     sortedActivities.forEach(activityGroup => {
                         const formattedName = activityGroup.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                         const icon = getActivityIcon(activityGroup);
                         activityHtml += `<li>${icon} ${formattedName}: <span>${data.distanceByActivity[activityGroup].toLocaleString(undefined, { minimumFractionDigits: 1, maximumFractionDigits: 1 })} km</span></li>`;
                     });
                } else if (data.distanceKm > 0) {
                     activityHtml += '<li>No distance breakdown available</li>';
                } else {
                     activityHtml += '<li>No distance recorded</li>';
                }
                activityHtml += '</ul>';

                item.innerHTML = `
                     <strong>${monthName}</strong>
                     <div class="summary-details">Visits: <span>${data.visits.toLocaleString()}</span></div>
                     <div class="summary-details">Total Dist: <span>${data.distanceKm.toLocaleString(undefined, { minimumFractionDigits: 1, maximumFractionDigits: 1 })} km</span></div>
                     ${activityHtml}
                 `;

                 // Add click listener to navigate to this month on the map
                 item.addEventListener('click', () => navigateToMonth(year, monthIndex));

                container.appendChild(item);
            });
             // Ensure the months container is visible (handled by CSS .expanded-year-active)
             document.getElementById('summary-months').style.display = 'flex';
             // Ensure the back button is visible (handled by CSS .expanded-year-active)
             document.getElementById('backToYearsBtn').style.display = 'flex';

        }

        // Navigates from the summary view to the map view for a specific month
        function navigateToMonth(year, monthIndex) {
            console.log(`Navigating to: ${year}-${String(monthIndex + 1).padStart(2, '0')}`);
            // Calculate start and end dates for the selected month
            const startOfMonth = moment.utc({ year: year, month: monthIndex }).startOf('month').format('YYYY-MM-DD');
            const endOfMonth = moment.utc({ year: year, month: monthIndex }).endOf('month').format('YYYY-MM-DD');

            // Update date pickers
            document.getElementById('startDatePicker').value = startOfMonth;
            document.getElementById('endDatePicker').value = endOfMonth;

            // Switch back to map view
            document.getElementById('summaryView').style.display = 'none';
            document.getElementById('map').classList.remove('hidden');
            summaryViewVisible = false;
            updateViewToggleButtons(); // Update button state

            // Trigger data load for the selected month
            document.getElementById('goBtn').click();
        }

        // --- UI Initialization and Event Listeners ---

        // Initializes the date picker controls and listeners
		function initDatePicker() {
			const startDatePicker = document.getElementById('startDatePicker');
			const endDatePicker = document.getElementById('endDatePicker');
			const prevDayBtn = document.getElementById('prevDayBtn');
			const nextDayBtn = document.getElementById('nextDayBtn');
			const goBtn = document.getElementById('goBtn');

			// Set initial dates to today
			const today = moment().format('YYYY-MM-DD');
			startDatePicker.value = today;
			endDatePicker.value = today;

			// Function to navigate days using arrow buttons
			const navigateDays = (days) => {
				if (!uiEnabled) return;

				// Ensure start date is not after end date (can happen if range was > 1 day)
				// If moving back, the end date should also move back by the same amount
				// If moving forward, the end date should also move forward by the same amount
				// The difference between start and end should remain constant.
				const originalStart = moment.utc(startDatePicker.value);
				const originalEnd = moment.utc(endDatePicker.value);
				const diffDays = originalEnd.diff(originalStart, 'days');

				const newStart = moment.utc(startDatePicker.value).add(days, 'days');
				const newEnd = newStart.clone().add(diffDays, 'days'); // Maintain original range duration

				startDatePicker.value = newStart.format('YYYY-MM-DD');
				endDatePicker.value = newEnd.format('YYYY-MM-DD');

				// Load data for the new range (without the 62-day warning for arrow navigation)
				loadTimelineDataInDateRange(newStart.toDate(), newEnd.toDate(), false); // Pass false to skip warning
			};

			prevDayBtn.addEventListener('click', () => navigateDays(-1));
			nextDayBtn.addEventListener('click', () => navigateDays(1));

			// GO button click handler
			goBtn.addEventListener('click', () => {
				if (!uiEnabled) return;
				const startDate = moment.utc(startDatePicker.value); // Keep as moment object for diff
				const endDate = moment.utc(endDatePicker.value);   // Keep as moment object for diff

				// Basic validation: ensure start date is not after end date
				if (startDate.isAfter(endDate)) {
					console.warn("Start date cannot be after end date.");
					alert("Start date cannot be after end date."); // User feedback
					// Clear map/timeline and return
					clearMap();
					clearTimeline();
					globalIndex = 0;
					//placeDetailsCache = {};
					updateApiCallDisplay();
					// Clear summary data as well if needed
					document.getElementById('summary-selected-dates').innerHTML = '';
					document.getElementById('summary-years').innerHTML = '';
					document.getElementById('summary-months').innerHTML = '';
					return;
				}

				// Warn if date range is more than 62 days
				const dayDifference = endDate.diff(startDate, 'days');
				if (dayDifference > 62) {
					const userConfirmation = confirm(`The selected date range is ${dayDifference + 1} days. Loading this much data might cause a large number of API calls. Do you want to continue?`);
					if (!userConfirmation) {
						return; // User cancelled
					}
				}

				loadTimelineDataInDateRange(startDate.toDate(), endDate.toDate(), true); // Pass true or remove for default warning behavior in loadTimelineDataInDateRange if needed
			});
		}

        // Populates the activity filter checkboxes based on loaded data
		function populateActivityFilters() {
			const activityFilters = document.getElementById('activityFilters');
			activityFilters.innerHTML = ''; // Clear existing filters

			// Collect unique *grouped* activity types from all loaded data
			const uniqueGroupedTypes = new Set();
			Object.values(timelineData).forEach(monthData => {
				monthData.timelineObjects?.forEach(item => {
					let rawActivityType = 'UNKNOWN'; // Default

					// After readFilesFromDirectory, both standard Google Takeout data and
					// transformed iOS data should have an item.activitySegment structure.
					if (item.activitySegment) {
						rawActivityType = item.activitySegment.activityType ||
										 (item.activitySegment.activities && item.activitySegment.activities[0]?.activityType) ||
										 (item.activitySegment.waypointPath && item.activitySegment.waypointPath.travelMode) ||
										 'UNKNOWN'; // Default if no specific type found within activitySegment
					}
					// This else if block is a fallback for data that might not have been transformed as expected,
					else if (item.activity?.topCandidate?.type) { // Check for raw iOS-like structure if no activitySegment
						// console.warn("Encountered item.activity structure directly in populateActivityFilters. Data might not be fully transformed:", JSON.stringify(item).substring(0,200));
						rawActivityType = item.activity.topCandidate.type;
					}
					let processedActivityType;
					if (typeof rawActivityType === 'string') {
						processedActivityType = rawActivityType.trim().toUpperCase();
					}

					// If rawActivityType was not a string, or became empty after trim, default to 'UNKNOWN'
					if (!processedActivityType) {
						processedActivityType = 'UNKNOWN';
					}

					const groupedType = getGroupedActivityType(processedActivityType);

					uniqueGroupedTypes.add(groupedType);
				});
			});

			// Sort types alphabetically, putting UNKNOWN last
			const sortedGroupedTypes = Array.from(uniqueGroupedTypes).sort((a, b) => {
				if (a === 'UNKNOWN') return 1; // Move UNKNOWN to the end
				if (b === 'UNKNOWN') return -1;
				return a.localeCompare(b); // Alphabetical sort for others
			});

			// Create checkboxes for each type (excluding STATIONARY)
			sortedGroupedTypes.forEach(groupType => {
				if (groupType === 'STATIONARY') return; // Skip STATIONARY filter

				const label = document.createElement('label');
				label.className = 'layer-option';
				const formattedName = groupType.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());

				label.innerHTML = `
					 <input type="checkbox" id="filter-${groupType}" class="layer-checkbox activity-filter-checkbox" checked data-group-type="${groupType}">
					 <span style="color:${getActivityColor(groupType)}; margin-right: 4px;">${getActivityIcon(groupType)}</span>
					 ${formattedName}
				 `;
				activityFilters.appendChild(label);

				// Add event listener to reload data when filter changes
				const checkbox = label.querySelector('input');
				checkbox.addEventListener('change', () => {
					if (!uiEnabled) return;

					// Update the main "Show Activities" checkbox based on individual filters
					const allActivityFilters = activityFilters.querySelectorAll('.activity-filter-checkbox');
					document.getElementById('showActivities').checked = [...allActivityFilters].some(cb => cb.checked);

					// Reload data with current date range and new filters
					const startDate = new Date(document.getElementById('startDatePicker').value);
					const endDate = new Date(document.getElementById('endDatePicker').value);
					loadTimelineDataInDateRange(startDate, endDate, false);
				});
			});
		}

        // Initializes the layer button and its options panel
        function initLayerButton() {
            const layerBtn = document.getElementById('layerBtn');
            const layerOptions = document.getElementById('layerOptions');
            const closeLayerBtn = document.getElementById('closeLayerBtn');
            const showActivitiesCheckbox = document.getElementById('showActivities');
            const showVisitsCheckbox = document.getElementById('showVisits');
            const activityFiltersDiv = document.getElementById('activityFilters');

            // Toggle layer options visibility
            layerBtn.addEventListener('click', () => {
                if (!uiEnabled) return;
                layerOptions.style.display = layerOptions.style.display === 'none' ? 'block' : 'none';
            });

            // Close layer options
            closeLayerBtn.addEventListener('click', () => layerOptions.style.display = 'none');

            // Function to reload data based on current filters and date range
            const reloadData = () => {
                if (!uiEnabled) return;
                const startDate = new Date(document.getElementById('startDatePicker').value);
                const endDate = new Date(document.getElementById('endDatePicker').value);
                loadTimelineDataInDateRange(startDate, endDate);
            };

            // Reload data when "Show Visits" changes
            showVisitsCheckbox.addEventListener('change', reloadData);

            // Handle "Show Activities" master checkbox change
            showActivitiesCheckbox.addEventListener('change', function() {
                if (!uiEnabled) return;
                const isChecked = this.checked;
                // Check/uncheck all individual activity filters
                activityFiltersDiv.querySelectorAll('.activity-filter-checkbox').forEach(checkbox => checkbox.checked = isChecked);
                // Reload data
                reloadData();
            });
        }

        // Initializes the "Fit Map" button
        function initFitMapButton() {
            document.getElementById('fitMapBtn').addEventListener('click', fitMapToData);
        }

        // Initializes the Summary View buttons and interactions
        function initSummaryView() {
             const summaryBtn = document.getElementById('summaryBtn');
             const closeSummaryBtn = document.getElementById('closeSummaryBtn');
             const summaryView = document.getElementById('summaryView');
             const mapElement = document.getElementById('map');
             const mapBtn = document.getElementById('mapBtn'); // Get map button
             const backBtn = document.getElementById('backToYearsBtn');

             // Toggle Summary View on button click
             summaryBtn.addEventListener('click', () => {
                 if (!uiEnabled) return;

                 if (!summaryViewVisible) {
                     // Calculate summaries if not already done
                     if (!allYearlySummaries) {
                         calculateSummaries();
                     }
                     // Display the summary sections
                     displaySelectedDatesSummary( // Display selected range summary
                         new Date(document.getElementById('startDatePicker').value),
                         new Date(document.getElementById('endDatePicker').value)
                     );
                     // Display years, reset expanded view state
                     displayYearSummary();
                     summaryView.classList.remove('expanded-year-active'); // Ensure not expanded initially

                     summaryView.style.display = 'block';
                     mapElement.classList.add('hidden');
                     summaryViewVisible = true;
                 }
                 // No else needed, clicking again doesn't hide it, use close or map button

                 updateViewToggleButtons(); // Update button active state
             });

             // Close Summary View
             closeSummaryBtn.addEventListener('click', () => {
                 summaryView.style.display = 'none';
                 mapElement.classList.remove('hidden');
                 summaryViewVisible = false;
                 updateViewToggleButtons(); // Update button active state
             });

             // Switch to Map View using Map button
             mapBtn.addEventListener('click', () => {
                 if (!uiEnabled) return; // Only if UI is enabled
                 if (summaryViewVisible) { // Only act if summary is currently visible
                     summaryView.style.display = 'none';
                     mapElement.classList.remove('hidden');
                     summaryViewVisible = false;
                     updateViewToggleButtons(); // Update button active state
                 }
             });

             // Back to Years button listener
             backBtn.addEventListener('click', () => {
                 summaryView.classList.remove('expanded-year-active');
                 // Remove specific selected class from the year item
                 const selectedYearItem = summaryView.querySelector('.summary-year-item.is-selected-year');
                 if (selectedYearItem) {
                     selectedYearItem.classList.remove('is-selected-year');
                 }
                 // No need to re-display years, they are just hidden/shown by CSS
                 document.getElementById('summary-months').innerHTML = '<p>Select a year above.</p>'; // Clear months
                 document.getElementById('summary-selected-year').textContent = ''; // Clear month header
                 document.getElementById('backToYearsBtn').style.display = 'none';
             });
         }

        // Updates the active state of the Map/Summary toggle buttons
        function updateViewToggleButtons() {
            const summaryBtn = document.getElementById('summaryBtn');
            const mapBtn = document.getElementById('mapBtn');

            if (summaryViewVisible) {
                summaryBtn.classList.add('active');
                mapBtn.classList.remove('active');
            } else {
                summaryBtn.classList.remove('active');
                mapBtn.classList.add('active');
            }
        }
        
        function initCacheControls() {
            const disableApiBtn = document.getElementById('disableApiBtn');
            const saveCacheBtn = document.getElementById('saveCacheBtn');

            disableApiBtn.addEventListener('click', () => {
                apiCallsDisabled = !apiCallsDisabled;
                disableApiBtn.textContent = apiCallsDisabled ? 'API Disabled' : 'Disable API';
                disableApiBtn.classList.toggle('active', apiCallsDisabled);
                console.log(`API calls ${apiCallsDisabled ? 'disabled' : 'enabled'}.`);
                if (!apiCallsDisabled){
					document.getElementById('goBtn').click();
                }
            });

            saveCacheBtn.addEventListener('click', () => {
                if (Object.keys(placeDetailsCache).length === 0) {
                    alert("Cache is empty. Nothing to save.");
                    return;
                }
                try {
                    const jsonData = JSON.stringify(placeDetailsCache, null, 2); // Pretty print JSON
                    const blob = new Blob([jsonData], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = 'TimelinePlaceCache.json';
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    console.log("Place details cache saved.");
                } catch (error) {
                    console.error("Error saving cache:", error);
                    alert("Could not save cache data. See console for details.");
                }
            });
        }

        // Enables or disables UI controls based on whether data is loaded
        function setUIEnabled(enabled) {
            uiEnabled = enabled;
            const elementsToToggle = [
                document.getElementById('startDatePicker'),
                document.getElementById('endDatePicker'),
                document.getElementById('prevDayBtn'),
                document.getElementById('nextDayBtn'),
                document.getElementById('goBtn'),
                document.getElementById('layerBtn'),
                document.getElementById('fitMapBtn'),
                document.getElementById('summaryBtn'),
                document.getElementById('mapBtn'),
                document.getElementById('saveCacheBtn')
            ];
            elementsToToggle.forEach(el => { if(el) el.disabled = !enabled; });

            // Also enable/disable layer filter checkboxes
            const layerCheckboxes = document.querySelectorAll('#layerOptions input[type="checkbox"]');
            layerCheckboxes.forEach(cb => cb.disabled = !enabled);

            if (!enabled) {
                // Reset state when UI is disabled (e.g., no data loaded)
                document.getElementById('data-source-indicator').textContent = 'No data loaded. Use "Choose Folder".';
                clearMap();
                clearTimeline();
                document.getElementById('layerOptions').style.display = 'none';
                document.getElementById('summaryView').style.display = 'none'; // Hide summary view
                document.getElementById('map').classList.remove('hidden'); // Ensure map is visible
                summaryViewVisible = false;
                updateViewToggleButtons(); // Ensure map button is active
                allYearlySummaries = null; // Clear summary data
                allMonthlySummaries = null;
                selectedSummaryYear = null;
                updateApiCallDisplay();
                document.getElementById('activityFilters').innerHTML = ''; // Clear activity filters
                 // Reset summary view state
                 document.getElementById('summaryView').classList.remove('expanded-year-active');
                 document.getElementById('summary-months').style.display = 'none';
                 document.getElementById('backToYearsBtn').style.display = 'none';
            } else {
                 updateViewToggleButtons(); // Ensure correct button is active when enabled
            }
        }

        // Reads files from the selected directory (handles Takeout structure and single Timeline.json)
        async function readFilesFromDirectory(dirHandle, isRecursive=false) {
            let timelineJsonFile = null;
            let dataSourceText = 'Unknown';
            let placeCacheFile = null;

            // Reset global state ONLY on the initial, non-recursive call
            if (!isRecursive) {
                console.log("Initial call to readFilesFromDirectory, resetting globals...");
                globalIndex = 0;
                timelineData = {}; // Reset main data object
                activityTypes = new Set(); // Reset activity types
                //placeDetailsCache = {}; // Reset cache
                allYearlySummaries = null; // Reset summary data
                allMonthlySummaries = null;
                selectedSummaryYear = null;
                updateApiCallDisplay();
                // Show loading overlay and disable UI only on initial call
                document.getElementById('loading-overlay').style.display = "flex";
                setUIEnabled(false);
            }

            try {
                // --- Step 1: Scan for Timeline.json and TimelinePlaceCache.json at current level (non-recursive) ---
                if (!isRecursive) {
                    for await (const entry of dirHandle.values()) {
                        if (entry.kind === 'file') {
                            if (entry.name.toLowerCase() === 'timeline.json') {
                                timelineJsonFile = entry;
                            } else if (entry.name.toLowerCase() === 'timelineplacecache.json') {
                                placeCacheFile = entry;
                            }
                        }
                        if (timelineJsonFile && placeCacheFile) break; // Found both, no need to look further
                    }

                    // Load Place Details Cache if found
                    if (placeCacheFile) {
                        console.log("Found TimelinePlaceCache.json, attempting to load...");
                        try {
                            const file = await placeCacheFile.getFile();
                            const content = await file.text();
                            const cachedData = JSON.parse(content);
                            if (typeof cachedData === 'object' && cachedData !== null) {
                                placeDetailsCache = cachedData; // Load into global cache
                                console.log(`Successfully loaded ${Object.keys(placeDetailsCache).length} entries from TimelinePlaceCache.json.`);
                            } else {
                                console.warn("TimelinePlaceCache.json does not contain a valid JSON object. Ignoring.");
                                placeDetailsCache = {};
                            }
                        } catch (cacheError) {
                            console.error("Error reading or parsing TimelinePlaceCache.json:", cacheError);
                            alert("Error loading TimelinePlaceCache.json. It might be corrupted. Proceeding without cached place data.");
                            placeDetailsCache = {};
                        }
                    } else {
                         console.log("TimelinePlaceCache.json not found. Will rely on API calls or existing session cache.");
                         if (!isRecursive) placeDetailsCache = {};
                    }
                }

                // --- Step 2: Process single Timeline.json if found ---
                if (timelineJsonFile) {
                    console.log("Found Timeline.json, attempting to parse...");
                    const file = await timelineJsonFile.getFile();
                    const content = await file.text();
                    const jsonData = JSON.parse(content); // Renamed to jsonData to avoid conflict
                    const processedData = {}; 

                    // --- Handle iOS JSON Array Format ---
                    if (Array.isArray(jsonData)) {
                        dataSourceText = 'Local Timeline.json (iOS Format)';
                        console.log('Processing iOS Format Timeline.json...');
                        jsonData.forEach(item => {
                            if (!item || !item.startTime || !item.endTime) return; // Basic check

                            const startTimestamp = item.startTime;
                            const date = new Date(startTimestamp);
                            if (isNaN(date.getTime())) return; 

                            const key = `${date.getFullYear()}_${moment(date).format('MMMM').toUpperCase()}`;
                            if (!processedData[key]) processedData[key] = { timelineObjects: [] };

                            let processedItem = { ...item }; // Clone item to avoid modifying original if needed elsewhere

                            if (item.visit) { // iOS Visit Object
                                // No specific transformation needed here for 'visit' itself,
                                // downstream functions (createTimelineItem, renderPlaceVisit) will handle its structure.
                                // Ensure lat/lng parsing happens in renderPlaceVisit for 'geo:' string
                                if (item.visit.topCandidate?.placeLocation) {
                                   // console.log("iOS visit with placeLocation:", item.visit.topCandidate.placeLocation);
                                }
                            } else if (item.activity) { // iOS Activity Object
                                const activityData = item.activity;
                                const transformedActivity = {
                                    duration: { startTimestamp: item.startTime, endTimestamp: item.endTime },
                                    activityType: activityData.topCandidate?.type?.toUpperCase() || 'UNKNOWN',
                                    distance: activityData.distanceMeters ? parseFloat(activityData.distanceMeters) : 0,
                                    startLocation: {},
                                    endLocation: {},
                                    // No direct path data in iOS spec, so simplifiedRawPath will be empty or rely on start/end
                                    simplifiedRawPath: { points: [] } 
                                };

                                const startGeo = parseGeoString(activityData.start);
                                if (startGeo) {
                                    transformedActivity.startLocation = { latitudeE7: startGeo.lat * 1e7, longitudeE7: startGeo.lng * 1e7, lat: startGeo.lat, lng: startGeo.lng };
                                    transformedActivity.simplifiedRawPath.points.push({lat: startGeo.lat, lng: startGeo.lng});
                                }
                                const endGeo = parseGeoString(activityData.end);
                                if (endGeo) {
                                    transformedActivity.endLocation = { latitudeE7: endGeo.lat * 1e7, longitudeE7: endGeo.lng * 1e7, lat: endGeo.lat, lng: endGeo.lng };
                                    // Ensure end point is added to path if different from start
                                    if (!startGeo || (startGeo.lat !== endGeo.lat || startGeo.lng !== endGeo.lng)) {
                                       transformedActivity.simplifiedRawPath.points.push({lat: endGeo.lat, lng: endGeo.lng});
                                    }
                                }
                                // Replace the original item with the transformed activitySegment structure
                                processedItem = { activitySegment: transformedActivity };
                                activityTypes.add(transformedActivity.activityType);
                            }
                            processedData[key].timelineObjects.push(processedItem);
                        });
                        timelineData = processedData; 
                        console.log('iOS Format Timeline.json processed successfully.');


                    // --- Handle Standard Timeline Object Format ---
                    } else if (jsonData.timelineObjects) {
                        dataSourceText = 'Local Timeline.json (Standard Format)';
                        console.log('Processing Standard Format Timeline.json...');
                        jsonData.timelineObjects.forEach(item => {
                            const timestamp = item.placeVisit?.duration?.startTimestamp || item.activitySegment?.duration?.startTimestamp;
                            if (!timestamp) return;
                            const date = new Date(timestamp);
                            if (isNaN(date.getTime())) return; // Skip invalid dates
                            const key = `${date.getFullYear()}_${moment(date).format('MMMM').toUpperCase()}`;
                            if (!processedData[key]) processedData[key] = { timelineObjects: [] };
                            processedData[key].timelineObjects.push(item);
                            if (item.activitySegment?.activityType) activityTypes.add(item.activitySegment.activityType);
							else if (item.activitySegment?.activities && item.activitySegment.activities[0]?.activityType) {
                                activityTypes.add(item.activitySegment.activities[0].activityType);
                            }
                        });
                        timelineData = processedData; // Assign grouped data
                        console.log('Standard Format Timeline.json processed successfully.');

                    // --- Handle Semantic History Format ---
                    } else if (jsonData.semanticSegments) {
                        dataSourceText = 'Local Timeline.json (Semantic Format)';
                        console.log('Processing Semantic History format...');
                         // Populate the timelinePath points from every timelinePath object first
                         const allPathPoints = []; // Array to hold all path points with time
                         jsonData.semanticSegments.forEach(segment => {
                             if (segment.timelinePath) {
                                 segment.timelinePath.forEach(point => {
                                     try {
                                         const latLngMatch = point.point?.match(/(-?\d+\.\d+)\s*°,\s*(-?\d+\.\d+)/);
                                         const time = point.time;
                                         if (latLngMatch && time) {
                                             const lat = parseFloat(latLngMatch[1]);
                                             const lng = parseFloat(latLngMatch[2]);
                                             if (!isNaN(lat) && !isNaN(lng)) {
                                                 allPathPoints.push({
                                                     latE7: Math.round(lat * 1e7),
                                                     lngE7: Math.round(lng * 1e7),
                                                     time: time // Keep original timestamp string
                                                 });
                                             }
                                         }
                                     } catch (e) {
                                         console.warn("Error parsing timelinePath point:", point, e);
                                     }
                                 });
                             }
                         });
                         // Sort path points by time
                         allPathPoints.sort((a, b) => moment(a.time).valueOf() - moment(b.time).valueOf());
                         let pathPointPointer = 0; // Pointer for efficient matching

                         const processedTimelineObjects = jsonData.semanticSegments.map(segment => {
                             const startTime = segment.startTime;
                             const endTime = segment.endTime;
                             if (!startTime || !endTime) return null;

                             // Process Place Visit Segment
                             if (segment.visit?.topCandidate?.placeLocation?.latLng && segment.visit?.topCandidate?.placeId) {
                                 const latLngMatch = segment.visit.topCandidate.placeLocation.latLng.match(/(-?\d+\.\d+)\s*°,\s*(-?\d+\.\d+)/);
                                 if (!latLngMatch) return null;
                                 const lat = parseFloat(latLngMatch[1]);
                                 const lng = parseFloat(latLngMatch[2]);
                                 if (isNaN(lat) || isNaN(lng)) return null;
                                 return {
                                     placeVisit: { // Create standard placeVisit structure
                                         location: {
                                             latitudeE7: Math.round(lat * 1e7),
                                             longitudeE7: Math.round(lng * 1e7),
                                             placeId: segment.visit.topCandidate.placeId,
                                             semanticType: segment.visit.topCandidate.semanticType || null,
                                             name: segment.visit.topCandidate.name || 'Unknown Location'
                                         },
                                         duration: { startTimestamp: startTime, endTimestamp: endTime },
                                         editConfirmationStatus: segment.visit.editConfirmationStatus
                                     }
                                 };
                             // Process Activity Segment
                             } else if (segment.activity?.topCandidate?.type && segment.activity?.start?.latLng && segment.activity?.end?.latLng) {
                                 const startLatLngMatch = segment.activity.start.latLng.match(/(-?\d+\.\d+)\s*°,\s*(-?\d+\.\d+)/);
                                 const endLatLngMatch = segment.activity.end.latLng.match(/(-?\d+\.\d+)\s*°,\s*(-?\d+\.\d+)/);
                                 if (!startLatLngMatch || !endLatLngMatch) return null;
                                 const startLat = parseFloat(startLatLngMatch[1]);
                                 const startLng = parseFloat(startLatLngMatch[2]);
                                 const endLat = parseFloat(endLatLngMatch[1]);
                                 const endLng = parseFloat(endLatLngMatch[2]);
                                 if (isNaN(startLat) || isNaN(startLng) || isNaN(endLat) || isNaN(endLng)) return null;

                                 const activitySegment = { // Create standard activitySegment structure
                                     activityType: segment.activity.topCandidate.type || 'UNKNOWN',
                                     duration: { startTimestamp: startTime, endTimestamp: endTime },
                                     distance: segment.activity.distanceMeters, // Use provided distance
                                     startLocation: { latitudeE7: Math.round(startLat * 1e7), longitudeE7: Math.round(startLng * 1e7) },
                                     endLocation: { latitudeE7: Math.round(endLat * 1e7), longitudeE7: Math.round(endLng * 1e7) },
                                     editConfirmationStatus: segment.activity.editConfirmationStatus,
                                     simplifiedRawPath: { // Structure expected by rendering function
                                         distanceMeters: segment.activity.distanceMeters, // Include distance here too
                                         points: []
                                     }
                                 };
                                 // Efficiently find associated path points
                                 const segmentStartMoment = moment(startTime);
                                 const segmentEndMoment = moment(endTime);
                                 for (let i = pathPointPointer; i < allPathPoints.length; i++) {
                                     const pointTime = moment(allPathPoints[i].time);
                                     if (pointTime.isBefore(segmentStartMoment)) {
                                         pathPointPointer = i + 1; continue; // Advance pointer past old points
                                     }
                                     if (pointTime.isAfter(segmentEndMoment)) {
                                         break; // Done finding points for this segment
                                     }
                                     // Point is within the segment's time range
                                     activitySegment.simplifiedRawPath.points.push({ // Ensure E7 format for points
                                         latE7: allPathPoints[i].latE7,
                                         lngE7: allPathPoints[i].lngE7,
                                         // timestampMs: pointTime.valueOf() // Optional: add timestamp if needed later
                                     });
                                 }
                                 activityTypes.add(activitySegment.activityType);
                                 return { activitySegment: activitySegment };
                             }
                             return null; // Return null for segments that can't be processed
                         }).filter(Boolean); // Remove null entries

                         // Group by year and month
                         processedTimelineObjects.forEach(item => {
                             const timestamp = item.placeVisit ? item.placeVisit.duration.startTimestamp : item.activitySegment.duration.startTimestamp;
                             const date = new Date(timestamp);
                             if (isNaN(date.getTime())) return;
                             const key = `${date.getFullYear()}_${moment(date).format('MMMM').toUpperCase()}`;
                             if (!processedData[key]) processedData[key] = { timelineObjects: [] };
                             processedData[key].timelineObjects.push(item);
                             if (item.activitySegment) activityTypes.add(item.activitySegment.activityType);
                         });
                         timelineData = processedData; // Assign grouped data
                         console.log('Semantic Timeline.json processed successfully.');

                    } else {
                        throw new Error("Timeline.json does not contain known data structure (timelineObjects, semanticSegments, or iOS array).");
                    }

                } else {
                    // --- Step 3: Fallback to recursive directory reading (Takeout Monthly Files) ---
                    dataSourceText = 'Google Takeout (Monthly Files)';
                    console.log("Timeline.json not found at top level, scanning for YYYY_MONTH.json files...");
                    let fileFoundInThisLevel = false; // Track if files are found at the current level/recursion

                    for await (const entry of dirHandle.values()) {
                        if (entry.kind === 'file' && entry.name.endsWith('.json') && /^\d{4}_\w+\.json$/i.test(entry.name)) {
                            // Process monthly file directly (YYYY_MONTH.json)
                            fileFoundInThisLevel = true; // Mark that we found a file here
                            console.log(`Processing ${entry.name}`);
                            const file = await entry.getFile();
                            const content = await file.text();
                            try {
                                const data = JSON.parse(content);
                                const fileNameKey = entry.name.split('.')[0].toUpperCase(); // Use YYYY_MONTH as key
                                if (data.timelineObjects) {
                                    // Directly add to the global timelineData object
                                    timelineData[fileNameKey] = data;
                                    // Collect activity types
                                    data.timelineObjects.forEach(item => {
                                        if (item.activitySegment?.activityType) {
                                            activityTypes.add(item.activitySegment.activityType);
                                        } else if (item.activitySegment?.activities && item.activitySegment.activities[0]?.activityType) {
                                            activityTypes.add(item.activitySegment.activities[0].activityType.toUpperCase());
										}
                                    });
                                } else {
                                    console.warn(`Skipping file ${entry.name}: Does not contain 'timelineObjects'.`);
                                }
                            } catch (parseError) {
                                console.warn(`Skipping file ${entry.name} due to JSON parsing error:`, parseError.message);
                            }
                        } else if (entry.kind === 'directory') {
                            // Make recursive call for subdirectories (e.g., year folders)
                            console.log(`Recursively checking directory: ${entry.name}`);
                            // Await the recursive call to ensure all subfolders are processed before proceeding
                            await readFilesFromDirectory(entry, true);
                        }
                    }

                     // Check if *any* valid files were found ONLY on the initial call if no Timeline.json was processed
                     if (!isRecursive && !timelineJsonFile && Object.keys(timelineData).length === 0) {
                         throw new Error("No valid timeline data files (Timeline.json or YYYY_MONTH.json) found in the selected folder or subfolders.");
                     }
                }

                // --- Step 4: Post Loading (only on initial call) ---
                if (!isRecursive) {
                    if (Object.keys(timelineData).length > 0) {
                        console.log("Data loading complete. Enabling UI.");
                        document.getElementById('data-source-indicator').innerHTML = 'Data source: ' + dataSourceText + '<br>' +
                            (placeCacheFile ? ` (Cache: ${Object.keys(placeDetailsCache).length} entries)` : ' (No cache file loaded)');
                        populateActivityFilters(); // Populate filters based on loaded data
                        setUIEnabled(true); // Enable UI elements

                        // Perform initial data load for the default date range
                        const startDate = new Date(document.getElementById('startDatePicker').value);
                        const endDate = new Date(document.getElementById('endDatePicker').value);
                         await loadTimelineDataInDateRange(startDate, endDate); // Await initial load

                    } else {
                        // No data was successfully loaded
                        document.getElementById('data-source-indicator').innerHTML = 'No valid timeline data found.';
                        setUIEnabled(false); // Keep UI disabled
                        alert("No valid timeline data could be loaded from the selected folder.");
                    }
                }

            } catch (err) {
                console.error('Error processing directory:', err);
                 if (!isRecursive) { // Show error and disable UI on initial call failure
                     alert(`Error processing folder: ${err.message}`);
                     setUIEnabled(false);
                 }
                 // Don't re-throw if recursive, allow parent to handle
            } finally {
                 // Hide loading overlay ONLY on the initial, non-recursive call completion
                 if (!isRecursive) {
                     document.getElementById('loading-overlay').style.display = "none";
                 }
            }
        }

        // Initializes the "Choose Folder" button
        async function initFolderPicker() {
            const folderPicker = document.getElementById('folderPicker');
            // Check if showDirectoryPicker is supported
            if ('showDirectoryPicker' in window) {
                folderPicker.addEventListener('click', async () => {
                    try {
                        // Options for directory picker
                        const opts = { mode: 'read' }; // Request read access
                        // Show the directory picker dialog
                        const dirHandle = await window.showDirectoryPicker(opts);
                        // Start processing the selected directory
                        await readFilesFromDirectory(dirHandle); // Pass the handle to the processing function
                    } catch (err) {
                        // Handle errors, including user cancellation
                        if (err.name === 'AbortError') {
                            console.log('Folder selection cancelled by user.');
                        } else {
                            console.error('Error selecting folder:', err);
                            alert(`Could not select folder: ${err.message}`);
                        }
                         // Ensure loading overlay is hidden if selection fails/is cancelled before processing starts
                         document.getElementById('loading-overlay').style.display = "none";
                         // Keep UI disabled if it failed before any data was loaded
                         if(Object.keys(timelineData).length === 0) setUIEnabled(false);
                    }
                });
            } else {
                 // Fallback or message for unsupported browsers
                 folderPicker.disabled = true;
                 folderPicker.textContent = 'Folder Picker Not Supported';
                 console.warn('window.showDirectoryPicker is not supported in this browser.');
                 alert('Your browser does not support the File System Access API needed to select folders. Please try a different browser (like Chrome or Edge).');
            }
        }

        // --- Window Load ---
        window.onload = async () => { 
            // Check if the API key placeholder is still present
            if (window.GOOGLE_MAPS_API_KEY === "YOUR_API_KEY") {
                alert("Please replace 'YOUR_API_KEY' in the HTML (near the top of the <script> block) with your actual Google Maps API Key.");
                // Optionally, disable functionality or hide the map
                document.getElementById('howToMessage').innerHTML = "<h3>Configuration Error</h3><p>Please set your Google Maps API key in the HTML file to use this tool.</p>";
                document.getElementById('howToMessage').style.display = "block";
                // Disable controls if API key is not set
                setUIEnabled(false); 
                const folderPicker = document.getElementById('folderPicker');
                if(folderPicker) folderPicker.disabled = true; // Also disable folder picker explicitly
                return; // Stop further execution
            }


            try {
                await initMap();
                initDatePicker();
                initFolderPicker(); // This now checks for browser support
                initLayerButton();
                initFitMapButton();
                initSummaryView(); // Initialize Summary View Listeners & Buttons
                initCacheControls();
                setUIEnabled(false); // Start with UI disabled
                updateApiCallDisplay(); // Initialize counter display

                // Add global key listeners for date navigation
                document.addEventListener('keydown', (e) => {
                    if (!uiEnabled) return; // Only act if UI is enabled

                    // Check if the event target is an input field to avoid interference
                    const targetTagName = e.target.tagName.toLowerCase();
                    if (targetTagName === 'input' || targetTagName === 'textarea' || targetTagName === 'select') {
                        return; // Don't navigate if typing in an input
                    }

                    // Navigate using arrow keys
                    if (e.key === 'ArrowLeft') {
                        e.preventDefault(); // Prevent default browser behavior (like scrolling)
                        document.getElementById("prevDayBtn").click();
                    } else if (e.key === 'ArrowRight') {
                        e.preventDefault(); // Prevent default browser behavior
                        document.getElementById("nextDayBtn").click();
                    }
                });
            } catch (error) {
                 console.error("Error during initialization:", error);
                 alert("An error occurred during map initialization. Please check your API key and network connection.");
            }
        };
    </script>
</body>
</html>
