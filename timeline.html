<!DOCTYPE html>
<html lang="en">
	<!-- -----

	 Be sure to set your API key in place of "YOUR_API_KEY"

	 Version: April 1, 2025
	 Full details here:
	 https://github.com/kurupted/google-maps-timeline-viewer/

	----  -->
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Google Maps Timeline Viewer</title>
    <script src="https://maps.googleapis.com/maps/api/js?key=YOUR_API_KEY&libraries=marker,places"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.29.1/moment.min.js"></script>
    <style>
        body, html {
            height: 100%;
            margin: 0;
            font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            background-color: #f8f9fa;
            overflow: hidden; /* Prevent body scroll */
        }
        a {
            color: #007bff;
            text-decoration:none;
        }
        a:hover {
            text-decoration:underline;
        }
        #container {
            display: flex;
            height: 100%;
            position: relative;
        }
        #sidebar {
            width: 350px;
            background-color: #ffffff;
            border-right: 1px solid #dee2e6;
            display: flex;
            flex-direction: column; /* Stack elements vertically */
            height: 100%; /* Ensure sidebar takes full height */
            overflow: hidden; /* Prevent sidebar itself from scrolling */
            position: relative; /* Ensure sidebar stays in flow */
            z-index: 60; /* Keep sidebar above summary view background if needed */
        }
        /* --- Control Sections (Non-scrolling) --- */
        #controls-container,
        #layerOptions,
        #datePickerContainer,
        #icon-buttons-container,
        #go-container {
            padding: 10px 12px;
            border-bottom: 1px solid #e9ecef;
            flex-shrink: 0; /* Prevent these sections from shrinking */
            background-color: #ffffff; /* Ensure background */
        }
        #controls-container {
          display: flex;
          align-items: center;
          gap: 8px;
        }
        .control-btn {
            flex-grow:1;
            padding: 10px 15px;
            background-color: #5A95F5;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: background-color 0.2s ease, box-shadow 0.2s ease;
            text-align: center;
        }
        .control-btn:hover:not(:disabled) {
            background-color: #4a85e5;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .control-btn:disabled {
            background: #ced4da;
            cursor: not-allowed;
            color: #6c757d;
        }
        #layerOptions {
            display: none; /* Initially hidden */
        }
         #layerOptionsHeader {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        #layerOptions h4 {
            margin-top: 0;
            margin-bottom: 10px;
            font-weight: 500;
        }
        #layerOptions label {
            display: block;
            margin-bottom: 8px;
            font-size: 14px;
        }
        .layer-option {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
        }
        .layer-checkbox {
            margin-right: 8px;
        }
         #closeLayerBtn {
            padding: 4px 10px;
            font-size: 12px;
            cursor: pointer;
            background-color: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            color: #495057;
        }
        #closeLayerBtn:hover {
            background-color: #e9ecef;
        }
        #activityFilters {
            margin-left: 20px;
            padding-top: 5px;
        }
        #datePickerContainer {
          display: flex;
          align-items: center;
          justify-content: space-between;
          gap: 6px;
        }
        #startDatePicker, #endDatePicker {
            flex: 1;
            padding: 8px 10px;
            border: 1px solid #ced4da;
            border-radius: 4px;
            font-size: 12px;
            background-color: #fff;
        }
        #startDatePicker:disabled, #endDatePicker:disabled {
             background-color: #e9ecef;
             cursor: not-allowed;
        }
        #datePickerContainer span {
            color: #6c757d;
        }
        #dateToSpan {
            font-size: 10px;
        }
        #prevDayBtn, #nextDayBtn {
          background: #f8f9fa;
          border: 1px solid #ced4da;
          border-radius: 4px;
          padding: 2px 4px;
          cursor: pointer;
          font-size: 10px;
          color: #495057;
          transition: all 0.2s ease;
        }
        #prevDayBtn:hover:not(:disabled), #nextDayBtn:hover:not(:disabled) {
          background: #e9ecef;
          color: #343a40;
        }
        #prevDayBtn:disabled, #nextDayBtn:disabled {
            background: #e9ecef;
            color: #adb5bd;
            cursor: not-allowed;
        }
        /* --- Icon Buttons --- */
        #icon-buttons-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding-top: 8px;
            padding-bottom: 8px;
            min-height: 30px;
        }
        #icon-buttons-left, #icon-buttons-right {
            display: flex;
            gap: 2px;
        }
        .icon-btn {
            background: none;
            border: none;
            font-size: 18px;
            padding: 5px;
            cursor: pointer;
            color: #6c757d;
            border-radius: 4px;
            transition: background-color 0.2s ease, color 0.2s ease;
        }
        .icon-btn:hover:not(:disabled) {
            background-color: #e9ecef;
            color: #343a40;
        }
         .icon-btn:disabled {
            color: #adb5bd;
            cursor: not-allowed;
        }
        .icon-btn.active {
            background-color: #e9ecef;
        }
        #go-container {
          display: flex;
          align-items: center;
          justify-content: center;
          padding-top: 5px;
        }
        #goBtn {
            flex-grow: 1;
            padding: 12px 20px;
            background-color: #48a765;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 15px;
            font-weight: 500;
            transition: background-color 0.2s ease, box-shadow 0.2s ease;
        }
        #goBtn:hover:not(:disabled) {
             background-color: #218838;
             box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        #goBtn:disabled {
            background: #ced4da;
            color: #6c757d;
            cursor: not-allowed;
        }
         #goBtn:disabled:hover {
            background: #ced4da;
            box-shadow: none;
        }
        /* --- Timeline (Scrollable Area) --- */
        #timeline {
            flex-grow: 1; /* Allow timeline to fill remaining vertical space */
            overflow-y: auto; /* Make ONLY the timeline scrollable */
            padding: 10px 12px;
            padding-top:0px;
            background-color: #f8f9fa;
        }
        /* --- Sticky Date Header --- */
        #timeline .date-header{
            display: flex;
            align-items: center;
            margin-bottom: 10px;
            padding: 8px 10px;
            background-color: #cccccc;
            position: sticky; /* Enable sticky behavior */
            top: 0; /* Stick to the top of the #timeline container */
            z-index: 10; /* Ensure it stays above timeline items */
            font-weight: 600;
            border-bottom: 1px solid #dee2e6;
            font-size: 14px;
            color: #192027;
        }
        .timeline-item {
            display: flex;
            align-items: flex-start;
            margin-bottom: 8px;
            padding: 8px;
            background-color: #ffffff;
            border: 1px solid #e9ecef;
            border-radius: 5px;
            cursor: pointer;
            position: relative;
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
        }
        .timeline-item:hover {
            border-color: #adb5bd;
        }
        .timeline-icon-container {
            width: 32px;
            text-align: center;
            padding-right: 10px;
            padding-top: 2px;
            flex-shrink: 0;
        }
        .timeline-item-details {
            flex-grow: 1;
        }
         .timeline-item-details strong {
             font-weight: 500;
             font-size: 15px;
             color: #343a40;
         }
        .timeline-item-details div {
            font-size: 14px;
            line-height: 1.4;
            color: #495057;
        }
        .timeline-item-time {
             display: block;
             font-size: 12px;
             color: #6c757d;
             margin-top: 2px;
             margin-bottom: 4px;
        }
        /* Specific style for distance */
        .timeline-item-details .distance {
            font-size: 12px;
            color: #6c757d;
        }
        .place-visit-item {
            background-color: #fffacd;
             border-left: 4px solid #ffc107;
             padding-left: 10px;
        }
        /* Adjust Activity Segment border */
         .timeline-item:not(.place-visit-item) { /* Target activity segments */
            border-left: 4px solid var(--activity-color, #6c757d);
            padding-left: 10px;
        }
        .highlighted {
            border-color: #007bff !important;
            box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.25);
        }
        .confirmed-checkmark {
            position: absolute;
            bottom: 5px;
            right: 8px;
            font-size: 12px;
            opacity: 0.3;
            color: #28a745;
        }
        .highlighted .confirmed-checkmark{
            opacity: 0.6;
        }
        /* --- Bottom Sidebar Elements (Non-scrolling) --- */
        #data-source-indicator,
        #about {
            font-size: 11px;
            padding: 8px 12px;
            color: #6c757d;
            text-align: center;
            border-top: 1px solid #e9ecef;
            flex-shrink: 0;
            background-color: #ffffff;
        }
        #data-source-indicator {
            /* margin-top: auto; Let timeline push it down */
        }
        #about {
             margin-top: auto; /* Pushes About link to the very bottom */
             border-top: none; /* Remove double border if indicator is shown */
             padding-top: 0;
        }
        #map {
            flex-grow: 1;
            height: 100%;
            position: relative; /* Needed for absolute positioning of summary view */
            transition: opacity 0.3s ease; /* Smooth map fade */
        }
        /* --- Advanced Marker (if needed, seems okay) --- */
        .advanced-marker { display: flex; flex-direction: column; align-items: center; }
        .marker-icon { font-size: 24px; }
        .marker-label { font-size: 12px; white-space: nowrap; }
        /* --- Summary View Styles --- */
        #summaryView,
        #howToMessage {
            position: absolute; /* Position over the map area */
            top: 0;
            left: 351px; /* Sidebar width (350px) + border (1px) */
            right: 0;
            bottom: 0;
            background-color: #f8f9fa; /* Match sidebar scroll background */
            z-index: 50; /* Above map, below loading overlay */
            padding: 20px;
            padding-left:40px;
            overflow-y: auto; /* Scroll if content overflows */
            border-left: 1px solid #dee2e6; /* Match sidebar border */
            font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
        }
        #summary-controls {
            text-align: right;
            margin-bottom: 10px;
        }
        #closeSummaryBtn {
            background: none;
            border: 1px solid #ccc;
            border-radius: 50%;
            cursor: pointer;
            font-size: 16px;
            line-height: 1;
            width: 24px;
            height: 24px;
            color: #666;
            padding: 0;
        }
        #closeSummaryBtn:hover {
            background-color: #eee;
            border-color: #aaa;
        }
        #summaryView h4 {
             margin-top: 15px;
             margin-bottom: 8px;
             border-bottom: 1px solid #e0e0e0;
             padding-bottom: 5px;
             font-weight: 500;
             color: #333;
        }
         #summaryView h4:first-of-type {
             margin-top: 0;
         }
        #summary-years, #summary-months {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }
        .summary-year-item, .summary-month-item {
            border: 1px solid #ced4da;
            padding: 10px;
            border-radius: 5px;
            background-color: #ffffff;
            cursor: pointer;
            transition: background-color 0.2s ease, border-color 0.2s ease;
            min-width: 120px; /* Ensure items have some width */
            font-size: 13px;
        }
        .summary-year-item:hover, .summary-month-item:hover {
             border-color: #adb5bd;
             background-color: #f1f3f4;
        }
        .summary-year-item.selected {
            border-color: #007bff;
            background-color: #e7f1ff;
            font-weight: bold;
        }
        .summary-year-item strong, .summary-month-item strong {
            display: block;
            font-size: 16px;
            margin-bottom: 5px;
            color: #0056b3;
        }
        .summary-month-item strong {
             color: #1a73e8;
        }
		.summary-details {
			display: flex;
			justify-content: space-between;
			align-items: center;
			font-size: 12px;
			color: #495057;
			margin-top: 3px;
		}
		.summary-details span {
			text-align: right;
		}
        .summary-month-item ul {
            list-style: none;
            padding: 0;
            margin: 8px 0 0 0;
            font-size: 11px;
            color: #6c757d;
        }
        .summary-month-item ul li {
			display: flex;
			justify-content: space-between;
			align-items: center;
		}
        .summary-month-item li {
             margin-bottom: 2px;
        }
         .summary-month-item li span {
             color: #343a40;
             font-weight: 500;
         }
        /* Style to hide map when summary is shown */
        #map.hidden {
            opacity: 0;
            pointer-events: none; /* Prevent interaction with hidden map */
        }
        /* --- Loading Overlay --- */
        #loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            display: none; /* Initially hidden */
            z-index: 1000; /* Ensure above summary view */
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 1.2em;
        }
        #loading-spinner {
            border: 8px solid #f3f3f3;
            border-top: 8px solid #5A95F5;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1.5s linear infinite;
            margin-bottom: 15px;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="sidebar">
            <div id="controls-container">
                <button id="folderPicker" class="control-btn">Choose Folder</button>
                <button id="layerBtn" class="control-btn" disabled>Layers</button>
                <button id="fitMapBtn" class="control-btn" disabled>Fit Map</button>
            </div>
            <div id="layerOptions" style="display: none;">
                <div id="layerOptionsHeader">
                    <h4>View Options</h4>
                    <button id="closeLayerBtn">Close</button>
                </div>
                <label>
                    <input type="checkbox" id="showVisits" class="layer-checkbox" checked> Show Visits
                </label>
                <label>
                    <input type="checkbox" id="showActivities" class="layer-checkbox" checked> Show Activities
                </label>
                <div id="activityFilters" style="margin-left: 20px;">
                        <!-- Activity filters will be populated here -->
                    </div>
            </div>
            <div id="datePickerContainer">
                <button id="prevDayBtn" disabled><</button>
                <input type="date" id="startDatePicker" disabled>
                <span id="dateToSpan">to</span>
                <input type="date" id="endDatePicker" disabled>
                <button id="nextDayBtn" disabled>></button>
            </div>
            <div id="icon-buttons-container">
                <div id="icon-buttons-left">
					<button id="mapBtn" class="icon-btn" title="Show Map" disabled>üó∫Ô∏è</button>
                    <button id="summaryBtn" class="icon-btn" title="Show Summary" disabled>üìä</button>
                </div>
                <div id="icon-buttons-right">
                    </div>
            </div>
            <div id="go-container">
                <button id="goBtn" class="control-btn" disabled>GO</button>
            </div>
            <div id="loading-overlay">
                <div id="loading-spinner"></div>
                <span>Loading data...</span>
            </div>
            <div id="timeline"></div> 
            <div id="data-source-indicator">No data loaded. Use "Choose Folder".</div>
            <div id="about"><a href="https://github.com/kurupted/google-maps-timeline-viewer/" target="_blank">View project on Github</a></div>
        </div>
        <div id="summaryView">
             <div id="summary-controls">
                <button id="closeSummaryBtn" title="Close Summary">&times;</button>
            </div>
            <h4>Yearly Summary</h4>
            <div id="summary-years">
                <p>Calculating...</p>
            </div>
            <h4>Monthly Summary (<span id="summary-selected-year"></span>)</h4>
            <div id="summary-months">
                 <p>Select a year above.</p>
            </div>
        </div>
        <div id="map" class="hidden"></div>
        <div id="howToMessage">
			<h3>How to use:</h3>
			First, complete the initial setup as explained on the <a href="https://github.com/kurupted/google-maps-timeline-viewer/" target="_blank">Github project page</a>.<br><br>
			Click "Choose Folder" on the left and navigate to the folder that contains your Timeline data.<br>
			<h4>For Google Takeout data:</h4>
			The folder structure should be "Takeout\Location History (Timeline)\Semantic Location History".<br>
			Navigate into the "Semantic Location History" folder, and then click "Select Folder" on the dialog.<br>
			(Do not navigate into one of the yearly subfolders.)<br>
			<h4>For On-Device exported data:</h4>
			Simply choose the folder that contains your exported Timeline.json file.<br>
			(On non-English systems, the filename may be different -- rename the file to Timeline.json)
			<br><br><br><br>
			After the data has loaded, use the date picker to choose a date or date range that contains timeline data.<br>
		</div>
    </div>
    <script>
        let map;
        let markers = [];
        let polylines = [];
        let infoWindows = [];
        let selectedPolyline = null;
        let timelineData = {};
        let activityTypes = new Set(); // Keep track of unique activity types
        let placeDetailsCache = {}; // Cache for storing Place Details
        let globalIndex = 0; // Global counter for unique data-index
        let uiEnabled = false; // Flag to track if UI is enabled

        // Summary View Globals
        let allYearlySummaries = null;
        let allMonthlySummaries = null;
        let selectedSummaryYear = null;
        let summaryViewVisible = false;

        // --- Activity Type Mapping ---
        const activityGroupMapping = {
            'DRIVING': ['IN_VEHICLE', 'IN_PASSENGER_VEHICLE'],
            'TAXI': ['IN_TAXI'],
            'MOTORCYCLING': ['MOTORCYCLING'],
            'CYCLING': ['ON_BICYCLE', 'CYCLING'],
            'WALKING': ['ON_FOOT', 'WALKING', 'WALKING_NORDIC'],
            'HIKING': ['HIKING'],
            'RUNNING': ['RUNNING'],
            'BUS': ['IN_BUS'],
            'SUBWAY': ['IN_SUBWAY'],
            'TRAIN': ['IN_TRAIN'],
            'TRAM': ['IN_TRAM'],
            'FERRY': ['IN_FERRY'],
            'STATIONARY': ['STILL'],
            'FLYING': ['FLYING'],
            'CABLECAR': ['IN_CABLECAR'],
            'FUNICULAR': ['IN_FUNICULAR'],
            'GONDOLA_LIFT': ['IN_GONDOLA_LIFT'],
            'WHEELCHAIR': ['IN_WHEELCHAIR'],
            'SNOWMOBILE': ['SNOWMOBILE'],
            'BOATING': ['BOATING'],
            'CATCHING_POKEMON': ['CATCHING_POKEMON'],
            'HORSEBACK_RIDING': ['HORSEBACK_RIDING'],
            'KAYAKING': ['KAYAKING'],
            'KITESURFING': ['KITESURFING'],
            'PARAGLIDING': ['PARAGLIDING'],
            'ROWING': ['ROWING'],
            'SAILING': ['SAILING'],
            'SKATEBOARDING': ['SKATEBOARDING'],
            'SKATING': ['SKATING'],
            'SKIING': ['SKIING'],
            'SLEDDING': ['SLEDDING'],
            'SNOWBOARDING': ['SNOWBOARDING'],
            'SNOWSHOEING': ['SNOWSHOEING'],
            'SURFING': ['SURFING'],
            'SWIMMING': ['SWIMMING'],
            'UNKNOWN': ['UNKNOWN', 'UNKNOWN_ACTIVITY_TYPE', 'TILTING']
        };

        // Reverse mapping for easy lookup: RawType -> GroupName
        const rawToGroupMapping = {};
        for (const groupName in activityGroupMapping) {
            activityGroupMapping[groupName].forEach(rawType => {
                rawToGroupMapping[rawType] = groupName;
            });
        }
        function getGroupedActivityType(rawType) {
            return rawToGroupMapping[rawType] || 'UNKNOWN'; // Default to UNKNOWN if not found
        }
        // --- End Activity Type Mapping ---

        function initMap() {
            map = new google.maps.Map(document.getElementById('map'), {
                center: {
                    lat: 25.034170396411103,
                    lng: 121.56456035320929
                },
                zoom: 12,
                mapId: "TIMELINE_MAP"
            });
        }

        function getActivityIcon(activityType) {
            let group = (activityType in activityGroupMapping) ? activityType : getGroupedActivityType(activityType);
            switch (group) {
                case 'DRIVING': case 'TAXI': return 'üöó';
                case 'MOTORCYCLING': return 'üèçÔ∏è';
                case 'CYCLING': return 'üö¥';
                case 'WALKING': return 'üö∂';
                case 'RUNNING': return 'üèÉ';
                case 'HIKING': return 'ü•æ';
                case 'BUS': return 'üöå';
                case 'SUBWAY': return 'üöá';
                case 'TRAIN': return 'üöÜ';
                case 'TRAM': return 'üöä';
                case 'FERRY': return '‚õ¥Ô∏è';
                case 'STATIONARY': return 'üõë';
                case 'FLYING': return '‚úàÔ∏è';
                case 'CABLECAR': return 'üö†';
                case 'FUNICULAR': return 'üöû';
                case 'GONDOLA_LIFT': return 'üö°';
                case 'WHEELCHAIR': return '‚ôø';
                case 'SNOWMOBILE': return 'üöú';
                case 'BOATING': return 'üö§';
                case 'CATCHING_POKEMON': return 'üëæ'; // Using alien monster
                case 'HORSEBACK_RIDING': return 'üêé';
                case 'KAYAKING': return 'üõ∂';
                case 'KITESURFING': return 'üèÑ‚Äç‚ôÇÔ∏è';
                case 'PARAGLIDING': return 'ü™Ç';
                case 'ROWING': return 'üö£';
                case 'SAILING': return '‚õµ';
                case 'SKATEBOARDING': return 'üõπ';
                case 'SKATING': return '‚õ∏Ô∏è';
                case 'SKIING': return '‚õ∑Ô∏è';
                case 'SLEDDING': return 'üõ∑';
                case 'SNOWBOARDING': return 'üèÇ';
                case 'SNOWSHOEING': return '‚ùÑÔ∏è';
                case 'SURFING': return 'üèÑ';
                case 'SWIMMING': return 'üèä';
                case 'UNKNOWN':
                    switch (activityType) { case 'TILTING': return 'üì±'; default: return '‚ùì'; }
                default: return '‚ùì';
            }
        }

        function createTimelineItem(item, index, currentDate) {
            const timelineItem = document.createElement('div');
            timelineItem.className = 'timeline-item';
            timelineItem.dataset.index = index;
            // Check if a date header needs to be added
            const existingHeader = document.querySelector(`.date-header[data-date="${currentDate}"]`);
            if (!existingHeader) {
                const dateHeader = document.createElement('div');
                dateHeader.className = 'date-header';
                dateHeader.dataset.date = currentDate;
                dateHeader.textContent = moment(currentDate).format('dddd, MMMM DD, YYYY');
                const firstItemOfDay = document.querySelector(`.timeline-item[data-item-date="${currentDate}"]`);
                if (firstItemOfDay) {
                        document.getElementById('timeline').insertBefore(dateHeader, firstItemOfDay);
                } else {
                    document.getElementById('timeline').appendChild(dateHeader);
                }
            }
            let startTimestamp, endTimestamp;
            if (item.placeVisit) {
                const placeVisit = item.placeVisit;
                startTimestamp = placeVisit.duration.startTimestamp;
                endTimestamp = placeVisit.duration.endTimestamp;
                const locationName = placeVisit.location.name || (placeVisit.location.semanticType === "TYPE_HOME" ? "Home" : 'Unknown location');
                timelineItem.classList.add('place-visit-item');
                timelineItem.innerHTML = `
                        <span class="timeline-icon-container">üìç</span>
                        <div class="timeline-item-details">
                            <strong class="nametag">${locationName}</strong><br>
                            <span class="timeline-item-time">${moment(startTimestamp).format('hh:mm A')} - ${moment(endTimestamp).format('hh:mm A')}</span>
                        </div>
                    `;
                timelineItem.style.setProperty('--activity-color', '#ffc107'); // Yellow for visits
            } else if (item.activitySegment) {
                const activitySegment = item.activitySegment;
                startTimestamp = activitySegment.duration.startTimestamp;
                endTimestamp = activitySegment.duration.endTimestamp;
                const distanceMeters = activitySegment.distance || (activitySegment.simplifiedRawPath && activitySegment.simplifiedRawPath.distanceMeters) || 0;
                const distanceKm = distanceMeters / 1000;
                const formattedType = formatActivityType(activitySegment.activityType);
                timelineItem.innerHTML = `
                        <span class="timeline-icon-container">${getActivityIcon(activitySegment.activityType)}</span>
                        <div class="timeline-item-details">
                            <strong>${formattedType}</strong><br>
                            <span class="timeline-item-time">${moment(startTimestamp).format('hh:mm A')} - ${moment(endTimestamp).format('hh:mm A')}</span>
                            <span class="distance">Distance: ${distanceKm.toFixed(2)} km</span>
                        </div>
                    `;
                const activityColor = getActivityColor(activitySegment.activityType);
                timelineItem.style.setProperty('--activity-color', activityColor);
            }
            timelineItem.dataset.startTimestamp = startTimestamp;
            timelineItem.dataset.endTimestamp = endTimestamp;
            timelineItem.dataset.itemDate = currentDate; // Store the date context
            if ((item.placeVisit && item.placeVisit.editConfirmationStatus === "CONFIRMED") ||
                (item.activitySegment && item.activitySegment.editConfirmationStatus === "CONFIRMED")) {
                const checkmark = document.createElement('span');
                checkmark.className = 'confirmed-checkmark';
                checkmark.textContent = '‚úîÔ∏è';
                timelineItem.appendChild(checkmark);
            }
            return timelineItem;
        }

        async function loadTimelineDataForDate(selectedDate) {
            if (!uiEnabled) return;
            const localSelectedDate = moment(selectedDate);
            const year = localSelectedDate.year();
            const month = localSelectedDate.format('MMMM').toUpperCase();
            const dataKey = `${year}_${month}`;
            if (timelineData[dataKey] && timelineData[dataKey].timelineObjects) {
                const selectedDateStr = localSelectedDate.format('YYYY-MM-DD');
                const relevantData = timelineData[dataKey].timelineObjects.filter(item => {
                    const itemStartMoment = moment(item.placeVisit ? item.placeVisit.duration.startTimestamp : item.activitySegment.duration.startTimestamp);
                    const itemEndMoment = moment(item.placeVisit ? item.placeVisit.duration.endTimestamp : item.activitySegment.duration.endTimestamp);
                    if (!itemStartMoment.isSame(localSelectedDate, 'day') && !itemEndMoment.isSame(localSelectedDate, 'day') && !(itemStartMoment.isBefore(localSelectedDate, 'day') && itemEndMoment.isAfter(localSelectedDate, 'day'))) {
                        return false;
                    }
                    if (item.placeVisit && !document.getElementById('showVisits').checked) return false;
                    if (item.activitySegment && !document.getElementById('showActivities').checked) return false;
                    if (item.activitySegment) {
                        const groupedType = getGroupedActivityType(item.activitySegment.activityType);
                        const filterCheckbox = document.getElementById(`filter-${groupedType}`);
                        if (filterCheckbox && !filterCheckbox.checked) return false;
                    }
                    return true;
                });
                let firstLocationSet = false;
                relevantData.sort((a, b) => {
                    const timeA = moment(a.placeVisit ? a.placeVisit.duration.startTimestamp : a.activitySegment.duration.startTimestamp);
                    const timeB = moment(b.placeVisit ? b.placeVisit.duration.startTimestamp : b.activitySegment.duration.startTimestamp);
                    return timeA - timeB;
                });
                relevantData.forEach((item, localIndex) => {
                    if (!firstLocationSet) {
                        let latLng;
                        if (item.placeVisit) {
                            latLng = { lat: item.placeVisit.location.latitudeE7 / 1e7, lng: item.placeVisit.location.longitudeE7 / 1e7 };
                        } else if (item.activitySegment && item.activitySegment.startLocation) {
                            latLng = { lat: item.activitySegment.startLocation.latitudeE7 / 1e7, lng: item.activitySegment.startLocation.longitudeE7 / 1e7 };
                        }
                        if (latLng && !isNaN(latLng.lat) && !isNaN(latLng.lng)) {
                            map.setCenter(latLng);
                            map.setZoom(15);
                            firstLocationSet = true;
                        }
                    }
                });
                relevantData.forEach((item) => {
                    const timelineItem = createTimelineItem(item, globalIndex, selectedDateStr);
                    document.getElementById('timeline').appendChild(timelineItem);
                    if (item.placeVisit) {
                        renderPlaceVisit(item.placeVisit, globalIndex);
                    } else if (item.activitySegment) {
                        renderActivitySegment(item.activitySegment, globalIndex);
                    }
                    globalIndex++;
                });
            }
        }

        async function loadTimelineDataInDateRange(startDate, endDate) {
             // Ensure map is visible when loading data range
            if (summaryViewVisible) {
                document.getElementById('summaryView').style.display = 'none';
                document.getElementById('map').classList.remove('hidden');
                summaryViewVisible = false;
            }
            if (!uiEnabled) return;
            clearMap();
            clearTimeline();
            globalIndex = 0;
            placeDetailsCache = {};
            const startMoment = moment.utc(startDate).startOf('day');
            const endMoment = moment.utc(endDate).endOf('day'); // Use end of day for comparison
            document.getElementById('loading-overlay').style.display = "flex";
            const promises = [];
            let currentDate = startMoment.clone();
            while (currentDate.isSameOrBefore(endMoment, 'day')) {
                promises.push(loadTimelineDataForDate(currentDate.toDate())); // Pass Date object
                currentDate.add(1, 'days');
            }
            try {
                await Promise.all(promises);
            } catch (error) {
                console.error("Error loading data for date range:", error);
            } finally {
                document.getElementById('loading-overlay').style.display = "none";
                document.getElementById('howToMessage').style.display = "none";
                document.getElementById('map').classList.remove('hidden');
                fitMapToData(); // Optionally fit map after loading range
            }
        }

        function clearMap() {
            markers.forEach(marker => marker.map = null);
            markers = [];
            polylines.forEach(polyline => polyline.setMap(null));
            polylines = [];
            infoWindows.forEach(infoWindow => infoWindow.close());
            infoWindows = [];
            deselectPolyline(); // Also deselect any highlighted polyline
        }

        function clearTimeline() {
            document.getElementById('timeline').innerHTML = '';
        }

        function renderPlaceVisit(placeVisit, index) {
            let locationName = placeVisit.location.name ||
                               (placeVisit.location.semanticType === "TYPE_HOME" ? "Home" : null);
            const placeId = placeVisit.location.placeId;
            const lat = placeVisit.location.latitudeE7 / 1e7;
            const lng = placeVisit.location.longitudeE7 / 1e7;
            const fallbackName = locationName || `Location (${lat.toFixed(4)}, ${lng.toFixed(4)})`;
            // Attempt to fetch Place Details if placeId exists
            if (placeId) {
                if (placeDetailsCache[placeId]) {
                    renderPlaceDetails(placeDetailsCache[placeId], placeVisit, index);
                } else {
                    fetchPlaceDetails(placeId, fallbackName, placeVisit, index);
                }
            } else {
                renderBasicMarker(lat, lng, fallbackName, placeVisit, index);
                updateSidebarItem(index, fallbackName, null);
            }
        }

        function renderBasicMarker(lat, lng, name, placeVisit, index) {
            const position = { lat, lng };
            const marker = new google.maps.marker.AdvancedMarkerElement({
                position: position,
                map: map,
                title: name,
            });
            markers.push(marker);
            const infoWindowContent = `
                <h3>${name}</h3>
                <p>Lat: ${lat.toFixed(6)}, Lng: ${lng.toFixed(6)}</p>
                <p>${moment(placeVisit.duration.startTimestamp).format("YYYY-MM-DD hh:mm A")} - ${moment(placeVisit.duration.endTimestamp).format("YYYY-MM-DD hh:mm A")}</p>
                <p><a href="https://www.google.com/maps?q=${lat},${lng}" target="_blank">View on Google Maps</a></p> `;
            const infoWindow = new google.maps.InfoWindow({ content: infoWindowContent });
            infoWindows.push(infoWindow);
            const sidebarItem = document.querySelector(`.timeline-item[data-index="${index}"]`);
            addMarkerClickListener(marker, infoWindow, index);
            if (sidebarItem) {
                addSidebarItemClickListener(sidebarItem, index, marker, infoWindow);
            }
        }

        function fetchPlaceDetails(placeId, fallbackName, placeVisit, index) {
            const placeService = new google.maps.places.PlacesService(map);
            const request = {
                placeId: placeId,
                fields: ["name", "formatted_address", "geometry", "icon", "icon_background_color", "photos", "url"]
            };
            placeService.getDetails(request, (place, status) => {
                if (status === google.maps.places.PlacesServiceStatus.OK && place) {
                    // Cache the result
                    placeDetailsCache[placeId] = place;
                    // Render details
                    renderPlaceDetails(place, placeVisit, index);
                } else {
                    console.warn("Error fetching place details:", status, "for placeId:", placeId, "Falling back to basic marker.");
                    // Fallback to basic marker if details fetch fails
                    const lat = placeVisit.location.latitudeE7 / 1e7;
                    const lng = placeVisit.location.longitudeE7 / 1e7;
                    renderBasicMarker(lat, lng, fallbackName, placeVisit, index);
                    updateSidebarItem(index, fallbackName, null);
                }
            });
        }

        function updateSidebarItem(index, locationName, iconUrl) {
            const sidebarItem = document.querySelector(`.timeline-item[data-index="${index}"]`);
            if (sidebarItem) {
                const nametag = sidebarItem.querySelector('.nametag');
                if (nametag) nametag.textContent = locationName;
                const iconContainer = sidebarItem.querySelector('.timeline-icon-container');
                if (iconContainer) {
                    iconContainer.innerHTML = iconUrl ? `<img src="${iconUrl}" alt="Icon" style="width: 20px; height: 20px; vertical-align: middle;">` : 'üìç';
                }
            }
        }

        function renderPlaceDetails(place, placeVisit, index) {
            let locationName = place.name || placeVisit.location.name || (placeVisit.location.semanticType === "TYPE_HOME" ? "Home" : 'Unknown Location');
            const position = place.geometry?.location || { lat: placeVisit.location.latitudeE7 / 1e7, lng: placeVisit.location.longitudeE7 / 1e7 };
            let markerContent;
            if (place.icon && place.icon_background_color) {
                try {
                    // NOTE: PinElement border thickness cannot be directly controlled via API.
                    const pinElement = new google.maps.marker.PinElement({
                        background: place.icon_background_color,
                        glyph: new URL(place.icon),
                        glyphColor: '#FFFFFF',
                        borderColor: '#000000',
                    });
                    markerContent = pinElement.element;
                } catch (e) {
                    console.warn("Could not create PinElement, using default marker:", e);
                    markerContent = null; // Fallback to default marker rendering below
                }
            }
            const marker = new google.maps.marker.AdvancedMarkerElement({
                position: position,
                map: map,
                content: markerContent,
                title: locationName,
            });
            markers.push(marker);
            const photoUrl = place.photos?.[0]?.getUrl({ maxWidth: 200, maxHeight: 150 });
            const mapsLink = place.url ? `<a href="${place.url}" target="_blank">View on Google Maps</a>` : `<a href="https://www.google.com/maps?q=${position.lat()},${position.lng()}" target="_blank">View on Google Maps</a>`; // Fallback link
            const infoWindowContent = `
                <div style="max-width: 250px;">
                    <h3 style="margin: 5px 0;">${locationName}</h3>
                    <p style="margin: 3px 0; font-size: 0.9em;">${place.formatted_address || ""}</p>
                    ${photoUrl ? `<img src="${photoUrl}" alt="${locationName}" style="max-width: 200px; max-height: 200px; margin-top: 5px; border-radius: 3px;"><br>` : ""}
                    <p style="margin: 5px 0; font-size: 0.85em;">${moment(placeVisit.duration.startTimestamp).format("MMM DD, YYYY hh:mm A")} - ${moment(placeVisit.duration.endTimestamp).format("hh:mm A")}</p>
                    <p style="margin-top: 5px; font-size: 0.85em;">${mapsLink}</p>
                </div>
            `;
            const infoWindow = new google.maps.InfoWindow({ content: infoWindowContent });
            infoWindows.push(infoWindow);
            updateSidebarItem(index, locationName, place.icon);
            const sidebarItem = document.querySelector(`.timeline-item[data-index="${index}"]`);
            addMarkerClickListener(marker, infoWindow, index);
            if (sidebarItem) {
                addSidebarItemClickListener(sidebarItem, index, marker, infoWindow);
            }
        }

        function renderActivitySegment(activitySegment, index) {
            let path = [];
            const startLat = activitySegment.startLocation?.latitudeE7 / 1e7;
            const startLng = activitySegment.startLocation?.longitudeE7 / 1e7;
            const endLat = activitySegment.endLocation?.latitudeE7 / 1e7;
            const endLng = activitySegment.endLocation?.longitudeE7 / 1e7;
            if (!isNaN(startLat) && !isNaN(startLng)) path.push({ lat: startLat, lng: startLng });
            let intermediatePoints = activitySegment.simplifiedRawPath?.points || activitySegment.timelinePath?.points || activitySegment.waypointPath?.waypoints || [];
            intermediatePoints.forEach(point => {
                const pLat = point.latE7 / 1e7;
                const pLng = point.lngE7 / 1e7;
                if (!isNaN(pLat) && !isNaN(pLng)) path.push({ lat: pLat, lng: pLng });
            });
            if (!isNaN(endLat) && !isNaN(endLng)) {
                 const lastPoint = path[path.length - 1];
                 if (!lastPoint || lastPoint.lat !== endLat || lastPoint.lng !== endLng) {
                    path.push({ lat: endLat, lng: endLng });
                 }
            }
            if (path.length < 2) return;
            const polyline = new google.maps.Polyline({
                path: path,
                geodesic: true,
                strokeColor: getActivityColor(activitySegment.activityType),
                strokeOpacity: 0.8, // Slightly less opaque
                strokeWeight: 5,
                map: map,
                clickable: true,
                zIndex: 0 // Default zIndex
            });
            polyline.set('originalColor', getActivityColor(activitySegment.activityType)); // Store original color
            polylines.push(polyline);
            const sidebarItem = document.querySelector(`.timeline-item[data-index="${index}"]`);
            addPolylineClickListener(polyline, sidebarItem, path);
            if (sidebarItem) {
                addSidebarItemClickListener(sidebarItem, index, null, null, polyline, path);
            }
        }

        function addMarkerClickListener(marker, infoWindow, index) {
            marker.addListener('click', () => {
                if (!marker.map) return;
                infoWindows.forEach(iw => iw.close());
                infoWindow.open({ map: map, anchor: marker });
                highlightSidebarItem(index);
                deselectPolyline();
            });
        }

        function addPolylineClickListener(polyline, timelineItem, path) {
            polyline.addListener('click', (e) => { // e is PolyMouseEvent
                if (!polyline.getMap()) return;
                const index = timelineItem ? timelineItem.dataset.index : null;
                if (index !== null) highlightSidebarItem(index);
                selectPolyline(polyline); // Select clicked polyline
                infoWindows.forEach(iw => iw.close()); // Close info windows
                if (timelineItem) {
                    timelineItem.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                }
                // Optional: Fit bounds on click? Sometimes selecting is enough.
                // const bounds = new google.maps.LatLngBounds();
                // path.forEach(point => bounds.extend(point));
                // map.fitBounds(bounds);
            });
        }

        function selectPolyline(polyline) {
            if (selectedPolyline === polyline) return; // Already selected
            deselectPolyline(); // Deselect previous first
            polyline.setOptions({
                strokeWeight: 7, // Make it slightly thicker
                icons: [{
                    icon: {
                        path: google.maps.SymbolPath.FORWARD_CLOSED_ARROW,
                        scale: 4,
                        strokeColor: '#FFF', // White outline for visibility
                        strokeWeight: 1
                    },
                    offset: '50%',
                    repeat: '90px'
                }],
                zIndex: 1 // Bring to front
            });
            selectedPolyline = polyline;
        }

        function deselectPolyline() {
            if (selectedPolyline) {
                selectedPolyline.setOptions({
                    icons: [],
                    strokeWeight: 5,
                    strokeOpacity: 0.8,
                    zIndex: 0
                });
                selectedPolyline = null;
            }
        }

        function addSidebarItemClickListener(sidebarItem, index, marker, infoWindow, polyline, path) {
            if (!sidebarItem) return;
            sidebarItem.addEventListener('click', () => {
                highlightSidebarItem(index);
                if (marker && infoWindow && marker.map) {
                    // Center on marker and open its info window
                    map.setCenter(marker.position);
                    map.setZoom(Math.max(map.getZoom(), 15)); // Zoom in if necessary
                    infoWindows.forEach(iw => iw.close());
                    infoWindow.open({ map: map, anchor: marker });
                    deselectPolyline(); // Deselect any selected polyline
                } else if (polyline && path?.length > 0 && polyline.getMap()) {
                    // Fit map to polyline bounds and select it
                    const bounds = new google.maps.LatLngBounds();
                    path.forEach(point => bounds.extend(point));
                    map.fitBounds(bounds, 30); // Add some padding
                    selectPolyline(polyline);
                    infoWindows.forEach(iw => iw.close());
                }
            });
        }

        function highlightSidebarItem(index) {
            const timelineItems = document.querySelectorAll('.timeline-item');
            document.getElementById('layerOptions').style.display = 'none';
            timelineItems.forEach((item) => {
                const timeElement = item.querySelector('.timeline-item-time');
                const startTimestamp = item.dataset.startTimestamp;
                const endTimestamp = item.dataset.endTimestamp;
                if (item.dataset.index === String(index)) {
                    item.classList.add('highlighted');
                    if (!isElementInViewport(item)) {
                        item.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                    }
                    if (timeElement && startTimestamp && endTimestamp) {
                         timeElement.textContent = `${moment(startTimestamp).format('hh:mm A')} - ${moment(endTimestamp).format('hh:mm A')}`;
                    }
                } else {
                    item.classList.remove('highlighted');
                    if (timeElement && startTimestamp && endTimestamp) {
                         timeElement.textContent = `${moment(startTimestamp).format('hh:mm A')} - ${moment(endTimestamp).format('hh:mm A')}`;
                    }
                }
            });
        }

        function isElementInViewport (el) {
            if (!el) return false;
            const rect = el.getBoundingClientRect();
            const timeline = document.getElementById('timeline'); // Check against timeline scroll container
            const timelineRect = timeline.getBoundingClientRect();
            return (
                rect.top >= timelineRect.top &&
                rect.bottom <= timelineRect.bottom
            );
        }

        function getActivityColor(activityType) {
            const group = getGroupedActivityType(activityType);
            switch (group) {
                case 'DRIVING': case 'TAXI': return '#4285F4'; // Google Blue
                case 'MOTORCYCLING': return '#1E90FF';
                case 'CYCLING': return '#0F9D58'; // Google Green
                case 'WALKING': return '#DB4437'; // Google Red
                case 'RUNNING': return '#DB4437';
                case 'HIKING': return '#0F9D58'; // Google Green (for nature)
                case 'BUS': return '#9C27B0'; // Purple
                case 'SUBWAY': case 'TRAIN': case 'TRAM': case 'FERRY': return '#673AB7'; // Deep Purple
                case 'STATIONARY': return '#757575'; // Grey
                case 'FLYING': return '#03A9F4'; // Light Blue
                case 'CABLECAR': case 'FUNICULAR': case 'GONDOLA_LIFT': case 'WHEELCHAIR': return '#607D8B'; // Blue Grey
                case 'BOATING': case 'KAYAKING': case 'ROWING': case 'SAILING': case 'SURFING': case 'SWIMMING': return '#00BCD4'; // Cyan
                case 'CATCHING_POKEMON': return '#FFEB3B'; // Yellow
                case 'HORSEBACK_RIDING': return '#795548'; // Brown
                case 'KITESURFING': case 'PARAGLIDING': return '#87CEEB'; // Sky Blue
                case 'SKATEBOARDING': case 'SKATING': return '#FF9800'; // Orange
                case 'SKIING': case 'SLEDDING': case 'SNOWBOARDING': case 'SNOWSHOEING': case 'SNOWMOBILE': return '#B0E0E6'; // Powder Blue
                case 'UNKNOWN': default: return '#9E9E9E'; // Darker Grey
            }
        }

        function formatActivityType(activityType) {
            switch (activityType) {
                case 'IN_VEHICLE': return 'Driving';
                case 'IN_PASSENGER_VEHICLE': return 'In a Vehicle';
                case 'IN_TAXI': return 'In a Taxi';
                case 'MOTORCYCLING': return 'Motorcycling';
                case 'ON_BICYCLE': case 'CYCLING': return 'Biking';
                case 'ON_FOOT': case 'WALKING': return 'Walking';
                case 'WALKING_NORDIC': return 'Nordic Walking';
                case 'HIKING': return 'Hiking';
                case 'RUNNING': return 'Running';
                case 'IN_BUS': return 'On a Bus';
                case 'IN_SUBWAY': return 'On the Subway';
                case 'IN_TRAIN': return 'On a Train';
                case 'IN_TRAM': return 'On a Tram';
                case 'IN_FERRY': return 'On a Ferry';
                case 'STILL': return 'Stationary';
                case 'FLYING': return 'On a Plane';
                case 'IN_CABLECAR': return 'On a Cable Car';
                case 'IN_FUNICULAR': return 'On a Funicular';
                case 'IN_GONDOLA_LIFT': return 'On a Gondola';
                case 'IN_WHEELCHAIR': return 'In a Wheelchair';
                case 'SNOWMOBILE': return 'On a Snowmobile';
                case 'BOATING': return 'Boating';
                case 'CATCHING_POKEMON': return 'Catching Pok√©mon';
                case 'HORSEBACK_RIDING': return 'Horseback Riding';
                case 'KAYAKING': return 'Kayaking';
                case 'KITESURFING': return 'Kitesurfing';
                case 'PARAGLIDING': return 'Paragliding';
                case 'ROWING': return 'Rowing';
                case 'SAILING': return 'Sailing';
                case 'SKATEBOARDING': return 'Skateboarding';
                case 'SKATING': return 'Skating';
                case 'SKIING': return 'Skiing';
                case 'SLEDDING': return 'Sledding';
                case 'SNOWBOARDING': return 'Snowboarding';
                case 'SNOWSHOEING': return 'Snowshoeing';
                case 'SURFING': return 'Surfing';
                case 'SWIMMING': return 'Swimming';
                case 'UNKNOWN': case 'UNKNOWN_ACTIVITY_TYPE': return 'Unknown Activity';
                case 'TILTING': return 'Device Tilt';
                default: return activityType ? activityType.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase()) : 'Unknown Activity';
            }
        }

        function initDatePicker() {
            const startDatePicker = document.getElementById('startDatePicker');
            const endDatePicker = document.getElementById('endDatePicker');
            const prevDayBtn = document.getElementById('prevDayBtn');
            const nextDayBtn = document.getElementById('nextDayBtn');
            const goBtn = document.getElementById('goBtn');
            const today = moment().format('YYYY-MM-DD');
            startDatePicker.value = today;
            endDatePicker.value = today;
            const navigateDays = (days) => {
                 if (!uiEnabled) return;
                const startMoment = moment.utc(startDatePicker.value).add(days, 'days');
                const endMoment = moment.utc(endDatePicker.value).add(days, 'days');
                 if (startMoment.isAfter(endMoment)) {
                    endMoment.add(days, 'days');
                }
                startDatePicker.value = startMoment.format('YYYY-MM-DD');
                endDatePicker.value = endMoment.format('YYYY-MM-DD');
                loadTimelineDataInDateRange(startMoment.toDate(), endMoment.toDate());
            };
            prevDayBtn.addEventListener('click', () => navigateDays(-1));
            nextDayBtn.addEventListener('click', () => navigateDays(1));
            goBtn.addEventListener('click', () => {
                if (!uiEnabled) return;
                const startDate = moment.utc(startDatePicker.value).toDate();
                const endDate = moment.utc(endDatePicker.value).toDate();
                if (startDate > endDate) {
					console.log(`${startDate} not before ${endDate}`);
					clearMap();
					clearTimeline();
					globalIndex = 0;
					placeDetailsCache = {};
					document.getElementById('summary-years').innerHTML = '';
					document.getElementById('summary-months').innerHTML = '';
                    return;
                }
                loadTimelineDataInDateRange(startDate, endDate);
            });
            startDatePicker.addEventListener('change', () => { if(uiEnabled) goBtn.click(); });
            endDatePicker.addEventListener('change', () => { if(uiEnabled) goBtn.click(); });
        }

        function populateActivityFilters() {
            const activityFilters = document.getElementById('activityFilters');
            activityFilters.innerHTML = '';
            const uniqueGroupedTypes = new Set();
            Object.values(timelineData).forEach(monthData => {
                monthData.timelineObjects?.forEach(item => {
                    if (item.activitySegment) {
                        uniqueGroupedTypes.add(getGroupedActivityType(item.activitySegment.activityType));
                    }
                });
            });
            const sortedGroupedTypes = Array.from(uniqueGroupedTypes).sort((a, b) => {
                if (a === 'UNKNOWN') return 1;
                if (b === 'UNKNOWN') return -1;
                return a.localeCompare(b);
             });
            sortedGroupedTypes.forEach(groupType => {
                if (groupType === 'STATIONARY') return;
                const label = document.createElement('label');
                label.className = 'layer-option';
                const formattedName = groupType.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                label.innerHTML = `
                    <input type="checkbox" id="filter-${groupType}" class="layer-checkbox activity-filter-checkbox" checked data-group-type="${groupType}">
                    <span style="color:${getActivityColor(groupType)}; margin-right: 4px;">${getActivityIcon(groupType)}</span>
                    ${formattedName}
                `;
                activityFilters.appendChild(label);
                const checkbox = label.querySelector('input');
                checkbox.addEventListener('change', () => {
                    if (!uiEnabled) return;
                    const allActivityFilters = activityFilters.querySelectorAll('.activity-filter-checkbox');
                    document.getElementById('showActivities').checked = [...allActivityFilters].some(cb => cb.checked);
                    const startDate = new Date(document.getElementById('startDatePicker').value);
                    const endDate = new Date(document.getElementById('endDatePicker').value);
                    loadTimelineDataInDateRange(startDate, endDate);
                });
            });
        }

        function initLayerButton() {
            const layerBtn = document.getElementById('layerBtn');
            const layerOptions = document.getElementById('layerOptions');
            const closeLayerBtn = document.getElementById('closeLayerBtn');
            const showActivitiesCheckbox = document.getElementById('showActivities');
            const showVisitsCheckbox = document.getElementById('showVisits');
            const activityFiltersDiv = document.getElementById('activityFilters');
            layerBtn.addEventListener('click', () => {
                if (!uiEnabled) return;
                layerOptions.style.display = layerOptions.style.display === 'none' ? 'block' : 'none';
            });
            closeLayerBtn.addEventListener('click', () => layerOptions.style.display = 'none');
            const reloadData = () => {
                if (!uiEnabled) return;
                const startDate = new Date(document.getElementById('startDatePicker').value);
                const endDate = new Date(document.getElementById('endDatePicker').value);
                loadTimelineDataInDateRange(startDate, endDate);
            };
            showVisitsCheckbox.addEventListener('change', reloadData);
            showActivitiesCheckbox.addEventListener('change', function() {
                if (!uiEnabled) return;
                const isChecked = this.checked;
                activityFiltersDiv.querySelectorAll('.activity-filter-checkbox').forEach(checkbox => checkbox.checked = isChecked);
                reloadData();
            });
        }

        function initFitMapButton() {
            document.getElementById('fitMapBtn').addEventListener('click', fitMapToData);
        }

        function fitMapToData() {
            if (!uiEnabled || (markers.length === 0 && polylines.length === 0)) return;
            const bounds = new google.maps.LatLngBounds();
            let itemCount = 0;
            markers.forEach(marker => {
                if (marker.map) {
                    bounds.extend(marker.position);
                    itemCount++;
                }
            });
            polylines.forEach(polyline => {
                if (polyline.getMap()) {
                    polyline.getPath().forEach(point => bounds.extend(point));
                    itemCount++;
                }
            });
            if (itemCount > 0) {
                if (itemCount === 1 && markers.length === 1) {
                     // Single marker: center and set zoom
                     map.setCenter(bounds.getCenter());
                     map.setZoom(15);
                 } else if (bounds.getNorthEast().equals(bounds.getSouthWest())) {
                     // Multiple items at the exact same point
                     map.setCenter(bounds.getCenter());

                     map.setZoom(16); // Zoom slightly closer for identical points
                 } else {
                     map.fitBounds(bounds, 50); // Fit multiple items with padding
                }
            }
        }

        // --- Summary View Calculation ---
        function calculateSummaries() {
            console.log("Calculating summaries...");
            const yearly = {};
            const monthly = {};
            const kmConversion = 0.001;
            for (const key in timelineData) {
                if (!timelineData[key].timelineObjects) continue;
                const parts = key.split('_');
                if (parts.length < 2) continue;
                const yearStr = parts[0];
                const monthStr = parts[1];
                const year = parseInt(yearStr, 10);
                let monthIndex = moment().month(monthStr).format("M") - 1;
                if (monthIndex < 0) {
                    const monthNum = parseInt(monthStr, 10);
                    if (!isNaN(monthNum) && monthNum >= 1 && monthNum <= 12) {
                        monthIndex = monthNum - 1;
                    }
                }
                if (isNaN(year) || monthIndex < 0 || monthIndex > 11) continue;
                if (!yearly[year]) yearly[year] = { visits: 0, distanceKm: 0 };
                if (!monthly[year]) monthly[year] = {};
                if (!monthly[year][monthIndex]) {
                    monthly[year][monthIndex] = { visits: 0, distanceKm: 0, distanceByActivity: {} };
                }
                timelineData[key].timelineObjects.forEach(item => {
                    if (item.placeVisit) {
                        yearly[year].visits++;
                        monthly[year][monthIndex].visits++;
                    } else if (item.activitySegment) {
                        const segment = item.activitySegment;
                        const distanceMeters = segment.distance || segment.simplifiedRawPath?.distanceMeters || segment.waypointPath?.distanceMeters || 0;
                        const distanceKm = distanceMeters * kmConversion;
                        if (distanceKm > 0) {
                            yearly[year].distanceKm += distanceKm;
                            monthly[year][monthIndex].distanceKm += distanceKm;
                            const groupedType = getGroupedActivityType(segment.activityType);
                            monthly[year][monthIndex].distanceByActivity[groupedType] = (monthly[year][monthIndex].distanceByActivity[groupedType] || 0) + distanceKm;
                        }
                    }
                });
            }
            allYearlySummaries = yearly;
            allMonthlySummaries = monthly;
            console.log("Summaries calculated:", allYearlySummaries, allMonthlySummaries);
        }

        // --- Summary View Display Functions ---
        function displayYearSummary() {
            const container = document.getElementById('summary-years');
            container.innerHTML = ''; // Clear previous
            if (!allYearlySummaries || Object.keys(allYearlySummaries).length === 0) {
                 container.innerHTML = '<p>No summary data available.</p>';
                 document.getElementById('summary-months').innerHTML = '<p>Select a year above.</p>';
                 document.getElementById('summary-selected-year').textContent = '';
                 return;
            }
            const sortedYears = Object.keys(allYearlySummaries).map(Number).sort((a, b) => b - a);
            sortedYears.forEach(year => {
                const data = allYearlySummaries[year];
                const item = document.createElement('div');
                item.className = 'summary-year-item';
                item.dataset.year = year;
                item.innerHTML = `
                    <strong>${year}</strong>
                    <div class="summary-details">Visits: <span>${data.visits.toLocaleString()}</span></div>
                    <div class="summary-details">Distance: <span>${data.distanceKm.toLocaleString(undefined, { minimumFractionDigits: 1, maximumFractionDigits: 1 })} km</span></div>
                `;
                item.addEventListener('click', () => {
                    displayMonthSummary(year);
                    container.querySelectorAll('.summary-year-item.selected').forEach(el => el.classList.remove('selected'));
                    item.classList.add('selected');
                });
                container.appendChild(item);
            });
            if (sortedYears.length > 0) {
                const initialYear = selectedSummaryYear && allYearlySummaries[selectedSummaryYear] ? selectedSummaryYear : sortedYears[0];
                displayMonthSummary(initialYear);
                container.querySelector(`.summary-year-item[data-year="${initialYear}"]`)?.classList.add('selected');
            } else {
                 document.getElementById('summary-months').innerHTML = '<p>Select a year above.</p>';
                 document.getElementById('summary-selected-year').textContent = '';
            }
        }

        function displayMonthSummary(year) {
            selectedSummaryYear = year;
            document.getElementById('summary-selected-year').textContent = year;
            const container = document.getElementById('summary-months');
            container.innerHTML = '';
            if (!allMonthlySummaries || !allMonthlySummaries[year] || Object.keys(allMonthlySummaries[year]).length === 0) {
                container.innerHTML = `<p>No monthly data available for ${year}.</p>`;
                return;
            }
            const sortedMonths = Object.keys(allMonthlySummaries[year]).map(Number).sort((a, b) => a - b);
            sortedMonths.forEach(monthIndex => {
                const data = allMonthlySummaries[year][monthIndex];
                const monthName = moment().month(monthIndex).format("MMMM");
                const item = document.createElement('div');
                item.className = 'summary-month-item';
                item.dataset.year = year;
                item.dataset.month = monthIndex;
                let activityHtml = '<ul>';
                const sortedActivities = Object.keys(data.distanceByActivity).sort((a,b) => data.distanceByActivity[b] - data.distanceByActivity[a]);
                if (sortedActivities.length > 0) {
                     sortedActivities.forEach(activityGroup => {
                        const formattedName = activityGroup.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                        const icon = getActivityIcon(activityGroup);
                        activityHtml += `<li>${icon} ${formattedName}: <span>${data.distanceByActivity[activityGroup].toLocaleString(undefined, { minimumFractionDigits: 1, maximumFractionDigits: 1 })} km</span></li>`;
                    });
                } else {
                    activityHtml += '<li>No distance recorded</li>';
                }
                activityHtml += '</ul>';
                item.innerHTML = `
                    <strong>${monthName}</strong>
                    <div class="summary-details">Visits: <span>${data.visits.toLocaleString()}</span></div>
                    <div class="summary-details">Total Dist: <span>${data.distanceKm.toLocaleString(undefined, { minimumFractionDigits: 1, maximumFractionDigits: 1 })} km</span></div>
                    ${activityHtml}
                `;
                 item.addEventListener('click', () => navigateToMonth(year, monthIndex));
                container.appendChild(item);
            });
        }

        // --- Navigation from Summary to Map ---
        function navigateToMonth(year, monthIndex) {
            console.log(`Navigating to: ${year}-${String(monthIndex + 1).padStart(2, '0')}`);
            const startOfMonth = moment.utc({ year: year, month: monthIndex }).startOf('month').format('YYYY-MM-DD');
            const endOfMonth = moment.utc({ year: year, month: monthIndex }).endOf('month').format('YYYY-MM-DD');
            document.getElementById('startDatePicker').value = startOfMonth;
            document.getElementById('endDatePicker').value = endOfMonth;
            document.getElementById('summaryView').style.display = 'none';
            document.getElementById('map').classList.remove('hidden');
            summaryViewVisible = false;
            document.getElementById('goBtn').click(); // Trigger data load
        }

        // --- Initialize Summary View ---
        function initSummaryView() {
             const summaryBtn = document.getElementById('summaryBtn');
             const closeSummaryBtn = document.getElementById('closeSummaryBtn');
             const summaryView = document.getElementById('summaryView');
             const mapElement = document.getElementById('map');
             const mapBtn = document.getElementById('mapBtn');
             summaryBtn.addEventListener('click', () => {
                if (!uiEnabled) return;
                if (!summaryViewVisible) {
                    if (!allYearlySummaries) {
                        calculateSummaries();
                    }
                    displayYearSummary();
                    summaryView.style.display = 'block';
                    mapElement.classList.add('hidden');
                    summaryViewVisible = true;
                } else {
                    summaryView.style.display = 'none';
                    mapElement.classList.remove('hidden');
                    summaryViewVisible = false;
                }
                updateViewToggleButtons();
             });
             closeSummaryBtn.addEventListener('click', () => {
                summaryView.style.display = 'none';
                mapElement.classList.remove('hidden');
                summaryViewVisible = false;
                updateViewToggleButtons();
             });
             mapBtn.addEventListener('click', () => {
                summaryView.style.display = 'none';
                mapElement.classList.remove('hidden');
                summaryViewVisible = false;
                updateViewToggleButtons();
             });
        }
        function updateViewToggleButtons() {
            const summaryBtn = document.getElementById('summaryBtn');
            const mapBtn = document.getElementById('mapBtn');
            if (summaryViewVisible) {
                summaryBtn.classList.add('active');
                mapBtn.classList.remove('active');
            } else {
                summaryBtn.classList.remove('active');
                mapBtn.classList.add('active');
            }
        }

        // --- UI Enable/Disable ---
        function setUIEnabled(enabled) {
            uiEnabled = enabled;
            const elementsToToggle = [
                document.getElementById('startDatePicker'),
                document.getElementById('endDatePicker'),
                document.getElementById('prevDayBtn'),
                document.getElementById('nextDayBtn'),
                document.getElementById('goBtn'),
                document.getElementById('layerBtn'),
                document.getElementById('fitMapBtn'),
                document.getElementById('summaryBtn'),
                document.getElementById('mapBtn')
            ];
            elementsToToggle.forEach(el => { if(el) el.disabled = !enabled; });
            const layerCheckboxes = document.querySelectorAll('#layerOptions input[type="checkbox"]');
            layerCheckboxes.forEach(cb => cb.disabled = !enabled);
            if (!enabled) {
                document.getElementById('data-source-indicator').textContent = 'No data loaded. Use "Choose Folder".';
                clearMap();
                clearTimeline();
                document.getElementById('layerOptions').style.display = 'none';
                document.getElementById('summaryView').style.display = 'none'; // Hide summary view
                document.getElementById('map').classList.remove('hidden'); // Ensure map is visible
                summaryViewVisible = false;
                allYearlySummaries = null;
                allMonthlySummaries = null;
                selectedSummaryYear = null;
            }
        }

        async function readFilesFromDirectory(dirHandle, isRecursive=false) {
            let timelineJsonFile = null;
            let dataSourceText = 'Unknown';
            if (!isRecursive) {
                console.log("Initial call to readFilesFromDirectory, resetting globals...");
                globalIndex = 0;
                timelineData = {}; // Reset main data object
                activityTypes = new Set(); // Reset activity types
                placeDetailsCache = {}; // Reset cache
                allYearlySummaries = null;
                allMonthlySummaries = null;
                selectedSummaryYear = null;
                // Show loading overlay only on initial call
                document.getElementById('loading-overlay').style.display = "flex";
                setUIEnabled(false); // Disable UI only on initial call
            }
            try {
                if (!isRecursive) {
                    for await (const entry of dirHandle.values()) {
                        if (entry.kind === 'file' && entry.name.toLowerCase() === 'timeline.json') {
                            timelineJsonFile = entry;
                            break;
                        }
                    }
                }
                if (timelineJsonFile) {
                    // If Timeline.json is found, try parsing it (Semantic History format)
                    console.log("Found Timeline.json, attempting to parse...");
                    const file = await timelineJsonFile.getFile();
                    const content = await file.text();
                    const data = JSON.parse(content);
                    // Create temp structure to hold processed objects grouped by key
                    const processedData = {};

                    if (data.timelineObjects) { // Check for standard Takeout Timeline.json format first
                        dataSourceText = 'Local Timeline.json (Standard Format)';
                        data.timelineObjects.forEach(item => {
                            const timestamp = item.placeVisit?.duration?.startTimestamp || item.activitySegment?.duration?.startTimestamp;
                            if (!timestamp) return;
                            const date = new Date(timestamp);
                            const key = `${date.getFullYear()}_${moment(date).format('MMMM').toUpperCase()}`;
                            if (!processedData[key]) processedData[key] = { timelineObjects: [] };
                            processedData[key].timelineObjects.push(item);
                            if (item.activitySegment?.activityType) activityTypes.add(item.activitySegment.activityType);
                        });
                        timelineData = processedData;
                    } else if (data.semanticSegments) { // check for Semantic History format
                         dataSourceText = 'Local Timeline.json (Semantic Format)';

                        // Populate the timelinePath points from every timelinePath object first
                        const allPathPoints = []; // Array to hold all path points with time
                        data.semanticSegments.forEach(segment => {
                            if (segment.timelinePath) {
                                segment.timelinePath.forEach(point => {
                                    try {
                                        const latLngMatch = point.point?.match(/(-?\d+\.\d+)\s*¬∞,\s*(-?\d+\.\d+)/);
                                        const time = point.time;
                                        if (latLngMatch && time) {
                                            const lat = parseFloat(latLngMatch[1]);
                                            const lng = parseFloat(latLngMatch[2]);
                                            if (!isNaN(lat) && !isNaN(lng)) {
                                                allPathPoints.push({
                                                    latE7: Math.round(lat * 1e7),
                                                    lngE7: Math.round(lng * 1e7),
                                                    time: time
                                                });
                                            }
                                        }
                                    } catch (e) {
                                        console.warn("Error parsing timelinePath point:", point, e);
                                    }
                                });
                            }
                        });
                        // Sort path points by time
                        allPathPoints.sort((a, b) => moment(a.time).valueOf() - moment(b.time).valueOf());
                        let pathPointPointer = 0; // Pointer for efficient matching
                        const processedTimelineObjects = data.semanticSegments.map(segment => {
                            const startTime = segment.startTime;
                            const endTime = segment.endTime;
                            if (!startTime || !endTime) return null;
                            if (segment.visit?.topCandidate?.placeLocation?.latLng && segment.visit?.topCandidate?.placeId) {
                                const latLngMatch = segment.visit.topCandidate.placeLocation.latLng.match(/(-?\d+\.\d+)\s*¬∞,\s*(-?\d+\.\d+)/);
                                if (!latLngMatch) return null;
                                const lat = parseFloat(latLngMatch[1]);
                                const lng = parseFloat(latLngMatch[2]);
                                if (isNaN(lat) || isNaN(lng)) return null;
                                return {
                                    placeVisit: {
                                        location: {
                                            latitudeE7: Math.round(lat * 1e7),
                                            longitudeE7: Math.round(lng * 1e7),
                                            placeId: segment.visit.topCandidate.placeId,
                                            semanticType: segment.visit.topCandidate.semanticType || null,
                                            name: segment.visit.topCandidate.name || 'Unknown Location'
                                        },
                                        duration: { startTimestamp: startTime, endTimestamp: endTime },
                                        editConfirmationStatus: segment.visit.editConfirmationStatus
                                    }
                                };
                            } else if (segment.activity?.topCandidate?.type && segment.activity?.start?.latLng && segment.activity?.end?.latLng) {
                                const startLatLngMatch = segment.activity.start.latLng.match(/(-?\d+\.\d+)\s*¬∞,\s*(-?\d+\.\d+)/);
                                const endLatLngMatch = segment.activity.end.latLng.match(/(-?\d+\.\d+)\s*¬∞,\s*(-?\d+\.\d+)/);
                                if (!startLatLngMatch || !endLatLngMatch) return null;
                                const startLat = parseFloat(startLatLngMatch[1]);
                                const startLng = parseFloat(startLatLngMatch[2]);
                                const endLat = parseFloat(endLatLngMatch[1]);
                                const endLng = parseFloat(endLatLngMatch[2]);
                                if (isNaN(startLat) || isNaN(startLng) || isNaN(endLat) || isNaN(endLng)) return null;
                                const activitySegment = {
                                    activityType: segment.activity.topCandidate.type || 'UNKNOWN',
                                    duration: { startTimestamp: startTime, endTimestamp: endTime },
                                    distance: segment.activity.distanceMeters,
                                    startLocation: {
                                        latitudeE7: Math.round(startLat * 1e7),
                                        longitudeE7: Math.round(startLng * 1e7)
                                    },
                                    endLocation: {
                                        latitudeE7: Math.round(endLat * 1e7),
                                        longitudeE7: Math.round(endLng * 1e7)
                                    },
                                    editConfirmationStatus: segment.activity.editConfirmationStatus,

                                    simplifiedRawPath: { // Structure expected by rendering function
                                        distanceMeters: segment.activity.distanceMeters,
                                        points: []
                                    }
                                };
                                // Efficiently find associated path points
                                const segmentStartMoment = moment(startTime);
                                const segmentEndMoment = moment(endTime);
                                for (let i = pathPointPointer; i < allPathPoints.length; i++) {
                                    const pointTime = moment(allPathPoints[i].time);
                                    if (pointTime.isBefore(segmentStartMoment)) {
                                        // If the point is before the segment starts, advance the pointer
                                        pathPointPointer = i + 1;
                                        continue;
                                    }
                                    if (pointTime.isAfter(segmentEndMoment)) {
                                        // If the point is after the segment ends, we're done for this segment
                                        break;
                                    }
                                    // Point is within the segment's time range
                                    activitySegment.simplifiedRawPath.points.push(allPathPoints[i]);
                                }
                                return { activitySegment: activitySegment };
                            }

                            return null; // Return null for segments that can't be processed
                        }).filter(Boolean); // Remove null entries
                        // Group by year and month
                        processedTimelineObjects.forEach(item => {
                             const timestamp = item.placeVisit ? item.placeVisit.duration.startTimestamp : item.activitySegment.duration.startTimestamp;
                             const date = new Date(timestamp);
                             if (isNaN(date.getTime())) return;
                             const key = `${date.getFullYear()}_${moment(date).format('MMMM').toUpperCase()}`;
                             if (!processedData[key]) processedData[key] = { timelineObjects: [] };
                             processedData[key].timelineObjects.push(item);
                             if (item.activitySegment) activityTypes.add(item.activitySegment.activityType);
                         });
                         timelineData = processedData;
                    } else {
                            throw new Error("Timeline data does not contain known data structure (timelineObjects or semanticSegments).");
                    }
                    console.log('Timeline data loaded successfully');
                } else {
                    // Fallback to original method of reading multiple JSON files (Takeout Month files format)
                    dataSourceText = 'Google Takeout (Monthly Files)';

                    let fileFoundInThisLevel = false; // Track if files are found at the current level/recursion
                    for await (const entry of dirHandle.values()) {
                        if (entry.kind === 'file' && entry.name.endsWith('.json') && /^\d{4}_\w+\.json$/i.test(entry.name)) {
                            // Process monthly file directly
                            fileFoundInThisLevel = true; // Mark that we found a file here
                            console.log(`Processing ${entry.name}`);
                            const file = await entry.getFile();
                            const content = await file.text();
                            try {
                                const data = JSON.parse(content);
                                const fileNameKey = entry.name.split('.')[0].toUpperCase();
                                if (data.timelineObjects) {
                                    // Directly add to the global timelineData object
                                    timelineData[fileNameKey] = data;
                                    data.timelineObjects.forEach(item => {
                                        if (item.activitySegment?.activityType) {
                                            activityTypes.add(item.activitySegment.activityType);
                                        }
                                    });
                                } else {
                                    console.warn(`Skipping file ${entry.name}: Does not contain 'timelineObjects'. File keys:`, Object.keys(data));
                                }
                            } catch (parseError) {
                                console.warn(`Skipping file ${entry.name} due to JSON parsing error:`, parseError.message);
                            }
                        } else if (entry.kind === 'directory') {
                            // Make recursive call for subdirectories
                             console.log(`Recursively checking directory: ${entry.name}`);
                            await readFilesFromDirectory(entry, true);
                        }
                    }
                     // Check if files were found ONLY on the initial call if no Timeline.json was processed
                    if (!isRecursive && !timelineJsonFile && Object.keys(timelineData).length === 0) {
                        throw new Error("No valid timeline data files found in the selected folder or subfolders.");
                    }
                }
                if (!isRecursive) {
                    // --- Post Loading ---
                    if (Object.keys(timelineData).length > 0) {
                    document.getElementById('data-source-indicator').textContent = 'Data source: ' + dataSourceText;
                    populateActivityFilters();
                    setUIEnabled(true);
                    const startDate = new Date(document.getElementById('startDatePicker').value);
                    const endDate = new Date(document.getElementById('endDatePicker').value);
                        await loadTimelineDataInDateRange(startDate, endDate); // Await initial load
                    } else {
                        document.getElementById('data-source-indicator').textContent = 'No valid timeline data found.';
                        setUIEnabled(false); // Keep UI disabled
                    }
                }
            } catch (err) {
                console.error('Error processing directory:', err);
                alert(`Error processing folder: ${err.message}`);

                 if (!isRecursive) { // Ensure UI is disabled on error during initial call
                     setUIEnabled(false);
                 }
            } finally {
                 if (!isRecursive) {
                     document.getElementById('loading-overlay').style.display = "none";
                 }
            }
        }

        async function initFolderPicker() {
            const folderPicker = document.getElementById('folderPicker');
            folderPicker.addEventListener('click', async () => {
                try {
                    const opts = { mode: 'read' };
                    const dirHandle = await window.showDirectoryPicker(opts);
                    await readFilesFromDirectory(dirHandle);
                } catch (err) {
                    if (err.name === 'AbortError') {
                        console.log('Folder selection cancelled.');
                    } else {
                        console.error('Error selecting folder:', err);
                        alert(`Could not select folder: ${err.message}`);
                    }
                     // Ensure loading overlay is hidden if selection fails/is cancelled
                    document.getElementById('loading-overlay').style.display = "none";
                    // Keep UI disabled if it failed before loading started
                    if(Object.keys(timelineData).length === 0) setUIEnabled(false);
                }
            });
        }

        window.onload = () => {
            initMap();
            initDatePicker();
            initFolderPicker();
            initLayerButton();
            initFitMapButton();
            initSummaryView(); // Initialize Summary View Listeners
            setUIEnabled(false); // Start with UI disabled
            document.addEventListener('keydown', (e) => {
                if (!uiEnabled) return;
                // Allow arrow keys if focus is not on an input/button element
                if (!e.target.matches('input, button')) {
                     if (e.key === 'ArrowLeft') {
                        document.getElementById("prevDayBtn").click();
                     } else if (e.key === 'ArrowRight') {
                        document.getElementById("nextDayBtn").click();
                    }
                }
            });
        };
    </script>
</body>
</html>
