<!DOCTYPE html>
<html lang="en">

<!-- -----
        Be sure to set your actual API key in place of "YOUR_API_KEY" (line 20)

        Version: July 31, 2025
        Full details here:
        https://github.com/kurupted/google-maps-timeline-viewer/

    ----  -->

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <title>Google Maps Timeline Viewer</title>

    <!-- Google Maps importLibrary loader -->
    <script>
        window.GOOGLE_MAPS_API_KEY = "YOUR_API_KEY"; // Replace YOUR_API_KEY with your actual key

        (g => {
            var h, a, k, p = "The Google Maps JavaScript API", c = "google", l = "importLibrary", q = "__ib__", m = document, b = window;
            b = b[c] || (b[c] = {});
            var d = b.maps || (b.maps = {}), r = new Set, e = new URLSearchParams,
                u = () => h || (h = new Promise(async (f, n) => {
                    await (a = m.createElement("script"));
                    e.set("libraries", [...r] + "");
                    for (k in g) e.set(k.replace(/[A-Z]/g, t => "_" + t[0].toLowerCase()), g[k]);
                    e.set("callback", c + ".maps." + q);
                    // Use the globally stored API key
                    if (g.key) { // Check if a key was passed in the config object
                        e.set("key", g.key);
                    }
                    a.src = `https://maps.${c}apis.com/maps/api/js?` + e;
                    d[q] = f;
                    a.onerror = () => h = n(Error(p + " could not load."));
                    a.nonce = m.querySelector("script[nonce]")?.nonce || "";
                    m.head.append(a);
                }));
            d[l] ? console.warn(p + " only loads once. Ignoring:", g) : d[l] = (f, ...n) => r.add(f) && u().then(() => d[l](f, ...n))
        })
        ({ key: window.GOOGLE_MAPS_API_KEY,
            v: "beta",
            libraries: "places" });
    </script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.29.1/moment.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/moment-timezone/0.5.43/moment-timezone-with-data.min.js"></script>

    <style>
        body, html {
            height: 100%;
            margin: 0;
            font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, 'Open Sans', 'Helvetica Neue', sans-serif;
            background-color: #f8f9fa;
            overflow: hidden; /* Prevent body scroll */
        }
        a {
            color: #007bff;
            text-decoration:none;
        }
        a:hover {
            text-decoration:underline;
        }
        #container {
            display: flex;
            height: 100%;
            position: relative;
        }

        /* --- Sidebar Styles --- */
        #sidebar {
            width: 350px;
            background-color: #ffffff;
            border-right: 1px solid #dee2e6;
            display: flex;
            flex-direction: column; /* Stack elements vertically */
            height: 100%;
            overflow: hidden;
            position: relative;
            z-index: 60;
            flex-shrink: 0;
        }
        #sidebar-main {
            flex-grow: 1; /* Make this new wrapper fill the space */
            position: relative;
            overflow: hidden; /* Hide overflow */
            display: flex; /* This will contain our single visible tab */
        }

        #dateView, #searchView, #settingsView, #areaView {
            width: 100%;
            height: 100%;
            display: none; /* All tabs hidden by default */
            flex-direction: column;
            flex-grow: 1;
            overflow: hidden; /* Prevent the tab itself from scrolling */
        }
        #searchView, #settingsView {
            display: none;
            flex-direction: column;
        }
        #dateView {
            display: none; /* Will be changed to 'flex' by JS */
            flex-direction: column;
        }

        /* --- Control Sections (Non-scrolling) --- */
        #controls-container {
            display: flex;
            justify-content: space-between; /* Right-aligns the second group of buttons */
            align-items: center;
            gap: 8px;
            padding: 10px 12px;
            border-bottom: 1px solid #e9ecef;
            flex-shrink: 0;
        }
        #controls-left, #controls-right {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        #datePickerContainer,
        #date-range-info,
        #icon-buttons-container,
        #go-container {
            padding: 10px 12px;
            border-bottom: 1px solid #e9ecef;
            flex-shrink: 0; /* Prevent these sections from shrinking */
            background-color: #ffffff; /* Ensure background */
        }
        .control-btn {
            flex-grow:0;
            padding: 10px 15px;
            background-color: #5A95F5;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: background-color 0.2s ease, box-shadow 0.2s ease;
            text-align: center;
        }
        .control-btn:hover:not(:disabled) {
            background-color: #4a85e5;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .control-btn:disabled {
            background: #ced4da;
            cursor: not-allowed;
            color: #6c757d;
        }
        #reloadBtn {
            display:none; /* don't need this atm */
            flex-grow: 0; /* Don't let it grow */
            padding: 10px;
            background-color: #6c757d;
        }
        #reloadBtn:hover:not(:disabled) {
            background-color: #5a6268;
        }


        /* --- Settings View --- */
        #settingsView {
            display: none; /* Initially hidden */
            width: 100%;    /* Fill the wrapper */
            height: 100%;   /* Fill the wrapper */
            overflow-y: auto; /* Make this section scrollable */
            padding: 10px 12px;
            border-bottom: 1px solid #e9ecef;
            background-color: #ffffff;
            flex-direction: column;
        }
        #settingsHeader {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        #settingsView h4 {
            margin-top: 25px;
            margin-bottom: 15px;
            font-weight: 500;
            border-bottom: 1px solid #e9ecef;
            padding-bottom: 5px;
        }
        #settingsView h4:first-of-type {
            margin-top: 20px;
        }
        #settingsView label {
            display: block;
            margin-bottom: 8px;
            font-size: 14px;
        }
        .settings-option {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
        }
        .settings-checkbox {
            margin-right: 8px;
        }
        #activityFilters {
            margin-left: 20px;
            padding-top: 5px;
            padding-bottom: 40px;
        }
        #timezone-select,
        #distance-unit-select {
            width: 100%;
            padding: 8px;
            margin-bottom:10px;
            border-radius: 4px;
            border: 1px solid #ced4da;
            font-size: 14px;
        }

        /* --- Date Picker --- */
        #datePickerContainer {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 6px;
        }
        #startDatePicker, #endDatePicker {
            flex: 1;
            padding: 8px 10px;
            border: 1px solid #ced4da;
            border-radius: 4px;
            font-size: 12px;
            background-color: #fff;
        }
        #startDatePicker:disabled, #endDatePicker:disabled {
            background-color: #e9ecef;
            cursor: not-allowed;
        }
        #datePickerContainer span {
            color: #6c757d;
        }
        #dateToSpan {
            font-size: 10px;
        }
        #prevDayBtn, #nextDayBtn {
            background: #f8f9fa;
            border: 1px solid #ced4da;
            border-radius: 4px;
            padding: 2px 4px;
            cursor: pointer;
            font-size: 10px;
            color: #495057;
            transition: all 0.2s ease;
        }
        #prevDayBtn:hover:not(:disabled), #nextDayBtn:hover:not(:disabled) {
            background: #e9ecef;
            color: #343a40;
        }
        #prevDayBtn:disabled, #nextDayBtn:disabled {
            background: #e9ecef;
            color: #adb5bd;
            cursor: not-allowed;
        }

        /* --- Date Range Info --- */
        #date-range-info {
            font-size: 11px;
            color: #6c757d;
            text-align: center;
            padding-top: 5px;
            padding-bottom: 5px;
            min-height: 15px; /* Reserve space */
        }
        #date-range-info span {
            cursor: pointer;
            color: #007bff;
            text-decoration: underline;
            margin: 0 5px;
        }
        #date-range-info span:hover {
            color: #0056b3;
        }

        #date-context-menu {
            font-size: 14px;
            color: #333;
        }
        .context-menu-item {
            padding: 8px 15px;
            cursor: pointer;
        }
        .context-menu-item:hover {
            background-color: #007bff;
            color: white;
        }

        /* --- Icon Buttons --- */
        #icon-buttons-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding-top: 8px;
            padding-bottom: 8px;
            min-height: 30px;
        }
        #icon-buttons-left, #icon-buttons-right {
            display: flex;
            gap: 2px;
        }
        .icon-btn {
            background: none;
            border: none;
            font-size: 14px;
            cursor: pointer;
            color: #6c757d;
            border-radius: 4px;
            transition: background-color 0.2s ease, color 0.2s ease;
            display: flex; /* Align icon and text */
            align-items: center; /* Vertically center icon and text */
            gap: 6px; /* Space between icon and text */
            padding: 5px 8px;
        }
        .icon-btn:hover:not(:disabled) {
            background-color: #e9ecef;
            color: #343a40;
        }
        .icon-btn:disabled {
            color: #adb5bd;
            cursor: not-allowed;
            filter: grayscale(100%);
            opacity: 0.7;
        }
        .icon-btn.active { /* Style for the active view button */
            background-color: #dde4ed; /* A slightly different background */
            color: #0056b3; /* A distinct color */
        }

        /* --- Go Button --- */
        #go-container {
            display: flex;
            align-items: center;
            justify-content: center;
            padding-top: 5px;
        }
        #goBtn, #findInAreaBtn {
            flex-grow: 1;
            padding: 12px 20px;
            background-color: #48a765;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 15px;
            font-weight: 500;
            transition: background-color 0.2s ease, box-shadow 0.2s ease;
        }
        #goBtn:hover:not(:disabled),
        #findInAreaBtn:hover:not(:disabled){
            background-color: #218838;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        #goBtn:disabled, #findInAreaBtn:disabled {
            background: #ced4da;
            color: #6c757d;
            cursor: not-allowed;
        }
        #goBtn:disabled:hover, #findInAreaBtn:disabled:hover {
            background: #ced4da;
            box-shadow: none;
        }

        /* --- Search View --- */
        #searchView {
            display: none; /* Initially hidden */
            width: 100%; /* Fill the wrapper */
            height: 100%; /* Fill the wrapper */
            background-color: #f8f9fa;
            flex-direction: column; /* To stack header, input, results */
        }
        #searchHeader {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 12px;
            background-color: #ffffff;
            border-bottom: 1px solid #e9ecef;
            flex-shrink: 0;
        }
        #searchHeader h4 {
            margin: 0;
            font-weight: 500;
        }
        #search-controls {
            padding: 10px 12px;
            background-color: #ffffff;
            border-bottom: 1px solid #e9ecef;
            flex-shrink: 0;
        }
        #searchInput {
            width: 100%;
            padding: 10px;
            font-size: 14px;
            border: 1px solid #ced4da;
            border-radius: 4px;
            box-sizing: border-box; /* Important */
        }
        #searchResults {
            padding: 10px 12px;
            flex-grow: 1;
            overflow-y: auto;
            min-height: 0;
        }
        .search-result-item {
            background-color: #ffffff;
            border: 1px solid #e9ecef;
            border-radius: 5px;
            padding: 10px;
            margin-bottom: 8px;
            cursor: pointer;
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
        }
        .search-result-item:hover {
            border-color: #adb5bd;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
        }
        .search-result-item strong {
            display: block;
            font-size: 15px;
            color: #343a40;
            margin-bottom: 4px;
        }
        .search-result-item span {
            font-size: 13px;
            color: #6c757d;
        }
        /* --- Autocomplete Suggestions --- */
        #autocomplete-suggestions-container {
            position: relative; /* Container for positioning the dropdown */
        }
        .clear-search-btn {
            position: absolute;
            right: 8px;
            top: 50%;
            transform: translateY(-50%);
            background-color: #eee;
            border: none;
            font-size: 20px;
            color: #999;
            cursor: pointer;
            padding: 0 5px;
            line-height: 1;
            display: none; /* Hidden by default, shown with JS */
        }
        .clear-search-btn:hover {
            color: #333;
        }
        #autocomplete-results {
            position: absolute;
            border: 1px solid #d4d4d4;
            border-top: none;
            z-index: 99;
            top: 100%;
            left: 0;
            right: 0;
            background-color: #fff;
            border-radius: 0 0 4px 4px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        .autocomplete-suggestion-item {
            padding: 10px;
            cursor: pointer;
            background-color: #fff;
            border-bottom: 1px solid #ddd;
            font-size: 14px;
            display: flex;
            align-items: center;
        }
        .autocomplete-suggestion-item:last-child {
            border-bottom: none;
        }
        .autocomplete-suggestion-item:hover {
            background-color: #e9e9e9;
        }
        .pac-icon { /* Google's icon */
            display: inline-block;
            width: 15px;
            height: 15px;
            margin-right: 7px;
            background-image: url(https://maps.gstatic.com/mapfiles/api-3/images/autocomplete-icons.png);
            background-size: 34px;
            background-position: -1px -1px;
            flex-shrink: 0;
        }

        /* --- Styles for New Area View Controls --- */
        #area-controls-header {
            padding: 10px 12px;
            border-bottom: 1px solid #e9ecef;
            flex-shrink: 0;
            background-color: #ffffff;
            display: flex;
        }
        #area-controls-header .control-btn {
            flex-grow: 1;
        }
        #area-options-container {
            padding: 10px 12px;
            border-bottom: 1px solid #e9ecef;
            flex-shrink: 0;
            background-color: #ffffff;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .area-options-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
            margin-bottom: 10px;
        }
        .area-options-title {
            font-size: 13px;
            font-weight: 500;
            color: #495057;
        }
        .radio-group {
            display: flex;
            flex-direction: column; /* Stack items vertically */
            gap: 8px;
            font-size: 13px;
        }
        .radio-group label {
            display: flex;
            align-items: center;
            gap: 4px;
        }
        #areaResultLimit {
            padding: 6px;
            border: 1px solid #ced4da;
            border-radius: 4px;
            font-size: 13px;
            background-color: #fff;
            align-self: flex-start; /* Prevent stretching */
        }
        /* --- Area View Styles --- */
        #area-controls {
            padding: 10px 12px;
            border-bottom: 1px solid #e9ecef;
            flex-shrink: 0;
            background-color: #ffffff;
            display: flex;
            align-items: center;
            gap: 15px; /* Space between button and options */
        }
        .area-options {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 13px;
            color: #495057;
        }
        #areaResults {
            flex-grow: 1;
            overflow-y: auto;
            padding: 10px 12px;
            background-color: #f8f9fa;
        }
        .area-placeholder {
            padding: 20px;
            text-align: center;
            font-size: 14px;
            color: #6c757d;
            line-height: 1.5;
        }
        #areaResults .timeline-item {
            cursor: pointer;
        }
        #areaResults .timeline-item:hover {
            border-color: #adb5bd;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
        }

        /* --- Styles for Consolidated Area Results --- */
        .consolidated-visit-dates {
            margin-top: 8px;
            font-size: 12px;
            color: #6c757d;
        }
        .consolidated-visit-dates span {
            display: inline-block;
            margin-right: 8px;
            margin-bottom: 4px;
            padding: 2px 6px;
            background-color: #e9ecef;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .consolidated-visit-dates span:hover {
            background-color: #007bff;
            color: white;
            text-decoration: none;
        }
        .timeline-item.consolidated {
            cursor: default; /* Remove pointer cursor from the main body */
        }

        #main-content-area {
            flex-grow: 1; /* This makes the wrapper take all available space */
            position: relative;
            overflow: hidden;
            display: flex;
        }

        /* Ensure the timeline inside the main area is scrollable */
        #timeline {
            width: 100%;
            height: 100%;
            overflow-y: auto;
            padding: 10px 12px;
            padding-top: 0px;
            background-color: #f8f9fa;
        }
        /* --- Sticky Date Header --- */
        #timeline .date-header{
            display: flex;
            align-items: center;
            margin-bottom: 10px;
            padding: 8px 10px;
            background-color: #cccccc;
            position: sticky; /* Enable sticky behavior */
            top: 0; /* Stick to the top of the #timeline container */
            z-index: 10; /* Ensure it stays above timeline items */
            font-weight: 600;
            border-bottom: 1px solid #dee2e6;
            font-size: 14px;
            color: #192027;
        }
        .timeline-item {
            display: flex;
            align-items: flex-start;
            margin-bottom: 8px;
            padding: 8px;
            background-color: #ffffff;
            border: 1px solid #e9ecef;
            border-radius: 5px;
            cursor: pointer;
            position: relative;
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
        }
        .timeline-item:hover {
            border-color: #adb5bd;
        }
        .timeline-icon-container {
            width: 32px;
            text-align: center;
            padding-right: 10px;
            padding-top: 2px;
            flex-shrink: 0;
            font-size: 24px;
        }
        .timeline-icon-svg {
            width: 24px;
            height: 24px;
            display: inline-block;
        }
        .timeline-item-details {
            flex-grow: 1;
        }
        .timeline-item-details strong {
            font-weight: 500;
            font-size: 15px;
            color: #343a40;
        }
        .timeline-item-details div {
            font-size: 14px;
            line-height: 1.4;
            color: #495057;
        }
        .timeline-item-time {
            display: block;
            font-size: 12px;
            color: #6c757d;
            margin-top: 2px;
            margin-bottom: 4px;
        }
        /* Specific style for distance */
        .timeline-item-details .distance {
            font-size: 12px;
            color: #6c757d;
        }
        .place-visit-item {
            background-color: #FFFAF0 !important; /* Light yellow background */
            border-left: 4px solid #ffc107; /* Yellow border */
            padding-left: 10px;
        }
        /* Adjust Activity Segment border */
        .timeline-item:not(.place-visit-item) { /* Target activity segments */
            border-left: 4px solid var(--activity-color, #6c757d); /* Use CSS variable for color */
            padding-left: 10px;
        }
        .highlighted {
            border-color-top: #007bff !important;
            border-color-right: #007bff !important;
            border-color-bottom: #007bff !important;
            box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.35);
        }
        .confirmed-checkmark {
            position: absolute;
            bottom: 5px;
            right: 8px;
            font-size: 12px;
            opacity: 0.3;
            color: #28a745;
        }
        .highlighted .confirmed-checkmark{
            opacity: 0.6;
        }


        /* --- Bottom Sidebar Elements (Non-scrolling) --- */
        #status-bar-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 11px;
            padding: 8px 12px;
            color: #6c757d;
            border-top: 1px solid #e9ecef;
            flex-shrink: 0;
            background-color: #ffffff;
            gap: 10px;
        }
        #status-info {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            gap: 2px;
            text-align: left;
        }
        #cache-indicator {
            display: flex; /* Changed from none to flex */
            align-items: center;
            gap: 8px;
            font-size: 10px;
        }
        #new-cache-count, #new-cache-count-label {
            color: #28a745;
            font-weight: bold;
        }
        #api-controls {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 2px;
            text-align: right;
            flex-shrink: 1;
        }
        #data-source-indicator {
            text-align: left; /* Align text to the left */
            flex-grow: 1; /* Allow it to take available space */
        }
        #api-call-counter {
            font-weight: bold;
            color: #343a40;
            text-align: right;
        }
        #cache-controls {
            display: inline-block;
            padding: 0px 0px;
            padding-top: 3px;
            background-color: #ffffff;
        }
        .cache-btn {
            padding: 4px 6px;
            font-size: 10px;
            background-color: #e9ecef;
            color: #495057;
            border: 1px solid #ced4da;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }
        .cache-btn:hover:not(:disabled) {
            background-color: #dde4ed;
        }
        .cache-btn:disabled {
            background-color: #f8f9fa;
            color: #adb5bd;
            cursor: not-allowed;
        }
        #disableApiBtn.active {
            background-color: #f2bcb8;
        }
        #about-container {
            margin-top: auto; /* Pushes About link to the very bottom */
            font-size: 11px;
            padding: 8px 12px;
            padding-top: 0; /* Remove extra top padding */
            color: #6c757d;
            text-align: center;
            border-top: 1px solid #e9ecef;
            flex-shrink: 0;
            background-color: #ffffff;
        }


        /* --- Map Styles --- */
        #map {
            flex-grow: 1;
            height: 100%;
            position: relative; /* Needed for absolute positioning of summary view */
            transition: opacity 0.3s ease; /* Smooth map fade */
        }
        .map-custom-controls {
            position: absolute;
            bottom: 25px;
            right: 80px;
            z-index: 10;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .map-overlay-btn {
            background-color: #fff;
            border: none;
            border-radius: 2px;
            box-shadow: 0 2px 6px rgba(0,0,0,.3);
            cursor: pointer;
            padding: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 120%;
            width: 36px; /* Consistent size */
            height: 36px;
            line-height: 1;
        }
        .map-overlay-btn:disabled {
            cursor: not-allowed;
            background-color: #f5f5f5;
            color: #aaa;
        }
        /* --- Advanced Marker (if needed, seems okay) --- */
        .advanced-marker { display: flex; flex-direction: column; align-items: center; }
        .marker-icon { font-size: 24px; }
        .marker-label { font-size: 12px; white-space: nowrap; }

        /* --- Info Window Photo Placeholder --- */
        .photo-placeholder {
            width: 200px;
            height: 150px;
            background-color: #eee;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #aaa;
            font-size: 12px;
            border-radius: 3px;
            margin-top: 5px;
            text-align: center; /* Center text */
        }
        .photo-container img {
            max-width: 200px;
            max-height: 150px;
            margin-top: 5px;
            border-radius: 3px;
            display: block; /* Ensure img takes block space */
        }

        /* --- Summary View Styles --- */
        #summaryView,
        #howToMessage {
            position: absolute; /* Position over the map area */
            top: 0;
            left: 351px; /* Sidebar width (350px) + border (1px) */
            right: 0;
            bottom: 0;
            background-color: #f8f9fa; /* Match sidebar scroll background */
            z-index: 50; /* Above map, below loading overlay */
            padding: 20px;
            padding-left:40px;
            overflow-y: auto; /* Scroll if content overflows */
            border-left: 1px solid #dee2e6; /* Match sidebar border */
            font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
        }
        #summary-controls {
            text-align: right;
            margin-bottom: 10px;
        }
        #closeSummaryBtn {
            background: none;
            border: 1px solid #ccc;
            border-radius: 50%;
            cursor: pointer;
            font-size: 16px;
            line-height: 1;
            width: 24px;
            height: 24px;
            color: #666;
            padding: 0;
        }
        #closeSummaryBtn:hover {
            background-color: #eee;
            border-color: #aaa;
        }
        #summaryView h4 {
            margin-top: 15px;
            margin-bottom: 8px;
            border-bottom: 1px solid #e0e0e0;
            padding-bottom: 5px;
            font-weight: 500;
            color: #333;
        }
        #summaryView h4:first-of-type {
            margin-top: 0;
        }
        #summary-selected-dates,
        #summary-years, /* Apply flexbox to the direct container of year items */
        #summary-months {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }
        #summary-months {
            display: none; /* Hide months initially */
        }
        #backToYearsBtn {
            display: none; /* Hide back button initially */
            margin-bottom: 15px;
            padding: 5px 10px;
            font-size: 12px;
            cursor: pointer;
            background-color: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            color: #495057;
        }
        #backToYearsBtn:hover {
            background-color: #e9ecef;
        }

        .summary-selected-item,
        .summary-year-item,
        .summary-month-item {
            border: 1px solid #ced4da;
            padding: 10px;
            border-radius: 5px;
            background-color: #ffffff;
            cursor: default; /* Default cursor for selected/year/month */
            transition: background-color 0.2s ease, border-color 0.2s ease, width 0.3s ease, opacity 0.3s ease; /* Added opacity transition */
            min-width: 170px; /* Ensure items have some width */
            font-size: 13px;
            box-sizing: border-box; /* Include padding/border in width */
            opacity: 1; /* Ensure visible by default */
        }
        /* Allow click cursor only for year/month items */
        .summary-year-item, .summary-month-item {
            cursor: pointer;
        }
        .summary-year-item:hover, .summary-month-item:hover {
            border-color: #adb5bd;
            background-color: #f1f3f4;
        }
        .summary-year-item.is-selected-year { /* Style for the expanded year */
            border-color: #007bff;
            background-color: #e7f1ff;
            font-weight: bold;
            width: 100%; /* Expand to full width */
            cursor: default; /* No pointer cursor when expanded */
            opacity: 1; /* Ensure selected year is fully visible */
        }
        .summary-year-item.is-selected-year:hover { /* Override hover when expanded */
            border-color: #007bff;
            background-color: #e7f1ff;
        }

        /* Hide non-selected years when one is expanded */
        #summaryView.expanded-year-active #summary-years .summary-year-item:not(.is-selected-year) {
            opacity: 0;
            pointer-events: none; /* Prevent interaction with hidden items */
            height: 0; /* Collapse height */
            padding: 0; /* Remove padding */
            margin: 0; /* Remove margin */
            border: none; /* Remove border */
            overflow: hidden; /* Hide content */
        }
        /* Show months and back button when a year is expanded */
        #summaryView.expanded-year-active #summary-months,
        #summaryView.expanded-year-active #backToYearsBtn {
            display: flex; /* Or block, depending on desired layout */
        }

        .summary-selected-item strong,
        .summary-year-item strong,
        .summary-month-item strong {
            display: block;
            font-size: 16px;
            margin-bottom: 5px;
            color: #0056b3;
        }
        .summary-month-item strong {
            color: #1a73e8;
        }
        .summary-selected-item strong { /* Specific style for selected date title */
            color: #28a745; /* Green */
        }
        .summary-details {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 12px;
            color: #495057;
            margin-top: 3px;
        }
        .summary-details span {
            text-align: right;
        }
        /* Common style for activity lists */
        .summary-selected-item ul,
        .summary-year-item ul,
        .summary-month-item ul {
            list-style: none;
            padding: 0;
            margin: 8px 0 0 0;
            font-size: 11px;
            color: #6c757d;
        }
        /* Style for multi-column activity list in expanded year */
        .summary-year-item.is-selected-year ul {
            column-count: 3;
            column-gap: 20px;
        }
        .summary-year-item.is-selected-year ul li,
        .summary-year-item.is-selected-year .summary-details {
            max-width: 170px;
        }
        @media (max-width: 600px) { /* Use 1 column on smaller screens */
            .summary-year-item.is-selected-year ul {
                column-count: 1;
            }
        }

        .summary-selected-item ul li,
        .summary-year-item ul li,
        .summary-month-item ul li {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 2px; /* Consistent spacing */
            break-inside: avoid-column; /* Prevent list items from breaking across columns */
        }
        /* Common style for distance values in lists */
        .summary-selected-item li span,
        .summary-year-item li span,
        .summary-month-item li span {
            color: #343a40;
            font-weight: 500;
        }

        /* Style to hide map when summary is shown */
        #map.hidden {
            opacity: 0;
            pointer-events: none; /* Prevent interaction with hidden map */
        }
        /* --- Loading Overlay --- */
        #loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            display: none; /* Initially hidden */
            z-index: 1000; /* Ensure above summary view */
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 1.2em;
        }
        #loading-spinner {
            border: 8px solid #f3f3f3;
            border-top: 8px solid #5A95F5;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1.5s linear infinite;
            margin-bottom: 15px;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }


        /* For API Key Modal */
        #apiKeyModal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            z-index: 2000;
            display: none; /* Use flex to center */
            align-items: center;
            justify-content: center;
            color: #333;
            font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, 'Open Sans', 'Helvetica Neue', sans-serif;
        }
        .modal-content {
            background: #fff;
            padding: 20px 30px;
            border-radius: 8px;
            text-align: center;
            max-width: 400px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }
        #apiKeyModal input {
            width: 100%;
            padding: 10px;
            margin: 10px 0;
            box-sizing: border-box;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 14px;
        }
        #apiKeyModal button {
            padding: 10px 20px;
            background-color: #5A95F5;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
        }
        #apiKeyModal button:hover {
            background-color: #4a85e5;
        }
        #apiKeyModal a {
            color: #007bff;
        }
        
        /*
		========================================
		RESPONSIVE STYLES
		========================================
		*/

		/* --- Mobile View Switcher --- */
		#mobile-view-switcher {
			display: none; /* Hidden on desktop */
			position: fixed;
			bottom: 0;
			left: 0;
			width: 100%;
			height: 55px;
			/* Accomodate for iOS safe area (the notch/home bar) */
			padding-bottom: env(safe-area-inset-bottom, 0);
			box-sizing: content-box;
			background-color: #f8f9fa;
			border-top: 1px solid #dee2e6;
			z-index: 500;
			box-shadow: 0 -2px 5px rgba(0,0,0,0.05);
		}

		#mobile-view-switcher button {
			flex: 1;
			background: none;
			border: none;
			border-right: 1px solid #dee2e6;
			font-size: 16px;
			font-weight: 500;
			color: #495057;
			cursor: pointer;
			transition: background-color 0.2s ease, color 0.2s ease;
			display: flex;
			align-items: center;
			justify-content: center;
			gap: 8px;
		}

		#mobile-view-switcher button:last-child {
			border-right: none;
		}

		#mobile-view-switcher button.active {
			background-color: #e9ecef;
			color: #007bff;
		}

		/* --- Main Responsive Layout --- */
		@media (max-width: 768px) {
			#container {
				display: block; /* Remove flex, stack elements */
			}

			#mobile-view-switcher {
				display: flex; /* Show the switcher on mobile */
			}

			#sidebar {
				width: 100%;
				/* Use dvh instead of vh to account for browser UI */
				height: calc(100dvh - 55px - env(safe-area-inset-bottom, 0));
				border-right: none;
			}

			#map {
				position: fixed;
				top: 0;
				left: 0;
				width: 100%;
				height: calc(100dvh - 55px - env(safe-area-inset-bottom, 0));
				z-index: 1;
			}

			.map-custom-controls {
				bottom: calc(55px + env(safe-area-inset-bottom, 0) + 15px); 
				right: 15px;
			}

			#summaryView, #howToMessage {
				left: 0;
				width: 100%;
				height: calc(100dvh - 55px - env(safe-area-inset-bottom, 0));
				box-sizing: border-box;
				padding: 15px;
				border-left: none;
			}

			.mobile-hidden {
				display: none !important;
			}
		}
    </style>

</head>
<body>
<div id="apiKeyModal"><!-- not used atm. will fix later -->
    <div class="modal-content">
        <h3>Enter API Key</h3>
        <p>A Google Maps API Key is required. Please enter it below to continue.</p>
        <p><small>The key is only stored for this browser session.</small></p>
        <input type="text" id="apiKeyInput" placeholder="Paste your API key here">
        <button id="apiKeySubmit">Submit</button>
        <p><small>For instructions on getting a key, see the <a href="https://github.com/kurupted/google-maps-timeline-viewer/" target="_blank" rel="noopener">project page</a>.</small></p>
    </div>
</div>
<div id="container">
    <div id="sidebar">

        <div id="controls-container">
            <div id="controls-left">
                <button id="folderPicker" class="control-btn">Load Data</button>
                <button id="reloadBtn" class="icon-btn" title="Reload last used folder" style="display: none;">&#x21bb;</button>
            </div>
            <div id="controls-right">
                <button id="calendarBtn" class="icon-btn" title="Date View" disabled>üìÖ</button>
                <button id="searchBtn" class="icon-btn" title="Search" disabled>üîç</button>
                <button id="areaBtn" class="icon-btn" title="Area View" disabled>‚¨ö</button>
                <button id="settingsBtn" class="icon-btn" title="Settings" disabled>‚öôÔ∏è</button>
            </div>
        </div>

        <div id="sidebar-main">
            <div id="dateView">
                <div id="datePickerContainer">
                    <button id="prevDayBtn" disabled>&lt;</button>
                    <input type="date" id="startDatePicker" disabled>
                    <span id="dateToSpan">to</span>
                    <input type="date" id="endDatePicker" disabled>
                    <button id="nextDayBtn" disabled>&gt;</button>
                </div>
                <div id="date-range-info"></div>
                <div id="icon-buttons-container">
                    <div id="icon-buttons-left">
                        <button id="mapBtn" class="icon-btn active" title="Show Map" disabled>
                            <span role="img" aria-label="Map">üó∫Ô∏è</span> Map
                        </button>
                        <button id="summaryBtn" class="icon-btn" title="Show Summary" disabled>
                            <span role="img" aria-label="Summary">üìä</span> Summary
                        </button>
                        <button id="kmlBtn" class="icon-btn" title="Export as KML" disabled>
                            <span role="img" aria-label="Export">üì§</span> Export KML
                        </button>
                    </div>
                    <div id="icon-buttons-right"></div>
                </div>
                <div id="go-container">
                    <button id="goBtn" class="control-btn" disabled>GO</button>
                </div>
                <div id="main-content-area">
                    <div id="timeline"></div>
                </div>
            </div>

            <div id="searchView">
                <div id="searchHeader">
                    <h4>Search Places</h4>
                </div>
                <div id="search-controls">
                    <div id="autocomplete-suggestions-container">
                        <input type="text" id="searchInput" placeholder="Enter a place name..." autocomplete="off">
                        <button id="clearSearchBtn" class="clear-search-btn">&times;</button>
                        <div id="autocomplete-results"></div>
                    </div>
                </div>
                <div id="searchResults"></div>
            </div>

            <div id="areaView">
                <div id="area-controls-header">
                    <button id="findInAreaBtn" class="control-btn">Find in this map area</button>
                    <button id="newAreaSearchBtn" class="control-btn" style="display: none;">New Search</button>
                </div>
                <div id="area-options-container">
                    <div class="area-options-group">
                        <label class="area-options-title">Result Display:</label>
                        <div class="radio-group">
                            <label><input type="radio" name="areaResultType" value="all" checked> A place entry for each visit</label>
                            <label><input type="radio" name="areaResultType" value="consolidated"> Single entry for <i>all</i> visits</label>
                        </div>
                    </div>
                    <div class="area-options-group">
                        <label for="areaResultLimit" class="area-options-title">Limit:</label>
                        <select id="areaResultLimit" title="Limit the number of results returned">
                            <option value="-1">Unlimited</option>
                            <option value="100" selected>100</option>
                            <option value="250">250</option>
                            <option value="500">500</option>
                        </select>
                    </div>
                </div>
                <div id="areaResults">
                    <p class="area-placeholder">Pan and zoom the map to your desired location, then click the button above to find all recorded visits in that area.</p>
                </div>
            </div>


            <div id="settingsView">
                <div id="settingsHeader">
                </div>
                <h4>Timezone</h4>
                <label for="timezone-select">Display times in:</label>
                <select id="timezone-select"></select>
                <h4>Distance Units</h4>
                <label for="distance-unit-select">Display distances in:</label>
                <select id="distance-unit-select">
                    <option value="km" selected>Kilometers</option>
                    <option value="mi">Miles</option>
                </select>
                <h4>Display Options</h4>
                <label class="settings-option">
                    <input type="checkbox" id="showVisits" class="settings-checkbox" checked> Show Visits
                </label>
                <label class="settings-option">
                    <input type="checkbox" id="showActivities" class="settings-checkbox" checked> Show Activities
                </label>
                <div id="activityFilters" style="margin-left: 20px;"></div>
            </div>
        </div>

        <div id="loading-overlay">
            <div id="loading-spinner"></div>
            <span>Loading data...</span>
        </div>

        <div id="status-bar-container">
            <div id="status-info">
                <span id="data-source-indicator">No data loaded. Use "Load Data".</span>
                <div id="cache-indicator" style="display: none;">
                    <span>
                        Place cache:
                        <span id="saved-cache-count">0</span> saved /
                        <span id="new-cache-count">0</span><span id="new-cache-count-label"> new</span>
                    </span>
                    <button id="saveCacheBtn" class="cache-btn" disabled>Save</button>
                </div>
            </div>
            <div id="api-controls">
                <span id="api-call-counter">API Calls: 0</span>
                <button id="disableApiBtn" class="cache-btn">Disable API</button>
            </div>
        </div>
    </div>

    <div id="summaryView" style="display: none;">
        <div id="summary-controls">
            <button id="closeSummaryBtn" title="Close Summary">&times;</button>
        </div>
        <h4>Selected Date(s) Summary</h4>
        <div id="summary-selected-dates">
            <p>Calculating...</p>
        </div><br>
        <h4>Yearly Summary</h4>
        <div id="summary-years-container">
            <div id="summary-years">
                <p>Calculating...</p>
            </div>
            <button id="backToYearsBtn">‚Üê Back to Years</button>
        </div><br>
        <h4>Monthly Summary <span id="summary-selected-year"></span></h4>
        <div id="summary-months">
            <p>Select a year above.</p>
        </div>
    </div>

    <div id="map" class=""></div>

    <div class="map-custom-controls">
        <button id="fitMapBtn" class="map-overlay-btn" title="Fit Map to Data" disabled>‚§¢</button>
        <button id="currentLocationBtn" class="map-overlay-btn" title="My Location">ñ¶è</button>
    </div>

    <div id="howToMessage">
        <h3>How to use:</h3>
        First, complete the initial setup as explained on the <a href="https://github.com/kurupted/google-maps-timeline-viewer/" target="_blank">Github project page</a>.<br><br>
        Click "Load Data" on the left and navigate to the folder that contains your Timeline data.<br>
        <h4>For Google Takeout data:</h4>
        The folder structure should be "Takeout\Location History (Timeline)\Semantic Location History".<br>
        Navigate into the "Semantic Location History" folder, and then click "Select Folder" on the dialog.<br>
        (Do not navigate into one of the yearly subfolders.)<br>
        <h4>For On-Device exported data:</h4>
        Simply choose the folder that contains your exported Timeline.json file.<br>
        (On non-English systems, the filename may be different -- rename the file to Timeline.json)<br>
        If you have a previously saved "TimelinePlaceCache.json" file, be sure it's in the same folder. This can speed up loading and reduce API calls.
        <br><br><br><br>
        After the data has loaded, use the date picker to choose a date or date range that contains timeline data.<br>
    </div>
</div>

<div id="date-context-menu" style="display:none; position:absolute; background-color: white; border: 1px solid #ccc; box-shadow: 0 2px 5px rgba(0,0,0,0.2); z-index: 1000; border-radius: 4px; padding: 5px 0;">
    <div class="context-menu-item" data-action="set-start">Set as Start Date</div>
    <div class="context-menu-item" data-action="set-end">Set as End Date</div>
    <div class="context-menu-item" data-action="set-both">Set as Start & End</div>
</div>

<script>
    // --- Global Variables ---
    let map;
    let markers = [];
    let polylines = [];
    let infoWindows = [];
    let selectedPolyline = null;
    let timelineData = {}; // Stores parsed timeline data, keyed by YYYY_MONTH
    let activityTypes = new Set(); // Keep track of unique raw activity types found
    let placeDetailsCache = {}; // Cache for storing Place Details results
    let globalIndex = 0; // Global counter for unique data-index across map/timeline
    let uiEnabled = false; // Flag to track if UI is enabled (data loaded)
    let placeApiCallCount = 0; // Counter for Place API calls
    let initialCacheSizeFromFile = 0;
    let apiCallsDisabled = false;
    let globalMinDate = null; // Earliest date in loaded data
    let globalMaxDate = null; // Latest date in loaded data
    let displayTimezone = 'default'; // User-selected timezone
    let distanceUnit = 'km'; // User-selected distance unit ('km' or 'mi')
    let storedDirHandle = null; // For storing last used directory handle
    let locationBias = null; // For biasing autocomplete results
    let lastAreaSearchResults = [];
    let lastAreaSearchMode = 'all';
    let lastTimelineItemToHighlight = null;

    // Summary View Globals
    let allYearlySummaries = null; // Calculated yearly summaries
    let allMonthlySummaries = null; // Calculated monthly summaries
    let selectedSummaryYear = null; // Track which year's months are shown
    let summaryViewVisible = false; // Track summary view state

    // --- Activity Type Mapping ---
    // Groups similar activity types for display and filtering
    const activityGroupMapping = {
        'DRIVING': ['IN_VEHICLE', 'IN_PASSENGER_VEHICLE', 'DRIVE'],
        'TAXI': ['IN_TAXI'],
        'MOTORCYCLING': ['MOTORCYCLING'],
        'CYCLING': ['ON_BICYCLE', 'CYCLING', 'BICYCLE'],
        'WALKING': ['ON_FOOT', 'WALKING', 'WALKING_NORDIC', 'WALK'],
        'HIKING': ['HIKING'],
        'RUNNING': ['RUNNING'],
        'BUS': ['IN_BUS'],
        'SUBWAY': ['IN_SUBWAY'],
        'TRAIN': ['IN_TRAIN'],
        'TRAM': ['IN_TRAM'],
        'FERRY': ['IN_FERRY'],
        'STATIONARY': ['STILL'],
        'FLYING': ['FLYING'],
        'CABLECAR': ['IN_CABLECAR'],
        'FUNICULAR': ['IN_FUNICULAR'],
        'GONDOLA_LIFT': ['IN_GONDOLA_LIFT'],
        'WHEELCHAIR': ['IN_WHEELCHAIR'],
        'SNOWMOBILE': ['SNOWMOBILE'],
        'BOATING': ['BOATING'],
        'CATCHING_POKEMON': ['CATCHING_POKEMON'],
        'HORSEBACK_RIDING': ['HORSEBACK_RIDING'],
        'KAYAKING': ['KAYAKING'],
        'KITESURFING': ['KITESURFING'],
        'PARAGLIDING': ['PARAGLIDING'],
        'ROWING': ['ROWING'],
        'SAILING': ['SAILING'],
        'SKATEBOARDING': ['SKATEBOARDING'],
        'SKATING': ['SKATING'],
        'SKIING': ['SKIING'],
        'SLEDDING': ['SLEDDING'],
        'SNOWBOARDING': ['SNOWBOARDING'],
        'SNOWSHOEING': ['SNOWSHOEING'],
        'SURFING': ['SURFING'],
        'SWIMMING': ['SWIMMING'],
        'UNKNOWN': ['UNKNOWN', 'UNKNOWN_ACTIVITY_TYPE', 'TILTING']
    };

    // Reverse mapping for easy lookup: RawType -> GroupName
    const rawToGroupMapping = {};
    for (const groupName in activityGroupMapping) {
        activityGroupMapping[groupName].forEach(rawType => {
            rawToGroupMapping[rawType] = groupName;
        });
    }
    // Function to get the grouped activity type from a raw type
    function getGroupedActivityType(rawType) {
        return rawToGroupMapping[rawType] || 'UNKNOWN'; // Default to UNKNOWN if not found
    }

    // --- Place Type to Color/Icon Mapping (for sidebar) ---
    const placeTypeStyles = {
        'restaurant': { color: '#FFA500', icon: 'üçΩÔ∏è' }, // Orange
        'cafe': { color: '#D2691E', icon: '‚òï' }, // Chocolate
        'bar': { color: '#FF4500', icon: 'üçπ' }, // OrangeRed
        'store': { color: '#4682B4', icon: 'üõçÔ∏è' }, // SteelBlue
        'grocery_or_supermarket': { color: '#32CD32', icon: 'üõí' }, // LimeGreen
        'park': { color: '#228B22', icon: 'üå≥' }, // ForestGreen
        'lodging': { color: '#800080', icon: 'üè®' }, // Purple (Hotel)
        'transit_station': { color: '#A9A9A9', icon: 'üöâ' }, // DarkGray
        // Add more types as needed
        'default': { color: '#707070', icon: 'üìç' } // Default
    };

    function getPlaceStyle(placeTypes) {
        if (placeTypes && placeTypes.length > 0) {
            for (const type of placeTypes) {
                if (placeTypeStyles[type]) {
                    return placeTypeStyles[type];
                }
            }
        }
        return placeTypeStyles['default'];
    }

    // --- Map Initialization ---
    let AdvancedMarkerElement;
    let Place;
    let GoogleMap; // Renamed to avoid conflict with built-in Map

    async function initMap() {
        try {
            // First import the maps library
            const { Map } = await google.maps.importLibrary("maps");
            const {ColorScheme} = await google.maps.importLibrary("core")
            GoogleMap = Map;
            map = new GoogleMap(document.getElementById('map'), {
                center: { lat: 25.034170, lng: 121.564560 },
                zoom: 12,
                mapId: "TIMELINE_MAP",
                colorScheme: ColorScheme.FOLLOW_SYSTEM,
                zoomControl: true,
                mapTypeControl: true,
                streetViewControl: true,
                fullscreenControl: true,
                cameraControl: false
            });

            // Then import other libraries we need
            const markerModule = await google.maps.importLibrary("marker");
            AdvancedMarkerElement = markerModule.AdvancedMarkerElement;

            const placesModule = await google.maps.importLibrary("places");
            Place = placesModule.Place;

            console.log("Map and libraries loaded successfully");
        } catch (error) {
            console.error("Error initializing map libraries:", error);
            // Check if the error is due to API key issues specifically
            if (error.message && (error.message.includes("ApiNotActivatedMapError") || error.message.includes("InvalidKeyMapError") || error.message.includes("ProjectNotLinkedToBillingError") )) {
                alert("Failed to load Google Maps: API Key issue. Please check your API key, ensure the Maps JavaScript API is enabled, and that your project is linked to a billing account.");
            } else {
                alert("Failed to load Google Maps libraries. Please check your internet connection and API key settings.");
            }
        }
    }
    function initCurrentLocationButton() {
        const locationButton = document.getElementById('currentLocationBtn');
        locationButton.addEventListener('click', () => {
            if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(
                    (position) => {
                        const pos = {
                            lat: position.coords.latitude,
                            lng: position.coords.longitude,
                        };
                        map.setCenter(pos);
                        map.setZoom(15);
                        // Optional: Add a temporary marker for the current location
                        new AdvancedMarkerElement({
                            map: map,
                            position: pos,
                            title: "Your Location",
                        });
                    },
                    () => {
                        alert("Error: The Geolocation service failed.");
                    }
                );
            } else {
                alert("Error: Your browser doesn't support geolocation.");
            }
        });
    }

    // --- UI Helper Functions ---

    // Get appropriate emoji icon for an activity type (uses grouped type)
    function getActivityIcon(activityType) {
        let group = (activityType in activityGroupMapping) ? activityType : getGroupedActivityType(activityType);
        switch (group) {
            case 'DRIVING': return 'üöó';
            case 'TAXI': return 'üöï';
            case 'MOTORCYCLING': return 'üèçÔ∏è';
            case 'CYCLING': return 'üö¥';
            case 'WALKING': return 'üö∂';
            case 'RUNNING': return 'üèÉ';
            case 'HIKING': return 'ü•æ';
            case 'BUS': return 'üöå';
            case 'SUBWAY': return 'üöá';
            case 'TRAIN': return 'üöÜ';
            case 'TRAM': return 'üöä';
            case 'FERRY': return '‚õ¥Ô∏è';
            case 'STATIONARY': return 'üõë';
            case 'FLYING': return '‚úàÔ∏è';
            case 'CABLECAR': return 'üö†';
            case 'FUNICULAR': return 'üöû';
            case 'GONDOLA_LIFT': return 'üö°';
            case 'WHEELCHAIR': return '‚ôø';
            case 'SNOWMOBILE': return 'üöú'; // Using tractor as placeholder
            case 'BOATING': return 'üö§';
            case 'CATCHING_POKEMON': return 'üëæ'; // Using alien monster
            case 'HORSEBACK_RIDING': return 'üêé';
            case 'KAYAKING': return 'üõ∂';
            case 'KITESURFING': return 'ü™Å'; // Using kite as placeholder
            case 'PARAGLIDING': return 'ü™Ç';
            case 'ROWING': return 'üö£';
            case 'SAILING': return '‚õµ';
            case 'SKATEBOARDING': return 'üõπ';
            case 'SKATING': return '‚õ∏Ô∏è';
            case 'SKIING': return '‚õ∑Ô∏è';
            case 'SLEDDING': return 'üõ∑';
            case 'SNOWBOARDING': return 'üèÇ';
            case 'SNOWSHOEING': return '‚ùÑÔ∏è'; // Using snowflake
            case 'SURFING': return 'üèÑ';
            case 'SWIMMING': return 'üèä';
            case 'UNKNOWN':
                switch (activityType) { case 'TILTING': return 'üì±'; default: return '‚ùì'; }
            default: return '‚ùì';
        }
    }

    // Get color associated with an activity type (uses grouped type)
    function getActivityColor(activityType) {
        const group = getGroupedActivityType(activityType);
        switch (group) {
            case 'DRIVING': return '#4285F4'; // Google Blue
            case 'TAXI': return '#FFEB3B'; // Yellow
            case 'MOTORCYCLING': return '#1E90FF'; // Dodger Blue
            case 'CYCLING': return '#0F9D58'; // Google Green
            case 'WALKING': return '#DB4437'; // Google Red
            case 'RUNNING': return '#DB4437'; // Google Red
            case 'HIKING': return '#0F9D58'; // Google Green (for nature)
            case 'BUS': return '#9C27B0'; // Purple
            case 'SUBWAY': case 'TRAIN': case 'TRAM': case 'FERRY': return '#673AB7'; // Deep Purple
            case 'STATIONARY': return '#757575'; // Grey
            case 'FLYING': return '#03A9F4'; // Light Blue
            case 'CABLECAR': case 'FUNICULAR': case 'GONDOLA_LIFT': case 'WHEELCHAIR': return '#607D8B'; // Blue Grey
            case 'BOATING': case 'KAYAKING': case 'ROWING': case 'SAILING': case 'SURFING': case 'SWIMMING': return '#00BCD4'; // Cyan
            case 'CATCHING_POKEMON': return '#FFEB3B'; // Yellow
            case 'HORSEBACK_RIDING': return '#795548'; // Brown
            case 'KITESURFING': case 'PARAGLIDING': return '#87CEEB'; // Sky Blue
            case 'SKATEBOARDING': case 'SKATING': return '#FF9800'; // Orange
            case 'SKIING': case 'SLEDDING': case 'SNOWBOARDING': case 'SNOWSHOEING': case 'SNOWMOBILE': return '#B0E0E6'; // Powder Blue
            case 'UNKNOWN': default: return '#9E9E9E'; // Darker Grey
        }
    }

    // Format activity type name for display (uses grouped type where appropriate)
    function formatActivityType(activityType) {
        // Fallback to specific formatting for raw types
        switch (activityType) {
            case 'IN_VEHICLE': case 'DRIVE': return 'Driving';
            case 'IN_PASSENGER_VEHICLE': return 'In a Vehicle';
            case 'IN_TAXI': return 'In a Taxi';
            case 'MOTORCYCLING': return 'Motorcycling';
            case 'ON_BICYCLE': case 'CYCLING': case 'BICYCLE': return 'Biking';
            case 'ON_FOOT': case 'WALKING': case 'WALK': return 'Walking';
            case 'WALKING_NORDIC': return 'Nordic Walking';
            case 'HIKING': return 'Hiking';
            case 'RUNNING': return 'Running';
            case 'IN_BUS': return 'On a Bus';
            case 'IN_SUBWAY': return 'On the Subway';
            case 'IN_TRAIN': return 'On a Train';
            case 'IN_TRAM': return 'On a Tram';
            case 'IN_FERRY': return 'On a Ferry';
            case 'STILL': return 'Stationary';
            case 'FLYING': return 'On a Plane';
            case 'IN_CABLECAR': return 'On a Cable Car';
            case 'IN_FUNICULAR': return 'On a Funicular';
            case 'IN_GONDOLA_LIFT': return 'On a Gondola';
            case 'IN_WHEELCHAIR': return 'In a Wheelchair';
            case 'SNOWMOBILE': return 'On a Snowmobile';
            case 'BOATING': return 'Boating';
            case 'CATCHING_POKEMON': return 'Catching Pok√©mon';
            case 'HORSEBACK_RIDING': return 'Horseback Riding';
            case 'KAYAKING': return 'Kayaking';
            case 'KITESURFING': return 'Kitesurfing';
            case 'PARAGLIDING': return 'Paragliding';
            case 'ROWING': return 'Rowing';
            case 'SAILING': return 'Sailing';
            case 'SKATEBOARDING': return 'Skateboarding';
            case 'SKATING': return 'Skating';
            case 'SKIING': return 'Skiing';
            case 'SLEDDING': return 'Sledding';
            case 'SNOWBOARDING': return 'Snowboarding';
            case 'SNOWSHOEING': return 'Snowshoeing';
            case 'SURFING': return 'Surfing';
            case 'SWIMMING': return 'Swimming';
            case 'UNKNOWN': case 'UNKNOWN_ACTIVITY_TYPE': return 'Unknown Activity';
            case 'TILTING': return 'Device Tilt';
            default:
                const group = getGroupedActivityType(activityType);
                // Use group name if it's not UNKNOWN
                if (group !== 'UNKNOWN' && group !== activityType) {
                    return group.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                }else{
                    return activityType ? activityType.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase()) : 'Unknown Activity';
                }
        }
    }

    function showSidebarTab(tabName) {
        // Tab content
        const dateView = document.getElementById('dateView');
        const areaView = document.getElementById('areaView');
        const searchView = document.getElementById('searchView');
        const settingsView = document.getElementById('settingsView');
        // Tab buttons
        const calendarBtn = document.getElementById('calendarBtn');
        const areaBtn = document.getElementById('areaBtn');
        const searchBtn = document.getElementById('searchBtn');
        const settingsBtn = document.getElementById('settingsBtn');

        // Hide all tab content
        dateView.style.display = 'none';
        areaView.style.display = 'none';
        searchView.style.display = 'none';
        settingsView.style.display = 'none';

        // Deactivate all tab buttons
        calendarBtn.classList.remove('active');
        areaBtn.classList.remove('active');
        searchBtn.classList.remove('active');
        settingsBtn.classList.remove('active');

        // Show the selected tab and activate its button
        if (tabName === 'date') {
            dateView.style.display = 'flex';
            calendarBtn.classList.add('active');
            // When switching to date view, re-fit the map to that day's data
            fitMapToData();
        } else if (tabName === 'area') {
            areaView.style.display = 'flex';
            areaBtn.classList.add('active');
            // If we have previous area results, restore them using the stored mode
            if (lastAreaSearchResults.length > 0) {
                const isConsolidated = lastAreaSearchMode === 'consolidated';
                displayAreaResults(lastAreaSearchResults, isConsolidated);
                // Also restore the UI state (hide options, show "New Search" button)
                document.getElementById('area-options-container').style.display = 'none';
                document.getElementById('findInAreaBtn').style.display = 'none';
                document.getElementById('newAreaSearchBtn').style.display = 'flex';
            }
        } else if (tabName === 'search') {
            searchView.style.display = 'flex';
            searchBtn.classList.add('active');
            document.getElementById('searchInput').focus();
        } else if (tabName === 'settings') {
            settingsView.style.display = 'flex';
            settingsBtn.classList.add('active');
        }
    }


    // --- Timezone & Distance Helpers ---
    function getSelectedTimezone() {
        return displayTimezone === 'default' ? moment.tz.guess() : displayTimezone;
    }

    function formatTimestamp(timestamp, formatString) {
        const tz = getSelectedTimezone();
        return moment(timestamp).tz(tz).format(formatString);
    }

    function formatDistance(meters) {
        const M_TO_MI = 0.000621371;
        if (distanceUnit === 'mi') {
            const miles = meters * M_TO_MI;
            return `${miles.toLocaleString(undefined, { minimumFractionDigits: 1, maximumFractionDigits: 1 })} mi`;
        } else { // Default to km
            const kilometers = meters / 1000;
            return `${kilometers.toLocaleString(undefined, { minimumFractionDigits: 1, maximumFractionDigits: 1 })} km`;
        }
    }

    // Debounce function to limit API calls
    function debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
            const later = () => {
                clearTimeout(timeout);
                func(...args);
            };
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
        };
    }

    // --- API Call Counter ---
    function incrementApiCallCount() {
        placeApiCallCount++;
        updateApiCallDisplay();
        // Enable save button if this is the first API call and the UI is active
        if (placeApiCallCount > 0 && uiEnabled) {
            document.getElementById('saveCacheBtn').disabled = false;
        }
    }

    function updateApiCallDisplay() {
        const counterElement = document.getElementById('api-call-counter');
        if (counterElement) {
            counterElement.textContent = `API Calls: ${placeApiCallCount}`;
        }
    }

    function updateCacheIndicator() {
        const indicator = document.getElementById('cache-indicator');
        if (Object.keys(timelineData).length === 0) {
            indicator.style.display = 'none';
            return;
        }
        const currentCacheSize = Object.keys(placeDetailsCache).length;
        const newCount = Math.max(0, currentCacheSize - initialCacheSizeFromFile);
        document.getElementById('saved-cache-count').textContent = initialCacheSizeFromFile;
        document.getElementById('new-cache-count').textContent = newCount;
        indicator.style.display = 'flex';
    }


    // --- Timeline Rendering ---

    // Creates a single timeline item element for the sidebar
    function createTimelineItem(item, index, currentDate) {
        const timelineItem = document.createElement('div');
        timelineItem.className = 'timeline-item';
        timelineItem.dataset.index = index; // Use the global index
        // --- DEBUG START: Add raw data ---
        /*try {
                // Select the relevant part of the item (visit or activity)
                const rawData = item;
                const jsonString = JSON.stringify(rawData);
                timelineItem.dataset.rawJson = escapeHtml(jsonString); // Add as data attribute
            } catch (e) {
                console.error("Error stringifying or escaping raw data for item:", item, e);
                timelineItem.dataset.rawJson = escapeHtml('{"error": "Could not serialize data"}'); // Add error indicator
            }*/
        // --- DEBUG END: Add raw data ---

        // Check if a date header needs to be added for this date
        const existingHeader = document.querySelector(`.date-header[data-date="${currentDate}"]`);
        if (!existingHeader) {
            const dateHeader = document.createElement('div');
            dateHeader.className = 'date-header';
            dateHeader.dataset.date = currentDate;
            dateHeader.textContent = formatTimestamp(currentDate, 'dddd, MMMM DD, YYYY');
            const timelineContainer = document.getElementById('timeline');
            timelineContainer.appendChild(dateHeader);
        }

        let startTimestamp, endTimestamp;
        let locationName = 'Unknown Location'; // Default name
        let placeTypesForStyle = []; // For sidebar icon styling

        if (item.visit || item.placeVisit) { // Combined logic for both visit types
            const isIOS = !!item.visit;
            const visitData = isIOS ? item.visit : item.placeVisit;
            const locationData = isIOS ? visitData.topCandidate : visitData.location;

            startTimestamp = isIOS ? item.startTime : visitData.duration.startTimestamp;
            endTimestamp = isIOS ? item.endTime : visitData.duration.endTimestamp;

            const semanticType = (isIOS ? locationData?.semanticType : locationData.semanticType)?.toUpperCase();
            if (semanticType === "HOME" || semanticType === "TYPE_HOME") {
                locationName = "Home";
            } else if (semanticType === "WORK" || semanticType === "TYPE_WORK") {
                locationName = "Work";
            } else {
                locationName = locationData?.name || 'Unknown Location';
            }

            placeTypesForStyle = locationData.placeTypes || [];
            const placeId = isIOS ? locationData?.placeID : locationData.placeId;

            // Add data attributes for later finding/scrolling
            if (placeId) {
                timelineItem.dataset.placeId = placeId;
            }
            timelineItem.dataset.startTimestamp = startTimestamp;


            const placeStyle = getPlaceStyle(placeTypesForStyle);
            timelineItem.classList.add('place-visit-item');
            timelineItem.innerHTML = `
                <span class="timeline-icon-container" style="border-color: ${placeStyle.color};">${placeStyle.icon}</span>
                <div class="timeline-item-details">
                    <strong class="nametag">${locationName}</strong><br>
                    <span class="timeline-item-time">${formatTimestamp(startTimestamp, 'hh:mm A')} - ${formatTimestamp(endTimestamp, 'hh:mm A')}</span>
                </div>
            `;
            timelineItem.style.setProperty('--activity-color', placeStyle.color);

        } else if (item.activitySegment) { // Handle 'activitySegment' (standard and transformed iOS)
            const activitySegment = item.activitySegment;
            startTimestamp = activitySegment.duration.startTimestamp;
            endTimestamp = activitySegment.duration.endTimestamp;
            const distanceMeters = activitySegment.distance || (activitySegment.simplifiedRawPath && activitySegment.simplifiedRawPath.distanceMeters) || (activitySegment.waypointPath && activitySegment.waypointPath.distanceMeters) || 0;
            const activityType = activitySegment.activityType || (activitySegment.activities && activitySegment.activities[0]?.activityType) || (activitySegment.waypointPath && activitySegment.waypointPath.travelMode) || 'UNKNOWN';
            const formattedType = formatActivityType(activityType);
            const activityColor = getActivityColor(activityType);
            timelineItem.innerHTML = `
                <span class="timeline-icon-container" style="border-color: ${activityColor};">${getActivityIcon(activityType)}</span>
                <div class="timeline-item-details">
                    <strong>${formattedType}</strong><br>
                    <span class="timeline-item-time">${formatTimestamp(startTimestamp, 'hh:mm A')} - ${formatTimestamp(endTimestamp, 'hh:mm A')}</span>
                    <span class="distance">Distance: ${formatDistance(distanceMeters)}</span>
                </div>
            `;
            timelineItem.style.setProperty('--activity-color', activityColor);
        }

        // Store timestamps and date context on the element
        timelineItem.dataset.startTimestamp = startTimestamp;
        timelineItem.dataset.endTimestamp = endTimestamp;
        timelineItem.dataset.itemDate = currentDate;

        // Add confirmed checkmark if applicable
        if ((item.placeVisit && item.placeVisit.editConfirmationStatus === "CONFIRMED") ||
            (item.activitySegment && item.activitySegment.editConfirmationStatus === "CONFIRMED") ||
            (item.visit && item.visit.editConfirmationStatus === "CONFIRMED")) {
            const checkmark = document.createElement('span');
            checkmark.className = 'confirmed-checkmark';
            checkmark.textContent = '‚úîÔ∏è';
            timelineItem.appendChild(checkmark);
        }

        return timelineItem;
    }


    // Finds a specific timeline item by its placeId and start time, then highlights and scrolls to it.
    function findAndHighlightTimelineItem(placeId, startTimestamp) {
        if (!placeId || !startTimestamp) return;

        const timelineItems = document.querySelectorAll('#timeline .timeline-item');
        let targetItem = null;

        for (const item of timelineItems) {
            if (item.dataset.placeId === placeId && item.dataset.startTimestamp === startTimestamp) {
                targetItem = item;
                break;
            }
        }

        if (targetItem) {
            console.log("Found timeline item to highlight:", targetItem);
            highlightSidebarItem(targetItem.dataset.index);
        } else {
            console.warn("Could not find matching timeline item to highlight.", { placeId, startTimestamp });
        }
    }


    // Clears the timeline sidebar
    function clearTimeline() {
        document.getElementById('timeline').innerHTML = '';
    }

    // --- Map Rendering ---

    // Clears all markers, polylines, and info windows from the map
    function clearMap() {
        markers.forEach(marker => marker.map = null);
        markers = [];
        polylines.forEach(polyline => polyline.setMap(null));
        polylines = [];
        infoWindows.forEach(infoWindow => infoWindow.close());
        infoWindows = [];
        deselectPolyline(); // Also deselect any highlighted polyline
    }

    // Helper to parse "geo:lat,lng" strings
    function parseGeoString(geoStr) {
        if (typeof geoStr === 'string' && geoStr.startsWith('geo:')) {
            const parts = geoStr.substring(4).split(',');
            if (parts.length === 2) {
                const lat = parseFloat(parts[0]);
                const lng = parseFloat(parts[1]);
                if (!isNaN(lat) && !isNaN(lng)) {
                    return { lat, lng };
                }
            }
        }
        return null;
    }

    // Renders a place visit marker (handles both standard and iOS formats)
    function renderPlaceVisit(itemData, index, sidebarItem = null) {
        let locationName, placeId, lat, lng, startTimestamp, endTimestamp, originalVisitData, semanticTypeStr;

        // Adapt based on data structure (standard vs. iOS)
        if (itemData.placeVisit) { // Standard format
            const placeVisit = itemData.placeVisit;
            semanticTypeStr = placeVisit.location.semanticType; // e.g., "TYPE_HOME"
            if (semanticTypeStr === "TYPE_HOME" || placeVisit.location.name?.toLowerCase() === "home") {
                locationName = "Home";
            } else if (semanticTypeStr === "TYPE_WORK" || placeVisit.location.name?.toLowerCase() === "work") {
                locationName = "Work";
            } else {
                locationName = placeVisit.location.name;
            }
            placeId = placeVisit.location.placeId;
            lat = placeVisit.location.latitudeE7 / 1e7;
            lng = placeVisit.location.longitudeE7 / 1e7;
            startTimestamp = placeVisit.duration.startTimestamp;
            endTimestamp = placeVisit.duration.endTimestamp;
            originalVisitData = placeVisit;
        } else if (itemData.visit) { // iOS format (itemData is the raw timeline object)
            const visit = itemData.visit; // The 'visit' sub-object
            semanticTypeStr = visit.topCandidate?.semanticType; // e.g., "Home", "Work"
            if (semanticTypeStr?.toUpperCase() === "HOME") {
                locationName = "Home";
            } else if (semanticTypeStr?.toUpperCase() === "WORK") {
                locationName = "Work";
            } else {
                locationName = visit.topCandidate?.name || visit.topCandidate?.semanticType;
            }
            placeId = visit.topCandidate?.placeID;

            const geoCoords = parseGeoString(visit.topCandidate?.placeLocation);
            if (geoCoords) {
                lat = geoCoords.lat;
                lng = geoCoords.lng;
            } else if (visit.location?.latitudeE7 && visit.location?.longitudeE7) { // Fallback if geo: parsing fails or not present
                lat = visit.location.latitudeE7 / 1e7;
                lng = visit.location.longitudeE7 / 1e7;
            } else if (visit.centerLatE7 && visit.centerLngE7) { // Another fallback
                lat = visit.centerLatE7 / 1e7;
                lng = visit.centerLngE7 / 1e7;
            }

            startTimestamp = itemData.startTime;
            endTimestamp = itemData.endTime;
            // Create a pseudo-standard structure for consistency downstream
            originalVisitData = {
                location: {
                    name: locationName,
                    placeId: placeId,
                    latitudeE7: lat ? lat * 1e7 : undefined,
                    longitudeE7: lng ? lng * 1e7 : undefined,
                    semanticType: semanticTypeStr // Store the original semantic type
                },
                duration: { startTimestamp: startTimestamp, endTimestamp: endTimestamp }
            };
        } else {
            console.warn("Unrecognized place visit structure:", itemData);
            return;
        }

        const fallbackName = locationName || (lat && lng ? `Location (${lat.toFixed(4)}, ${lng.toFixed(4)})` : 'Unknown Location');

        // Attempt to fetch Place Details if placeId exists and not cached
        if (placeId && !isNaN(lat) && !isNaN(lng)) {
            if (placeDetailsCache[placeId]) {
                // Use cached details
                console.log(`Using cached details for placeId: ${placeId}`);
                renderPlaceDetails(placeDetailsCache[placeId], originalVisitData, index, sidebarItem);
            } else if (apiCallsDisabled) {
                console.log(`API calls disabled. Rendering basic marker for placeId: ${placeId}`);
                renderBasicMarker(lat, lng, fallbackName, originalVisitData, index);
                updateSidebarItem(index, fallbackName, null); // Update sidebar with basic info
            } else {
                // Fetch details using the new API
                console.log(`Fetching details for placeId: ${placeId}`);
                fetchPlaceDetails(placeId, fallbackName, originalVisitData, index, sidebarItem);
            }
        } else if (!isNaN(lat) && !isNaN(lng)) {
            // No placeId or invalid coords, render a basic marker immediately
            console.log(`Rendering basic marker for: ${fallbackName}`);
            renderBasicMarker(lat, lng, fallbackName, originalVisitData, index);
            // Update sidebar with basic info
            updateSidebarItem(index, fallbackName, null, []);
        } else {
            console.warn(`Skipping marker render due to invalid coordinates for: ${fallbackName}`);
        }
    }


    // Renders a simple marker when no Place ID is available or fetch fails
    function renderBasicMarker(lat, lng, name, placeVisit, index) {
        const position = { lat, lng };

        // Check if marker library is loaded
        if (!google.maps.marker || !google.maps.marker.AdvancedMarkerElement) {
            console.error("AdvancedMarkerElement class not loaded.");
            return;
        }

        // Create a basic PinElement for a more consistent look with other markers
        const PinElement = google.maps.marker.PinElement;
        let markerContent = null;
        if (PinElement) {
            try {
                const pinElement = new PinElement({
                    background: '#FF0000', // Red for generic
                    borderColor: '#A00000',
                    glyph: '', // No glyph for basic
                    scale: 0.8 // Slightly smaller
                });
                markerContent = pinElement.element;
            } catch(e) {
                console.warn("Could not create PinElement for basic marker, using default.", e);
            }
        }

        const marker = new AdvancedMarkerElement({
            position: position,
            map: map,
            title: name,
            content: markerContent // Use PinElement or default if null
        });
        markers.push(marker);

        // Create InfoWindow content (without photo initially)
        const infoWindowContent = `
                          <div style="max-width: 250px;">
                               <h3 style="margin: 5px 0;">${name}</h3>
                               <p style="margin: 3px 0; font-size: 0.9em;">Lat: ${lat.toFixed(6)}, Lng: ${lng.toFixed(6)}</p>
                               <div class="photo-container" data-place-id="basic-${index}">
                                     <div class="photo-placeholder">No photo available</div>
                               </div>
                               <p style="margin: 5px 0; font-size: 0.85em;">${formatTimestamp(placeVisit.duration.startTimestamp, "MMM DD, YYYY hh:mm A")} - ${formatTimestamp(placeVisit.duration.endTimestamp, "hh:mm A")}</p>
                         <p style="margin-top: 5px; font-size: 0.85em;"><a href="https://maps.google.com/?q=${lat},${lng}" target="_blank">View on Google Maps</a></p>
                          </div>`;

        const infoWindow = new google.maps.InfoWindow({ content: infoWindowContent });
        infoWindow.placeId = null; // No place ID for basic marker
        infoWindow.photoFetched = true; // Mark as "fetched" since there's no photo to fetch
        infoWindows.push(infoWindow);

        // Add listeners
        const sidebarItem = document.querySelector(`.timeline-item[data-index="${index}"]`);
        addMarkerClickListener(marker, infoWindow, index);
        if (sidebarItem) {
            addSidebarItemClickListener(sidebarItem, index, marker, infoWindow);
        }
    }

    // Fetches place details using the new Place.fetchFields method
    async function fetchPlaceDetails(placeId, fallbackName, placeVisit, index, sidebarItem = null) {
        if (apiCallsDisabled) {
            console.log("API calls disabled. Skipping fetchPlaceDetails, rendering basic marker.");
            const lat = placeVisit.location.latitudeE7 / 1e7;
            const lng = placeVisit.location.longitudeE7 / 1e7;
            renderBasicMarker(lat, lng, fallbackName, placeVisit, index);
            updateSidebarItem(index, fallbackName, null, []);
            return;
        }

        // Define the fields to fetch (excluding 'photos')
        const fields = [
            'id',               // Basic identifier
            'displayName',      // New name field
            'formattedAddress',   // New address field
            'location',           // New geometry field (lat/lng)
            'svgIconMaskURI',     // New icon URL field
            'iconBackgroundColor', // New icon background color field
            'googleMapsURI',
            'types'
        ];

        try {
            const place = new Place({ id: placeId }); // , requestedLanguage: "en"
            await place.fetchFields({ fields: fields });
            incrementApiCallCount();

            placeDetailsCache[placeId] = place;
            updateCacheIndicator();
            renderPlaceDetails(place, placeVisit, index, sidebarItem);

        } catch (error) {
            console.warn(`Error fetching place details with fetchFields for placeId ${placeId}:`, error);
            // Fallback to basic marker if details fetch fails
            const lat = placeVisit.location.latitudeE7 / 1e7;
            const lng = placeVisit.location.longitudeE7 / 1e7;
            renderBasicMarker(lat, lng, fallbackName, placeVisit, index);
            // Note: sidebarItem is likely null here if called from date view, so we still need the original updateSidebarItem as a fallback.
            if (sidebarItem) {
                const nametag = sidebarItem.querySelector('strong');
                if (nametag) nametag.textContent = fallbackName;
            } else {
                updateSidebarItem(index, fallbackName, null, []);
            }
        }
    }


    /**
     * Reliably finds a sidebar item by its index (in any tab) and updates its
     * name and icon based on fetched data.
     * @param {number} index - The unique index of the item.
     * @param {string} locationName - The new name for the location.
     * @param {string|null} svgIconMaskURI - The URI for the Google icon.
     * @param {Array<string>} placeTypes - Array of place types for styling.
     */
    function updateSidebarItem(index, locationName, svgIconMaskURI, placeTypes = []) {
        // This querySelector works globally, finding the item whether it's
        // in the #timeline or the #areaResults container.
        const sidebarItem = document.querySelector(`.timeline-item[data-index="${index}"]`);

        if (!sidebarItem) {
            // This can happen if the user switches views while data is loading. It's not a critical error.
            console.warn(`updateSidebarItem: Could not find sidebar item with index ${index}.`);
            return;
        }

        // Update the name tag
        const nametag = sidebarItem.querySelector('strong');
        if (nametag) {
            nametag.textContent = locationName;
        }

        // Update the icon
        const iconContainer = sidebarItem.querySelector('.timeline-icon-container');
        if (iconContainer) {
            const placeStyle = getPlaceStyle(placeTypes);
            let finalIconHtml;

            // Prefer Google's icon from the API if it's available and not generic
            if (svgIconMaskURI && !svgIconMaskURI.includes('generic')) {
                finalIconHtml = `<span class="timeline-icon-svg" style="mask: url('${svgIconMaskURI}') no-repeat center / contain; -webkit-mask: url('${svgIconMaskURI}') no-repeat center / contain; background-color: ${placeStyle.color};"></span>`;
            } else {
                // Fallback to type-based emoji and color
                finalIconHtml = placeStyle.icon;
            }

            iconContainer.innerHTML = finalIconHtml;
            // Also update the left border color for activity segments
            sidebarItem.style.setProperty('--activity-color', placeStyle.color);
        }
    }

    // Renders the marker and InfoWindow using fetched Place Details (new API)
    async function renderPlaceDetails(place, placeVisit, index, sidebarItem = null) {
        // Determine the display name, prioritizing "Home" or "Work" if applicable
        let displayName = place.displayName;
        const originalSemanticType = placeVisit.location.semanticType; // From original data (e.g., TYPE_HOME or "Home")
        if (originalSemanticType) {
            const upperSemanticType = originalSemanticType.toUpperCase();
            if (upperSemanticType === "HOME" || upperSemanticType === "TYPE_HOME") {
                displayName = "Home";
            } else if (upperSemanticType === "WORK" || upperSemanticType === "TYPE_WORK") {
                displayName = "Work";
            }
        }
        const locationName = displayName || placeVisit.location.name || 'Unknown Location';
        const position = place.location;
        const placeId = place.id; // Use place.id

        // Find the sidebar item to update, preferring the directly passed element from Area View.
        const itemToUpdate = sidebarItem || document.querySelector(`.timeline-item[data-index="${index}"]`);

        // Update the item's name and icon now that we have the fetched details.
        if (itemToUpdate) {
            // This logic is moved from the `updateSidebarItem` function for a direct, reliable update.
            const nametag = itemToUpdate.querySelector('strong');
            if (nametag) {
                nametag.textContent = locationName;
            }

            const iconContainer = itemToUpdate.querySelector('.timeline-icon-container');
            if (iconContainer) {
                const placeStyle = getPlaceStyle(place.types || []);
                let finalIconHtml;

                if (place.svgIconMaskURI && !place.svgIconMaskURI.includes('generic')) {
                    finalIconHtml = `<span class="timeline-icon-svg" style="mask: url('${place.svgIconMaskURI}') no-repeat center / contain; -webkit-mask: url('${place.svgIconMaskURI}') no-repeat center / contain; background-color: ${placeStyle.color};"></span>`;
                } else {
                    finalIconHtml = placeStyle.icon;
                }

                iconContainer.innerHTML = finalIconHtml;
                itemToUpdate.style.setProperty('--activity-color', placeStyle.color);
            }
        }

        // --- Create Marker ---
        const PinElement = google.maps.marker.PinElement;
        if (!AdvancedMarkerElement || !PinElement) {
            console.error("Marker library classes (AdvancedMarkerElement, PinElement) not loaded.");
            return;
        }

        let markerContent;
        // Use PinElement if icon data is available
        if (place.svgIconMaskURI && !place.svgIconMaskURI.includes('generic') && place.iconBackgroundColor) {
            try {
                const pinGlyph = document.createElement('img');
                pinGlyph.src = place.svgIconMaskURI;
                pinGlyph.style.width = '18px';
                pinGlyph.style.height = '18px';
                //pinGlyph.style.filter = 'invert(100%) sepia(0%) saturate(0%) hue-rotate(0deg) brightness(200%) contrast(100%)'; // Make glyph white

                const pinElement = new PinElement({
                    background: place.iconBackgroundColor,
                    glyph: pinGlyph, // Use the img element as glyph
                    glyphColor: '#FFFFFF', // Glyph color might not be needed if using image
                    borderColor: '#505050', // Example border color
                    scale: 1.0
                });
                markerContent = pinElement.element;
            } catch (e) {
                console.warn("Could not create PinElement with image glyph, using default marker:", e);
                // Fallback: create a simpler PinElement without glyph if image fails
                const fallbackPin = new PinElement({ background: place.iconBackgroundColor || '#4285F4', scale: 0.8 });
                markerContent = fallbackPin.element;
            }
        } else {
            // Fallback if no icon URI or background color - use a generic colored pin
            const fallbackPin = new PinElement({ background: '#ce5140', scale: 0.9 }); // Default
            markerContent = fallbackPin.element;
        }

        // Create the Advanced Marker
        const marker = new AdvancedMarkerElement({
            position: position,
            map: map,
            content: markerContent, // Use PinElement if created, otherwise default
            title: locationName,
        });
        markers.push(marker);

        // --- Prepare InfoWindow content ---
        let mapsLink;
        try {
            if (place.googleMapsURI) {
                mapsLink = `<a href="${place.googleMapsURI}" target="_blank">View on Google Maps</a>`;
            } else if (position && typeof position.lat === 'function' && typeof position.lng === 'function') {
                mapsLink = `<a href="https://maps.google.com/?q=${position.lat()},${position.lng()}" target="_blank">View on Google Maps</a>`;
            } else if (position && 'lat' in position && 'lng' in position) {
                mapsLink = `<a href="https://maps.google.com/?q=${position.lat},${position.lng}" target="_blank">View on Google Maps</a>`;
            } else {
                throw new Error("No valid location for fallback maps link");
            }
        } catch (e) {
            console.warn("Could not create link, 1:", place);
            console.warn("Could not create link, 2:", e);
        }

        // Always start with the placeholder
        const photoHtml = `<div class="photo-placeholder">Loading photo...</div>`;


        // Use new field names in content
        const infoWindowContent = `
            <div style="max-width: 250px;">
                <h3 style="margin: 5px 0;">${locationName}</h3>
                <p style="margin: 3px 0; font-size: 0.9em;">${place.formattedAddress || ""}</p>
                <div class="photo-container" data-place-id="${placeId}">
                    ${photoHtml}
                </div>
                <p style="margin: 5px 0; font-size: 0.85em;">${formatTimestamp(placeVisit.duration.startTimestamp, "MMM DD, YYYY hh:mm A")} - ${formatTimestamp(placeVisit.duration.endTimestamp, "hh:mm A")}</p>
                <p style="margin-top: 5px; font-size: 0.85em;">${mapsLink}</p>
            </div>`;

        const infoWindow = new google.maps.InfoWindow({ content: infoWindowContent });
        infoWindow.placeId = placeId; // Store place ID
        infoWindow.photoFetched = false; // Mark photo as NOT fetched initially
        infoWindows.push(infoWindow);

        // Add listeners
        addMarkerClickListener(marker, infoWindow, index);
        if (itemToUpdate) { // Use the item we already found/updated to attach the click listener
            addSidebarItemClickListener(itemToUpdate, index, marker, infoWindow);
        }
    }


    // Renders an activity segment as a polyline on the map
    function renderActivitySegment(activitySegment, index) {
        let path = [];
        const startLat = activitySegment.startLocation?.latitudeE7 / 1e7 || activitySegment.startLocation?.lat; // Support direct lat/lng too
        const startLng = activitySegment.startLocation?.longitudeE7 / 1e7 || activitySegment.startLocation?.lng;
        const endLat = activitySegment.endLocation?.latitudeE7 / 1e7 || activitySegment.endLocation?.lat;
        const endLng = activitySegment.endLocation?.longitudeE7 / 1e7 || activitySegment.endLocation?.lng;

        // Add start point if valid
        if (!isNaN(startLat) && !isNaN(startLng)) path.push({ lat: startLat, lng: startLng });

        // Handle intermediate points from various possible path sources
        let intermediatePoints = activitySegment.simplifiedRawPath?.points ||
            activitySegment.timelinePath?.points ||
            activitySegment.waypointPath?.waypoints ||
            activitySegment.path; // For directly provided path in transformed iOS data
        if (intermediatePoints) {
            intermediatePoints.forEach(point => {
                const pLat = point.latE7 !== undefined ? point.latE7 / 1e7 : point.lat;
                const pLng = point.lngE7 !== undefined ? point.lngE7 / 1e7 : point.lng;
                if (!isNaN(pLat) && !isNaN(pLng)) path.push({ lat: pLat, lng: pLng });
            });
        }

        // Add end point if valid and different from last intermediate point
        if (!isNaN(endLat) && !isNaN(endLng)) {
            const lastPoint = path[path.length - 1];
            if (!lastPoint || lastPoint.lat !== endLat || lastPoint.lng !== endLng) {
                path.push({ lat: endLat, lng: endLng });
            }
        }

        // Only render if we have at least two points
        if (path.length < 2) {
            console.log(`Skipping polyline render for index ${index}: Not enough points (${path.length})`);
            return;
        }

        const activityType = activitySegment.activityType || (activitySegment.activities && activitySegment.activities[0]?.activityType) || (activitySegment.waypointPath && activitySegment.waypointPath.travelMode) || 'UNKNOWN';

        const polyline = new google.maps.Polyline({
            path: path,
            geodesic: true,
            strokeColor: getActivityColor(activityType),
            strokeOpacity: 0.8, // Slightly less opaque for better visibility if overlapping
            strokeWeight: 5, // Default weight
            map: map,
            clickable: true,
            zIndex: 0 // Default zIndex
        });
        polyline.set('originalColor', getActivityColor(activityType)); // Store original color
        polylines.push(polyline); // Keep track

        // Add listeners
        const sidebarItem = document.querySelector(`.timeline-item[data-index="${index}"]`);
        addPolylineClickListener(polyline, sidebarItem, path);
        if (sidebarItem) {
            addSidebarItemClickListener(sidebarItem, index, null, null, polyline, path);
        }
    }

    // --- Map Interaction ---

    // Fetches *only* the photo for an InfoWindow if not already fetched
    async function fetchPhotoForInfoWindow(infoWindow) {

        // If API calls are disabled, skip photo fetch
        if (apiCallsDisabled) {
            console.log("API calls disabled. Skipping photo fetch.");
            if (infoWindow && !infoWindow.photoFetched) { // Still update placeholder if not fetched
                try {
                    const contentNode = document.createElement('div');
                    contentNode.innerHTML = infoWindow.getContent();
                    const photoContainer = contentNode.querySelector(`.photo-container`);
                    if (photoContainer) {
                        photoContainer.innerHTML = '<div class="photo-placeholder">Photos disabled</div>';
                        infoWindow.setContent(contentNode.innerHTML);
                    }
                    infoWindow.photoFetched = true; // Mark as "fetched" (or known unavailable/disabled)
                } catch (e) { console.error("Error updating infowindow content when API disabled:", e); }
            }
            return;
        }

        // Skip if no placeId or photo already fetched/failed
        if (!infoWindow || !infoWindow.placeId || infoWindow.photoFetched) {
            console.log(`Skipping photo fetch for placeId: ${infoWindow?.placeId}. Reason: No placeId or photo already fetched/failed.`);
            // Ensure placeholder shows 'No photo available' if there's no placeId and it hasn't been marked fetched yet
            if (infoWindow && !infoWindow.placeId && !infoWindow.photoFetched) {
                try {
                    const contentNode = document.createElement('div');
                    contentNode.innerHTML = infoWindow.getContent();
                    const photoContainer = contentNode.querySelector(`.photo-container`);
                    if (photoContainer) {
                        photoContainer.innerHTML = '<div class="photo-placeholder">No photo available</div>';
                        infoWindow.setContent(contentNode.innerHTML);
                    }
                    infoWindow.photoFetched = true; // Mark as fetched (or known unavailable)
                } catch (e) { console.error("Error updating basic marker infowindow content:", e); }
            }
            return;
        }
        console.log(`Fetching photo for placeId: ${infoWindow.placeId}`);
        const fields = ['photos']; // Request only photos
        try {
            incrementApiCallCount(); // Increment counter for photo fetch
            const place = new Place({
                id: infoWindow.placeId,
                requestedLanguage: "en", // optional
            });
            await place.fetchFields({
                fields: fields
            });

            let photoHtml;
            if (place.photos && place.photos.length > 0) {
                try {
                    const photoUri = place.photos[0].getURI({ maxWidth: 200, maxHeight: 150 });
                    photoHtml = `<img src="${photoUri}" alt="Place photo">`;
                    console.log(`Photo found for ${infoWindow.placeId}`);
                } catch (e) {
                    console.warn("Error getting photo URI:", e);
                    photoHtml = '<div class="photo-placeholder">Error loading photo</div>';
                }
            } else {
                photoHtml = '<div class="photo-placeholder">No photo available</div>';
                console.log(`No photo found for ${infoWindow.placeId}`);
            }
            // Update the InfoWindow content with the photo or 'no photo' message
            const contentNode = document.createElement('div');
            // IMPORTANT: Get the *current* content in case it was closed/reopened quickly
            contentNode.innerHTML = infoWindow.getContent();
            const photoContainer = contentNode.querySelector(`.photo-container[data-place-id="${infoWindow.placeId}"]`);
            if (photoContainer) {
                photoContainer.innerHTML = photoHtml;
                // *** Crucial Step: Update the actual InfoWindow object's content ***
                infoWindow.setContent(contentNode.innerHTML);
            } else {
                console.warn("Could not find photo container in InfoWindow content for update, placeId:", infoWindow.placeId);
            }
        } catch (error) {
            console.warn(`Error fetching photos for placeId ${infoWindow.placeId}:`, error);
            // Update placeholder to show error
            try {
                const contentNode = document.createElement('div');
                contentNode.innerHTML = infoWindow.getContent();
                const photoContainer = contentNode.querySelector(`.photo-container[data-place-id="${infoWindow.placeId}"]`);
                if (photoContainer) {
                    photoContainer.innerHTML = '<div class="photo-placeholder">Error loading photo</div>';
                    infoWindow.setContent(contentNode.innerHTML);
                }
            } catch (e) { console.error("Error updating infowindow content after photo fetch error:", e); }
        } finally {
            // Mark as fetched regardless of success or failure to prevent re-fetching
            infoWindow.photoFetched = true;
        }
    }

    // Adds click listener to a marker to open InfoWindow and highlight sidebar
    function addMarkerClickListener(marker, infoWindow, index) {
        marker.addListener('click', async () => {
            if (!marker.map) return; // Don't do anything if marker isn't on map

            // Close other info windows
            infoWindows.forEach(iw => { if (iw !== infoWindow) iw.close(); });

            // Debug info
            console.log(`Marker clicked: Index=${index}, placeId=${infoWindow.placeId}, photoFetched=${infoWindow.photoFetched}`);

            // Fetch photo only if it hasn't been fetched yet
            await fetchPhotoForInfoWindow(infoWindow); // Wait for photo fetch/update
            // Open this info window (content will be updated if photo was fetched)

            infoWindow.open({ map: map, anchor: marker });

            // Highlight corresponding sidebar item
            highlightSidebarItem(index);

            // Deselect any selected polyline
            deselectPolyline();
        });
    }


    // Adds click listener to a polyline to highlight it and the sidebar item
    function addPolylineClickListener(polyline, timelineItem, path) {
        polyline.addListener('click', (e) => { // e is PolyMouseEvent
            if (!polyline.getMap()) return; // Ignore clicks if not on map

            const index = timelineItem ? timelineItem.dataset.index : null;
            if (index !== null) highlightSidebarItem(index);

            selectPolyline(polyline); // Select clicked polyline

            infoWindows.forEach(iw => iw.close()); // Close any open info windows

            // Scroll sidebar item into view
            if (timelineItem) {
                timelineItem.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
        });
    }

    // Adds click listener to a sidebar item to interact with the map
    function addSidebarItemClickListener(sidebarItem, index, marker, infoWindow, polyline, path) {
        if (!sidebarItem) return;

        sidebarItem.addEventListener('click', async () => {
            highlightSidebarItem(index); // Highlight this item

            if (marker && infoWindow && marker.map) {
                // --- Place Visit Click ---
                map.setCenter(marker.position);
                map.setZoom(Math.max(map.getZoom(), 15)); // Zoom in if necessary

                // Close other info windows
                infoWindows.forEach(iw => { if (iw !== infoWindow) iw.close(); });

                // Fetch photo only if it hasn't been fetched yet
                await fetchPhotoForInfoWindow(infoWindow); // Wait for photo fetch/update

                // Open this info window
                infoWindow.open({ map: map, anchor: marker });

                deselectPolyline(); // Deselect any polyline

            } else if (polyline && path?.length > 0 && polyline.getMap()) {
                // --- Activity Segment Click ---
                const bounds = new google.maps.LatLngBounds();
                path.forEach(point => bounds.extend(point));
                map.fitBounds(bounds, 30); // Fit map to polyline bounds with padding

                selectPolyline(polyline); // Select this polyline

                infoWindows.forEach(iw => iw.close()); // Close info windows
            }
        });
    }

    // Highlights a specific sidebar item and scrolls it into view
    function highlightSidebarItem(index) {
        // Determine which view is active
        const isAreaViewActive = document.getElementById('areaView').style.display === 'flex';
        const container = isAreaViewActive
            ? document.getElementById('areaResults')
            : document.getElementById('timeline');

        if (!container) return;

        // Remove highlight from all items in the active container
        container.querySelectorAll('.timeline-item').forEach((item) => {
            item.classList.remove('highlighted');
        });

        // Find and highlight the specific item
        const targetItem = container.querySelector(`.timeline-item[data-index="${index}"]`);
        if (targetItem) {
            targetItem.classList.add('highlighted');
            // Scroll the item into view within its container
            if (!isElementInViewport(targetItem, container)) {
                targetItem.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
        }
    }

    // Helper function to check if an element is within the timeline's viewport
    function isElementInViewport (el, container) {
        if (!el || !container) return false;
        const rect = el.getBoundingClientRect();
        const containerRect = container.getBoundingClientRect();

        return (
            rect.top >= containerRect.top &&
            rect.bottom <= containerRect.bottom
        );
    }

    // Highlights a polyline (thicker, arrows)
    function selectPolyline(polyline) {
        if (selectedPolyline === polyline) return; // Already selected

        deselectPolyline(); // Deselect previous first

        // Enhance the selected polyline
        polyline.setOptions({
            strokeWeight: 7,
            // Add direction arrows
            icons: [{
                icon: {
                    path: google.maps.SymbolPath.FORWARD_CLOSED_ARROW,
                    scale: 5, // Size of the arrow
                    strokeColor: '#000',
                    strokeWeight: 2
                },
                offset: '50%', // Position in the middle of segments
                repeat: '90px' // Spacing between arrows
            }],
            zIndex: 1 // Bring to front
        });
        selectedPolyline = polyline;
    }

    // Restores the appearance of the previously selected polyline
    function deselectPolyline() {
        if (selectedPolyline) {
            // Restore original appearance
            selectedPolyline.setOptions({
                icons: [], // Remove arrows
                strokeWeight: 5, // Restore original weight
                strokeOpacity: 0.8,
                zIndex: 0 // Restore default zIndex
            });
            selectedPolyline = null;
        }
    }

    // Adjusts map bounds to fit all currently visible markers and polylines
    function fitMapToData() {
        if (!uiEnabled || (markers.length === 0 && polylines.length === 0)) return;

        const bounds = new google.maps.LatLngBounds();
        let itemCount = 0;

        // Extend bounds for visible markers
        markers.forEach(marker => {
            if (marker.map && marker.position) { // Check if marker is actually on the map and has position
                bounds.extend(marker.position);
                itemCount++;
            }
        });

        // Extend bounds for visible polylines
        polylines.forEach(polyline => {
            if (polyline.getMap()) { // Check if polyline is actually on the map
                polyline.getPath().forEach(point => bounds.extend(point));
                itemCount++;
            }
        });

        // Fit map if there are items
        if (itemCount > 0) {
            if (itemCount === 1 && markers.length === 1 && markers[0].map && markers[0].position) {
                // Single marker: center and set zoom
                map.setCenter(bounds.getCenter());
                map.setZoom(15);
            } else if (bounds.getNorthEast().equals(bounds.getSouthWest())) {
                // Multiple items at the exact same point
                map.setCenter(bounds.getCenter());
                map.setZoom(16); // Zoom slightly closer for identical points
            } else {
                map.fitBounds(bounds, 50); // Fit multiple items with padding (e.g., 50px)
            }
        }
        // If itemCount is 0, do nothing (map remains as is)
    }


    // Helper function to escape HTML special characters for attributes. Used w debug
    function escapeHtml(unsafe) {
        if (!unsafe) return '';
        // Ensure it's a string before replacing
        const str = String(unsafe);
        return str
            .replace(/&/g, "&amp;")
            .replace(/</g, "&lt;")
            .replace(/>/g, "&gt;")
            .replace(/"/g, "&quot;")
            .replace(/'/g, "&#039;");
    }


    // --- Data Loading and Processing ---

    // Loads and renders timeline data for a single date, applying filters
    async function loadTimelineDataForDate(selectedDate) {
        if (!uiEnabled) return;

        const tz = getSelectedTimezone();
        const startOfDay = moment.tz(selectedDate, tz).startOf('day');
        const endOfDay = moment.tz(selectedDate, tz).endOf('day');

        const year = startOfDay.year();
        const month = startOfDay.format('MMMM').toUpperCase(); // Use uppercase month name as key
        const dataKey = `${year}_${month}`;

        if (timelineData[dataKey] && timelineData[dataKey].timelineObjects) {
            const selectedDateStr = startOfDay.format('YYYY-MM-DD'); // For data attribute

            const relevantData = timelineData[dataKey].timelineObjects.filter(item => {
                // Determine start/end times consistently across formats
                let itemStartTime, itemEndTime;
                if (item.placeVisit) { // Standard format
                    itemStartTime = item.placeVisit.duration?.startTimestamp;
                    itemEndTime = item.placeVisit.duration?.endTimestamp;
                } else if (item.activitySegment) { // Standard format
                    itemStartTime = item.activitySegment.duration?.startTimestamp;
                    itemEndTime = item.activitySegment.duration?.endTimestamp;
                } else if (item.visit || item.activity){ // iOS format (check start/end Time at top level)
                    itemStartTime = item.startTime;
                    itemEndTime = item.endTime;
                }

                // Skip if timestamps are missing
                if (!itemStartTime || !itemEndTime) return false;

                const itemStartMoment = moment(itemStartTime); // These are UTC moments
                const itemEndMoment = moment(itemEndTime);

                // Check if the item's UTC time range overlaps with the selected day's time range in the chosen timezone
                if (itemEndMoment.isBefore(startOfDay) || itemStartMoment.isAfter(endOfDay)) {
                    return false; // Does not overlap
                }

                // Apply layer filters
                if (item.placeVisit || item.visit) {
                    if (!document.getElementById('showVisits').checked) return false;
                }
                else if (item.activitySegment) {
                    if (!document.getElementById('showActivities').checked) return false;

                    const segment = item.activitySegment;
                    const activityType = segment.activityType ||
                        (segment.activities && segment.activities[0]?.activityType) ||
                        (segment.waypointPath && segment.waypointPath.travelMode) ||
                        'UNKNOWN';
                    const groupedType = getGroupedActivityType(activityType);
                    const filterCheckbox = document.getElementById(`filter-${groupedType}`);
                    if (filterCheckbox && !filterCheckbox.checked) {
                        return false; // Filtered out
                    }
                }

                return true; // Item is relevant
            });

            // Sort data for the day chronologically
            relevantData.sort((a, b) => {
                // Determine start times consistently
                const timeA = moment(a.placeVisit?.duration?.startTimestamp || a.activitySegment?.duration?.startTimestamp || a.startTime);
                const timeB = moment(b.placeVisit?.duration?.startTimestamp || b.activitySegment?.duration?.startTimestamp || b.startTime);
                return timeA - timeB;
            });

            // Process and render the relevant data
            let firstLocationSet = false;
            relevantData.forEach((item, localIndex) => {
                // Center map on the first item of the day
                if (!firstLocationSet) {
                    let latLng;
                    if (item.placeVisit) {
                        latLng = { lat: item.placeVisit.location.latitudeE7 / 1e7, lng: item.placeVisit.location.longitudeE7 / 1e7 };
                    } else if (item.visit) { // iOS visit
                        const geo = parseGeoString(item.visit.topCandidate?.placeLocation);
                        if (geo) latLng = geo;
                        else if (item.visit.centerLatE7 && item.visit.centerLngE7) latLng = {lat: item.visit.centerLatE7 / 1e7, lng: item.visit.centerLngE7 / 1e7};
                    } else if (item.activitySegment) { // Standard activity
                        if (item.activitySegment.startLocation) {
                            latLng = { lat: item.activitySegment.startLocation.latitudeE7 / 1e7, lng: item.activitySegment.startLocation.longitudeE7 / 1e7 };
                        }
                    } else if (item.activity) { // iOS activity
                        const geo = parseGeoString(item.activity.start);
                        if (geo) latLng = geo;
                    }
                    if (latLng && !isNaN(latLng.lat) && !isNaN(latLng.lng)) {
                        map.setCenter(latLng);
                        map.setZoom(15); // Reasonable zoom for a single location/start point
                        firstLocationSet = true;
                    }
                }

                // Create timeline item in sidebar
                const timelineItem = createTimelineItem(item, globalIndex, selectedDateStr);
                document.getElementById('timeline').appendChild(timelineItem);

                // Render corresponding map elements (marker or polyline)
                if (item.placeVisit || item.visit) {
                    renderPlaceVisit(item, globalIndex); // Pass the whole item
                } else if (item.activitySegment) { // Standard activity segment
                    renderActivitySegment(item.activitySegment, globalIndex);
                } else if (item.activity) { // Transformed iOS activity now looks like an activitySegment
                    // This case should be handled by readFilesFromDirectory transforming iOS activities
                    // into the { activitySegment: ... } structure.
                    // If an item with a direct 'activity' property reaches here, it means transformation might have been missed
                    // or the structure is unexpected. For now, we assume it's already transformed.
                    console.warn("Direct iOS activity object encountered in loadTimelineDataForDate. Expected transformed activitySegment.", item);
                }
                globalIndex++; // Increment global index for unique identification
            });
        }
        // No else needed, if data for the month isn't loaded, nothing happens for this date.
    }


    // Loads data for a range of dates, clearing previous data first
    async function loadTimelineDataInDateRange(startDate, endDate, showRangeWarning = true) {
        if (summaryViewVisible) {
            document.getElementById('summaryView').style.display = 'none';
            document.getElementById('map').classList.remove('hidden');
            summaryViewVisible = false;
            updateViewToggleButtons();
        }

        if (!uiEnabled) return;

        if (showRangeWarning) {
            const startMoment = moment(startDate);
            const endMoment = moment(endDate);
            const dayDifference = endMoment.diff(startMoment, 'days');
            if (dayDifference > 62) {
                console.log("Date range warning check in loadTimelineDataInDateRange, difference:", dayDifference);
            }
        }

        clearMap();
        clearTimeline();
        globalIndex = 0;
        updateApiCallDisplay();

        document.getElementById('loading-overlay').style.display = "flex";

        // Create a new promise that wraps the entire loading process
        return new Promise(async (resolve, reject) => {
            const promises = [];
            let currentDate = moment(startDate).clone();
            while (currentDate.isSameOrBefore(moment(endDate), 'day')) {
                promises.push(loadTimelineDataForDate(currentDate.toDate()));
                currentDate.add(1, 'days');
            }

            try {
                await Promise.all(promises);
                // After all data is loaded and rendered, check if we need to highlight an item
                if (lastTimelineItemToHighlight) {
                    findAndHighlightTimelineItem(lastTimelineItemToHighlight.placeId, lastTimelineItemToHighlight.startTimestamp);
                    lastTimelineItemToHighlight = null; // Clear it after use
                }
                resolve(); // Resolve the main promise
            } catch (error) {
                console.error("Error loading data for date range:", error);
                reject(error); // Reject the main promise on error
            } finally {
                document.getElementById('loading-overlay').style.display = "none";
                document.getElementById('howToMessage').style.display = "none";
                document.getElementById('map').classList.remove('hidden');
                fitMapToData();
                console.log(`Finished loading range. Total API Calls: ${placeApiCallCount}`);
            }
        });
    }


    function findPlacesInMapArea() {
        if (!map) return;
        const bounds = map.getBounds();
        if (!bounds) {
            alert("Map is not ready yet. Please try again.");
            return;
        }

        const resultsContainer = document.getElementById('areaResults');
        resultsContainer.innerHTML = '<p class="area-placeholder">Searching...</p>';

        const limit = parseInt(document.getElementById('areaResultLimit').value, 10);
        const consolidate = document.querySelector('input[name="areaResultType"]:checked').value === 'consolidated';
        lastAreaSearchMode = consolidate ? 'consolidated' : 'all'; // Store the mode

        let foundVisits = [];
        const consolidatedPlaces = new Map();

        // Iterate through ALL loaded timeline data
        for (const monthKey in timelineData) {
            if (timelineData[monthKey] && timelineData[monthKey].timelineObjects) {
                for (const item of timelineData[monthKey].timelineObjects) {
                    let lat, lng, placeId, locationName, startTimestamp;

                    if (item.placeVisit) {
                        const pv = item.placeVisit;
                        lat = pv.location.latitudeE7 / 1e7;
                        lng = pv.location.longitudeE7 / 1e7;
                        placeId = pv.location.placeId;
                        locationName = pv.location.name || 'Unknown Location';
                        startTimestamp = pv.duration.startTimestamp;
                    } else if (item.visit) {
                        const v = item.visit.topCandidate;
                        const geo = parseGeoString(v?.placeLocation);
                        if (geo) {
                            lat = geo.lat;
                            lng = geo.lng;
                        }
                        placeId = v?.placeID;
                        locationName = v?.name || 'Unknown Location';
                        startTimestamp = item.startTime;
                    }

                    if (lat !== undefined && lng !== undefined && placeId) {
                        const visitLatLng = new google.maps.LatLng(lat, lng);
                        if (bounds.contains(visitLatLng)) {
                            if (consolidate) {
                                if (!consolidatedPlaces.has(placeId)) {
                                    consolidatedPlaces.set(placeId, {
                                        placeId: placeId,
                                        locationName: locationName, // Initial name
                                        item: item, // Store the first item for rendering details
                                        visits: []
                                    });
                                }
                                consolidatedPlaces.get(placeId).visits.push({ date: startTimestamp });
                            } else {
                                foundVisits.push(item);
                            }
                        }
                    }
                }
            }
        }

        let finalResults;
        if (consolidate) {
            finalResults = Array.from(consolidatedPlaces.values());
            // Sort consolidated places by the most recent visit date
            finalResults.forEach(place => {
                place.visits.sort((a, b) => new Date(b.date) - new Date(a.date));
                place.mostRecentVisit = place.visits[0].date;
            });
            finalResults.sort((a, b) => new Date(b.mostRecentVisit) - new Date(a.mostRecentVisit));
        } else {
            foundVisits.sort((a, b) => {
                const timeA = moment(a.placeVisit?.duration?.startTimestamp || a.startTime);
                const timeB = moment(b.placeVisit?.duration?.startTimestamp || b.startTime);
                return timeB - timeA;
            });
            finalResults = foundVisits;
        }

        // Apply the result limit
        if (limit > 0 && finalResults.length > limit) {
            finalResults = finalResults.slice(0, limit);
        }

        lastAreaSearchResults = finalResults;
        displayAreaResults(finalResults, consolidate);

        // Update UI to show results view
        document.getElementById('area-options-container').style.display = 'none';
        document.getElementById('findInAreaBtn').style.display = 'none';
        document.getElementById('newAreaSearchBtn').style.display = 'flex';
    }

    /**
     * Clears the map, then displays the area search results in the sidebar
     * and renders a marker for each result on the map.
     * @param {Array} visits - An array of visit items found in the map area.
     */
    function displayAreaResults(results, isConsolidated) {
        const resultsContainer = document.getElementById('areaResults');
        resultsContainer.innerHTML = '';
        clearMap();
        globalIndex = 0;

        if (results.length === 0) {
            resultsContainer.innerHTML = '<p class="area-placeholder">No visits found in this map area.</p>';
            return;
        }

        results.forEach(result => {
            const resultItem = isConsolidated
                ? createConsolidatedAreaResultItem(result, globalIndex)
                : createAreaResultItem(result, globalIndex);

            if (resultItem) {
                resultsContainer.appendChild(resultItem);
                // For consolidated items, pass the representative item for rendering
                const itemToRender = isConsolidated ? result.item : result;
                renderPlaceVisit(itemToRender, globalIndex, resultItem);
                globalIndex++;
            }
        });
    }

    /**
     * Creates a single DOM element for an area search result with new formatting.
     * @param {Object} item - The timeline item object.
     * @param {number} index - The unique index for this item.
     * @returns {HTMLElement} - The created DOM element.
     */
    function createAreaResultItem(item, index) {
        const resultItem = document.createElement('div');
        resultItem.className = 'timeline-item place-visit-item';
        resultItem.dataset.index = index;

        let locationName, visitTimestamp, endTimestamp, placeId;

        if (item.placeVisit) {
            const pv = item.placeVisit;
            placeId = pv.location.placeId;
            locationName = placeDetailsCache[placeId]?.displayName || pv.location.name || 'Unknown Location';
            visitTimestamp = pv.duration.startTimestamp;
            endTimestamp = pv.duration.endTimestamp;
        } else if (item.visit) {
            const v = item.visit;
            placeId = v.topCandidate?.placeID;
            locationName = placeDetailsCache[placeId]?.displayName || v.topCandidate?.name || 'Unknown Location';
            visitTimestamp = item.startTime;
            endTimestamp = item.endTime;
        } else {
            return null;
        }

        const visitDate = moment(visitTimestamp);
        const placeStyle = getPlaceStyle(placeDetailsCache[placeId]?.types || []);

        resultItem.innerHTML = `
            <span class="timeline-icon-container" style="border-color: ${placeStyle.color};">${placeStyle.icon}</span>
            <div class="timeline-item-details">
                <strong>${locationName}</strong>
                <div class="timeline-item-time">${visitDate.format('dddd, MMMM DD, YYYY')}</div>
                <div class="timeline-item-time" style="font-size: 11px;">
                    ${formatTimestamp(visitTimestamp, 'hh:mm A')} - ${formatTimestamp(endTimestamp, 'hh:mm A')}
                </div>
            </div>
        `;

        resultItem.addEventListener('click', async () => {
            const targetDate = moment(visitTimestamp).format('YYYY-MM-DD');
            showSidebarTab('date');
            document.getElementById('startDatePicker').value = targetDate;
            document.getElementById('endDatePicker').value = targetDate;

            // Set the global variable so the item can be found after loading
            lastTimelineItemToHighlight = { placeId: placeId, startTimestamp: visitTimestamp };

            // Directly call the loading function and await it
            await loadTimelineDataInDateRange(new Date(targetDate), new Date(targetDate), false);
        });

        return resultItem;
    }

    function createConsolidatedAreaResultItem(placeData, index) {
        const resultItem = document.createElement('div');
        resultItem.className = 'timeline-item place-visit-item consolidated';
        resultItem.dataset.index = index;

        const placeId = placeData.placeId;
        const locationName = placeDetailsCache[placeId]?.displayName || placeData.locationName;
        const placeStyle = getPlaceStyle(placeDetailsCache[placeId]?.types || []);

        const datesHtml = placeData.visits.map(visit =>
            `<span data-date="${moment(visit.date).format('YYYY-MM-DD')}" data-place-id="${placeId}" data-start-timestamp="${visit.date}">
                ${moment(visit.date).format('YYYY-MM-DD')}
            </span>`
        ).join('');

        resultItem.innerHTML = `
            <span class="timeline-icon-container" style="border-color: ${placeStyle.color};">${placeStyle.icon}</span>
            <div class="timeline-item-details">
                <strong>${locationName}</strong>
                <div class="consolidated-visit-dates">${datesHtml}</div>
            </div>
        `;

        // Add click listeners to each individual date span
        resultItem.querySelectorAll('.consolidated-visit-dates span').forEach(span => {
            span.addEventListener('click', async (e) => {
                e.stopPropagation(); // Prevent any parent click events
                const targetDate = span.dataset.date;
                showSidebarTab('date');
                document.getElementById('startDatePicker').value = targetDate;
                document.getElementById('endDatePicker').value = targetDate;

                lastTimelineItemToHighlight = { placeId: span.dataset.placeId, startTimestamp: span.dataset.startTimestamp };
                await loadTimelineDataInDateRange(new Date(targetDate), new Date(targetDate), false);
            });
        });

        return resultItem;
    }



    // --- Search Functionality ---
    function initSearch() {
        const searchBtn = document.getElementById('searchBtn');
        const searchInput = document.getElementById('searchInput');
        const clearSearchBtn = document.getElementById('clearSearchBtn'); // Get the new button
        const searchResults = document.getElementById('searchResults');

        searchBtn.addEventListener('click', () => {
            if (!uiEnabled) return;
            showSidebarTab('search');
        });

        // Autocomplete logic using Places API (New)
        searchInput.addEventListener('input', debounce(async (e) => {
            const query = e.target.value;
            // Show/hide clear button based on input
            clearSearchBtn.style.display = query.length > 0 ? 'block' : 'none';
            if (query.length < 3) {
                clearAutocompleteSuggestions();
                return;
            }
            await getAutocompleteSuggestions(query);
        }, 300)); // 300ms debounce delay

        // Add click listener for the new clear button
        clearSearchBtn.addEventListener('click', () => {
            searchInput.value = '';
            searchResults.innerHTML = '';
            clearAutocompleteSuggestions();
            clearSearchBtn.style.display = 'none';
            searchInput.focus();
        });

        // Close suggestions when clicking outside
        document.addEventListener('click', function(event) {
            const container = document.getElementById('autocomplete-suggestions-container');
            if (container && !container.contains(event.target)) {
                clearAutocompleteSuggestions();
            }
        });
    }
    async function getAutocompleteSuggestions(query) {
        if (apiCallsDisabled) {
            console.log("API calls are disabled, skipping autocomplete search.");
            return;
        }

        const apiKey = window.GOOGLE_MAPS_API_KEY;
        const url = `https://places.googleapis.com/v1/places:autocomplete`;
        incrementApiCallCount(); // Count this as an API call

        const requestBody = {
            'input': query,
            'languageCode': 'en'
        };

        // Add location biasing if available
        if (locationBias && locationBias.lat && locationBias.lng) {
            requestBody.locationBias = {
                "circle": {
                    "center": {
                        "latitude": locationBias.lat,
                        "longitude": locationBias.lng
                    },
                    "radius": 50000.0 // Bias results within a 50km radius
                }
            };
        }

        try {
            const response = await fetch(url, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-Goog-Api-Key': apiKey,
                },
                body: JSON.stringify(requestBody)
            });

            if (!response.ok) {
                const errorBody = await response.json();
                console.error('Places Autocomplete API error:', errorBody);
                if (errorBody.error?.message.includes("is not enabled")) {
                    alert("Error: The Places API (New) is not enabled for your project. Please enable it in the Google Cloud Console.");
                }
                return;
            }

            const data = await response.json();
            displayAutocompleteSuggestions(data.suggestions || []);

        } catch (error) {
            console.error('Failed to fetch autocomplete suggestions:', error);
        }
    }

    function displayAutocompleteSuggestions(suggestions) {
        const resultsContainer = document.getElementById('autocomplete-results');
        clearAutocompleteSuggestions();
        if (suggestions.length === 0) {
            return;
        }
        suggestions.forEach(suggestion => {
            const item = document.createElement('div');
            item.className = 'autocomplete-suggestion-item';
            const prediction = suggestion.placePrediction;
            const placeId = prediction.placeId;
            const placeText = prediction.text.text;
            item.innerHTML = `<span class="pac-icon"></span> <span>${escapeHtml(placeText)}</span>`;
            item.addEventListener('click', () => {
                console.log("Place selected:", placeText, placeId);
                document.getElementById('searchInput').value = placeText; // Populate input
                clearAutocompleteSuggestions();
                performSearch(placeId, placeText);
            });
            resultsContainer.appendChild(item);
        });
    }

    function clearAutocompleteSuggestions() {
        const resultsContainer = document.getElementById('autocomplete-results');
        if (resultsContainer) {
            resultsContainer.innerHTML = '';
        }
    }

    function performSearch(placeId, placeName) {
        const resultsContainer = document.getElementById('searchResults');
        resultsContainer.innerHTML = '<p>Searching...</p>';
        const foundVisits = [];

        // Iterate over all loaded monthly data
        for (const monthKey in timelineData) {
            if (timelineData.hasOwnProperty(monthKey)) {
                const monthData = timelineData[monthKey];
                if (monthData.timelineObjects) {
                    monthData.timelineObjects.forEach(item => {
                        let visitData = null;
                        let visitTimestamp = null;
                        let visitName = null;
                        let visitPlaceId = null;

                        // Handle standard format
                        if (item.placeVisit) {
                            visitData = item.placeVisit;
                            visitTimestamp = visitData.duration.startTimestamp;
                            visitName = visitData.location.name;
                            visitPlaceId = visitData.location.placeId;
                        }
                        // Handle iOS format
                        else if (item.visit) {
                            visitData = item.visit;
                            visitTimestamp = item.startTime;
                            visitName = visitData.topCandidate?.name;
                            visitPlaceId = visitData.topCandidate?.placeID;
                        }

                        if (visitData) {
                            // Match by placeId first (more reliable), then by name as a fallback
                            if ((visitPlaceId && visitPlaceId === placeId) || (visitName && placeName && visitName.toLowerCase() === placeName.toLowerCase())) {
                                foundVisits.push({
                                    name: visitName || placeName,
                                    date: visitTimestamp,
                                    placeId: visitPlaceId
                                });
                            }
                        }
                    });
                }
            }
        }
        displaySearchResults(foundVisits);
    }

    function displaySearchResults(results) {
        const resultsContainer = document.getElementById('searchResults');
        resultsContainer.innerHTML = ''; // Clear "Searching..."

        if (results.length === 0) {
            resultsContainer.innerHTML = '<p>No visits found for this place in the loaded data.</p>';
            return;
        }

        // Group results by date
        const groupedResults = results.reduce((acc, visit) => {
            const dateKey = moment(visit.date).format('YYYY-MM-DD');
            if (!acc[dateKey]) {
                acc[dateKey] = [];
            }
            acc[dateKey].push(visit);
            return acc;
        }, {});

        // Sort the date keys so the most recent dates appear first
        const sortedDateKeys = Object.keys(groupedResults).sort().reverse();

        sortedDateKeys.forEach(dateKey => {
            const visitsOnDate = groupedResults[dateKey];
            const resultItem = document.createElement('div');
            resultItem.className = 'search-result-item';

            const visitMoment = moment(visitsOnDate[0].date);
            const dateString = visitMoment.format('MMMM DD, YYYY');

            // Create a list of times for that day
            const timesString = visitsOnDate
                .sort((a,b) => new Date(a.date) - new Date(b.date)) // Sort times chronologically
                .map(v => moment(v.date).format('hh:mm A, dddd'))
                .join(', ');

            resultItem.innerHTML = `
					<strong>${dateString}</strong>
					<span>${timesString}</span>
				`;

            // Store the date for the click handler
            resultItem.dataset.date = dateKey;

            resultItem.addEventListener('click', () => {
                const targetDate = resultItem.dataset.date;
                console.log(`Navigating to date: ${targetDate}`);

                // 1. Switch back to the Date tab
                showSidebarTab('date');

                // 2. Set date pickers
                document.getElementById('startDatePicker').value = targetDate;
                document.getElementById('endDatePicker').value = targetDate;

                // 3. Trigger GO
                document.getElementById('goBtn').click();
            });

            resultsContainer.appendChild(resultItem);
        });
    }

    // --- Summary Calculation & Display ---

    // Calculates yearly and monthly summaries from the loaded timelineData
    function calculateSummaries() {
        console.log("Calculating summaries...");
        const yearly = {};
        const monthly = {};

        for (const key in timelineData) {
            if (!timelineData[key].timelineObjects) continue;

            const parts = key.split('_'); // e.g., "2023_JANUARY"
            if (parts.length < 2) continue;

            const yearStr = parts[0];
            const monthStr = parts[1]; // Uppercase month name
            const year = parseInt(yearStr, 10);

            // Convert month name to index (0-11)
            let monthIndex = moment().month(monthStr).format("M") - 1;
            if (monthIndex < 0) continue; // Skip invalid month names

            if (isNaN(year)) continue; // Skip invalid keys

            // Initialize summary objects if they don't exist
            if (!yearly[year]) {
                yearly[year] = { visits: 0, distanceMeters: 0, distanceByActivity: {} };
            }
            if (!monthly[year]) {
                monthly[year] = {};
            }
            if (!monthly[year][monthIndex]) {
                monthly[year][monthIndex] = { visits: 0, distanceMeters: 0, distanceByActivity: {} };
            }

            // Process each item in the month's data
            timelineData[key].timelineObjects.forEach(item => {
                if (item.placeVisit || item.visit) { // Count both visit types
                    yearly[year].visits++;
                    monthly[year][monthIndex].visits++;
                } else if (item.activitySegment) {
                    const segment = item.activitySegment;
                    const distanceMeters = segment.distance || segment.simplifiedRawPath?.distanceMeters || segment.waypointPath?.distanceMeters || 0;

                    if (distanceMeters > 0) {
                        const activityType = segment.activityType || (segment.activities && segment.activities.activityType) || (segment.waypointPath && segment.waypointPath.travelMode) || 'UNKNOWN';
                        const groupedType = getGroupedActivityType(activityType);

                        // Add to yearly summary
                        yearly[year].distanceMeters += distanceMeters;
                        yearly[year].distanceByActivity[groupedType] = (yearly[year].distanceByActivity[groupedType] || 0) + distanceMeters;

                        // Add to monthly summary
                        monthly[year][monthIndex].distanceMeters += distanceMeters;
                        monthly[year][monthIndex].distanceByActivity[groupedType] = (monthly[year][monthIndex].distanceByActivity[groupedType] || 0) + distanceMeters;
                    }
                }
            });
        }

        allYearlySummaries = yearly;
        allMonthlySummaries = monthly;
        console.log("Summaries calculated:", allYearlySummaries, allMonthlySummaries);
    }

    // Calculates summary specifically for the selected date range
    function calculateSelectedDatesSummary(startDate, endDate) {
        const summary = { visits: 0, distanceMeters: 0, distanceByActivity: {} };
        const tz = getSelectedTimezone();
        const startMoment = moment.tz(startDate, tz).startOf('day');
        const endMoment = moment.tz(endDate, tz).endOf('day');

        let currentDate = startMoment.clone();
        while (currentDate.isSameOrBefore(endMoment, 'day')) {
            const year = currentDate.year();
            const monthKey = currentDate.format('MMMM').toUpperCase();
            const dataKey = `${year}_${monthKey}`;

            if (timelineData[dataKey] && timelineData[dataKey].timelineObjects) {
                timelineData[dataKey].timelineObjects.forEach(item => {
                    // Determine start/end times consistently
                    let itemStartTime, itemEndTime;
                    if (item.placeVisit) {
                        itemStartTime = item.placeVisit.duration?.startTimestamp;
                        itemEndTime = item.placeVisit.duration?.endTimestamp;
                    } else if (item.activitySegment) {
                        itemStartTime = item.activitySegment.duration?.startTimestamp;
                        itemEndTime = item.activitySegment.duration?.endTimestamp;
                    } else if (item.visit || item.activity) { // iOS top-level
                        itemStartTime = item.startTime;
                        itemEndTime = item.endTime;
                    }
                    if (!itemStartTime || !itemEndTime) return; // Skip if no time

                    const itemStartMoment = moment(itemStartTime); // UTC
                    const itemEndMoment = moment(itemEndTime); // UTC

                    // Check if the item's UTC time range overlaps with the selected day's time range in the chosen timezone
                    const dayStart = currentDate.clone().startOf('day');
                    const dayEnd = currentDate.clone().endOf('day');
                    if (itemEndMoment.isBefore(dayStart) || itemStartMoment.isAfter(dayEnd)) {
                        return; // Skip items not overlapping this specific day
                    }

                    // Item overlaps the current day, add its stats
                    if (item.placeVisit || item.visit ) { // Count both visit types
                        summary.visits++;
                    } else if (item.activitySegment) {
                        const segment = item.activitySegment;
                        const distanceMeters = segment.distance || segment.simplifiedRawPath?.distanceMeters || segment.waypointPath?.distanceMeters || 0;
                        if (distanceMeters > 0) {
                            summary.distanceMeters += distanceMeters;
                            const activityType = segment.activityType || (segment.activities && segment.activities[0]?.activityType) || (segment.waypointPath && segment.waypointPath.travelMode) || 'UNKNOWN';
                            const groupedType = getGroupedActivityType(activityType);
                            summary.distanceByActivity[groupedType] = (summary.distanceByActivity[groupedType] || 0) + distanceMeters;
                        }
                    }
                });
            }
            currentDate.add(1, 'days');
        }
        return summary;
    }

    // Displays the summary for the currently selected date range
    function displaySelectedDatesSummary(startDate, endDate) {
        const container = document.getElementById('summary-selected-dates');
        container.innerHTML = ''; // Clear previous

        const summaryData = calculateSelectedDatesSummary(startDate, endDate);

        const startStr = formatTimestamp(startDate, 'MMM DD, YYYY');
        const endStr = formatTimestamp(endDate, 'MMM DD, YYYY');
        const title = startStr === endStr ? startStr : `${startStr} to ${endStr}`;

        const item = document.createElement('div');
        item.className = 'summary-selected-item'; // Use a specific class

        let activityHtml = '<ul>';
        const sortedActivities = Object.keys(summaryData.distanceByActivity).sort((a, b) => summaryData.distanceByActivity[b] - summaryData.distanceByActivity[a]);

        if (sortedActivities.length > 0) {
            sortedActivities.forEach(activityGroup => {
                const formattedName = activityGroup.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                const icon = getActivityIcon(activityGroup);
                activityHtml += `<li>${icon} ${formattedName}: <span>${formatDistance(summaryData.distanceByActivity[activityGroup])}</span></li>`;
            });
        } else if (summaryData.distanceMeters > 0) {
            activityHtml += '<li>No distance breakdown available</li>';
        } else {
            activityHtml += '<li>No distance recorded</li>';
        }
        activityHtml += '</ul>';

        item.innerHTML = `
                  <strong>${title}</strong>
                  <div class="summary-details">Visits: <span>${summaryData.visits.toLocaleString()}</span></div>
                  <div class="summary-details">Total Dist: <span>${formatDistance(summaryData.distanceMeters)}</span></div>
                  ${activityHtml}
                 `;
        container.appendChild(item);
    }

    // Displays the yearly summary items
    function displayYearSummary() {
        const yearContainer = document.getElementById('summary-years'); // Target the inner div
        const summaryView = document.getElementById('summaryView');
        yearContainer.innerHTML = ''; // Clear previous years

        if (!allYearlySummaries || Object.keys(allYearlySummaries).length === 0) {
            yearContainer.innerHTML = '<p>No summary data available.</p>';
            document.getElementById('summary-months').style.display = 'none';
            document.getElementById('summary-selected-year').textContent = '';
            document.getElementById('backToYearsBtn').style.display = 'none';
            summaryView.classList.remove('expanded-year-active');
            return;
        }

        const sortedYears = Object.keys(allYearlySummaries).map(Number).sort((a, b) => b - a); // Sort descending

        sortedYears.forEach(year => {
            const data = allYearlySummaries[year];
            const item = document.createElement('div');
            item.className = 'summary-year-item';
            item.dataset.year = year;

            // Generate activity breakdown HTML for the year
            let activityHtml = '<ul>';
            const sortedActivities = Object.keys(data.distanceByActivity || {}).sort((a, b) => data.distanceByActivity[b] - data.distanceByActivity[a]);

            if (sortedActivities.length > 0) {
                sortedActivities.forEach(activityGroup => {
                    const formattedName = activityGroup.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                    const icon = getActivityIcon(activityGroup);
                    activityHtml += `<li>${icon} ${formattedName}: <span>${formatDistance(data.distanceByActivity[activityGroup])}</span></li>`;
                });
            } else if (data.distanceMeters > 0) {
                activityHtml += '<li>No distance breakdown available</li>';
            } else {
                activityHtml += '<li>No distance recorded</li>';
            }
            activityHtml += '</ul>';

            item.innerHTML = `
                        <strong>${year}</strong>
                        <div class="summary-details">Visits: <span>${data.visits.toLocaleString()}</span></div>
                        <div class="summary-details">Total Dist: <span>${formatDistance(data.distanceMeters)}</span></div>
                        ${activityHtml}
                       `;

            // --- Year Click Listener ---
            item.addEventListener('click', () => {
                // Mark this year as selected and expand it
                yearContainer.querySelectorAll('.summary-year-item').forEach(el => el.classList.remove('is-selected-year'));
                item.classList.add('is-selected-year');

                // Add class to parent to control visibility via CSS
                summaryView.classList.add('expanded-year-active');

                // Show months for this year
                displayMonthSummary(year);

                // Scroll to the top of the summary view might be helpful
                summaryView.scrollTop = 0;
            });
            // --- End Year Click Listener ---

            yearContainer.appendChild(item);
        });

        // Initially, ensure the view is not in expanded mode
        summaryView.classList.remove('expanded-year-active');
        document.getElementById('summary-months').style.display = 'none';
        document.getElementById('backToYearsBtn').style.display = 'none';
    }

    // Displays the monthly summary items for a given year
    function displayMonthSummary(year) {
        selectedSummaryYear = year; // Store the currently selected year
        document.getElementById('summary-selected-year').textContent = '('+year+')'; // Update header
        const container = document.getElementById('summary-months');
        container.innerHTML = ''; // Clear previous months

        if (!allMonthlySummaries || !allMonthlySummaries[year] || Object.keys(allMonthlySummaries[year]).length === 0) {
            container.innerHTML = `<p>No monthly data available for ${year}.</p>`;
            return;
        }

        // Sort months chronologically (0-11)
        const sortedMonths = Object.keys(allMonthlySummaries[year]).map(Number).sort((a, b) => a - b);

        sortedMonths.forEach(monthIndex => {
            const data = allMonthlySummaries[year][monthIndex];
            const monthName = moment().month(monthIndex).format("MMMM"); // Get month name
            const item = document.createElement('div');
            item.className = 'summary-month-item';
            item.dataset.year = year;
            item.dataset.month = monthIndex;

            // Generate activity breakdown HTML
            let activityHtml = '<ul>';
            const sortedActivities = Object.keys(data.distanceByActivity).sort((a,b) => data.distanceByActivity[b] - data.distanceByActivity[a]); // Sort by distance desc

            if (sortedActivities.length > 0) {
                sortedActivities.forEach(activityGroup => {
                    const formattedName = activityGroup.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                    const icon = getActivityIcon(activityGroup);
                    activityHtml += `<li>${icon} ${formattedName}: <span>${formatDistance(data.distanceByActivity[activityGroup])}</span></li>`;
                });
            } else if (data.distanceMeters > 0) {
                activityHtml += '<li>No distance breakdown available</li>';
            } else {
                activityHtml += '<li>No distance recorded</li>';
            }
            activityHtml += '</ul>';

            item.innerHTML = `
                        <strong>${monthName}</strong>
                        <div class="summary-details">Visits: <span>${data.visits.toLocaleString()}</span></div>
                        <div class="summary-details">Total Dist: <span>${formatDistance(data.distanceMeters)}</span></div>
                        ${activityHtml}
                       `;

            // Add click listener to navigate to this month on the map
            item.addEventListener('click', () => navigateToMonth(year, monthIndex));

            container.appendChild(item);
        });
        // Ensure the months container is visible (handled by CSS .expanded-year-active)
        document.getElementById('summary-months').style.display = 'flex';
        // Ensure the back button is visible (handled by CSS .expanded-year-active)
        document.getElementById('backToYearsBtn').style.display = 'flex';

    }

    // Navigates from the summary view to the map view for a specific month
    function navigateToMonth(year, monthIndex) {
        console.log(`Navigating to: ${year}-${String(monthIndex + 1).padStart(2, '0')}`);
        const tz = getSelectedTimezone();
        // Calculate start and end dates for the selected month in the correct timezone
        const startOfMonth = moment.tz({ year: year, month: monthIndex }, tz).startOf('month').format('YYYY-MM-DD');
        const endOfMonth = moment.tz({ year: year, month: monthIndex }, tz).endOf('month').format('YYYY-MM-DD');

        // Update date pickers
        document.getElementById('startDatePicker').value = startOfMonth;
        document.getElementById('endDatePicker').value = endOfMonth;

        // Switch back to map view
        document.getElementById('summaryView').style.display = 'none';
        document.getElementById('map').classList.remove('hidden');
        summaryViewVisible = false;

        showSidebarTab('date');
        updateViewToggleButtons();

        // Trigger data load for the selected month
        document.getElementById('goBtn').click();
    }

    // --- UI Initialization and Event Listeners ---

    // Initializes the date picker controls and listeners
    function initDatePicker() {
        const startDatePicker = document.getElementById('startDatePicker');
        const endDatePicker = document.getElementById('endDatePicker');
        const prevDayBtn = document.getElementById('prevDayBtn');
        const nextDayBtn = document.getElementById('nextDayBtn');
        const goBtn = document.getElementById('goBtn');

        // Set initial dates to today
        const today = moment().format('YYYY-MM-DD');
        startDatePicker.value = today;
        endDatePicker.value = today;

        // Function to navigate days using arrow buttons
        const navigateDays = (days) => {
            if (!uiEnabled) return;
            // Ensure start date is not after end date (can happen if range was > 1 day)
            // If moving back, the end date should also move back by the same amount
            // If moving forward, the end date should also move forward by the same amount
            // The difference between start and end should remain constant.
            const tz = getSelectedTimezone();
            const originalStart = moment.tz(startDatePicker.value, tz);
            const originalEnd = moment.tz(endDatePicker.value, tz);
            const diffDays = originalEnd.diff(originalStart, 'days');

            const newStart = originalStart.clone().add(days, 'days');
            const newEnd = newStart.clone().add(diffDays, 'days'); // Maintain original range duration

            startDatePicker.value = newStart.format('YYYY-MM-DD');
            endDatePicker.value = newEnd.format('YYYY-MM-DD');

            // Load data for the new range (without the 62-day warning for arrow navigation)
            loadTimelineDataInDateRange(newStart.toDate(), newEnd.toDate(), false); // Pass false to skip warning
        };

        prevDayBtn.addEventListener('click', () => navigateDays(-1));
        nextDayBtn.addEventListener('click', () => navigateDays(1));

        // GO button click handler
        goBtn.addEventListener('click', () => {
            if (!uiEnabled) return;
            const tz = getSelectedTimezone();
            const startDate = moment.tz(startDatePicker.value, tz);
            const endDate = moment.tz(endDatePicker.value, tz);

            // Basic validation: ensure start date is not after end date
            if (startDate.isAfter(endDate)) {
                console.warn("Start date cannot be after end date.");
                alert("Start date cannot be after end date."); // User feedback
                // Clear map/timeline and return
                clearMap();
                clearTimeline();
                globalIndex = 0;
                //placeDetailsCache = {};
                updateApiCallDisplay();
                // Clear summary data as well if needed
                document.getElementById('summary-selected-dates').innerHTML = '';
                document.getElementById('summary-years').innerHTML = '';
                document.getElementById('summary-months').innerHTML = '';
                return;
            }

            // Warn if date range is more than 62 days
            const dayDifference = endDate.diff(startDate, 'days');
            if (dayDifference > 62) {
                const userConfirmation = confirm(`The selected date range is ${dayDifference + 1} days. Loading this much data might cause a large number of API calls. Do you want to continue?`);
                if (!userConfirmation) {
                    return; // User cancelled
                }
            }

            loadTimelineDataInDateRange(startDate.toDate(), endDate.toDate(), true); // Pass true or remove for default warning behavior in loadTimelineDataInDateRange if needed
        });
    }

    // Populates the activity filter checkboxes based on loaded data
    function populateActivityFilters() {
        const activityFilters = document.getElementById('activityFilters');
        activityFilters.innerHTML = ''; // Clear existing filters

        // Collect unique *grouped* activity types from all loaded data
        const uniqueGroupedTypes = new Set();
        Object.values(timelineData).forEach(monthData => {
            monthData.timelineObjects?.forEach(item => {
                let rawActivityType = 'UNKNOWN'; // Default

                // After readFilesFromDirectory, both standard Google Takeout data and
                // transformed iOS data should have an item.activitySegment structure.
                if (item.activitySegment) {
                    rawActivityType = item.activitySegment.activityType ||
                        (item.activitySegment.activities && item.activitySegment.activities[0]?.activityType) ||
                        (item.activitySegment.waypointPath && item.activitySegment.waypointPath.travelMode) ||
                        'UNKNOWN'; // Default if no specific type found within activitySegment
                }
                // This else if block is a fallback for data that might not have been transformed as expected,
                else if (item.activity?.topCandidate?.type) { // Check for raw iOS-like structure if no activitySegment
                    // console.warn("Encountered item.activity structure directly in populateActivityFilters. Data might not be fully transformed:", JSON.stringify(item).substring(0,200));
                    rawActivityType = item.activity.topCandidate.type;
                }
                let processedActivityType;
                if (typeof rawActivityType === 'string') {
                    processedActivityType = rawActivityType.trim().toUpperCase();
                }

                // If rawActivityType was not a string, or became empty after trim, default to 'UNKNOWN'
                if (!processedActivityType) {
                    processedActivityType = 'UNKNOWN';
                }

                const groupedType = getGroupedActivityType(processedActivityType);

                uniqueGroupedTypes.add(groupedType);
            });
        });

        // Sort types alphabetically, putting UNKNOWN last
        const sortedGroupedTypes = Array.from(uniqueGroupedTypes).sort((a, b) => {
            if (a === 'UNKNOWN') return 1; // Move UNKNOWN to the end
            if (b === 'UNKNOWN') return -1;
            return a.localeCompare(b); // Alphabetical sort for others
        });

        // Create checkboxes for each type (excluding STATIONARY)
        sortedGroupedTypes.forEach(groupType => {
            if (groupType === 'STATIONARY') return; // Skip STATIONARY filter

            const label = document.createElement('label');
            label.className = 'settings-option';
            const formattedName = groupType.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());

            label.innerHTML = `
                        <input type="checkbox" id="filter-${groupType}" class="settings-checkbox activity-filter-checkbox" checked data-group-type="${groupType}">
                        <span style="color:${getActivityColor(groupType)}; margin-right: 4px;">${getActivityIcon(groupType)}</span>
                        ${formattedName}
                    `;
            activityFilters.appendChild(label);

            // Add event listener to reload data when filter changes
            const checkbox = label.querySelector('input');
            checkbox.addEventListener('change', () => {
                if (!uiEnabled) return;

                // Update the main "Show Activities" checkbox based on individual filters
                const allActivityFilters = activityFilters.querySelectorAll('.activity-filter-checkbox');
                document.getElementById('showActivities').checked = [...allActivityFilters].some(cb => cb.checked);

                // Reload data with current date range and new filters
                const startDate = new Date(document.getElementById('startDatePicker').value);
                const endDate = new Date(document.getElementById('endDatePicker').value);
                loadTimelineDataInDateRange(startDate, endDate, false);
            });
        });
    }

    // Initializes the settings button and its options panel
    function initSettingsButton() {
        const settingsBtn = document.getElementById('settingsBtn');
        const showActivitiesCheckbox = document.getElementById('showActivities');
        const showVisitsCheckbox = document.getElementById('showVisits');
        const activityFiltersDiv = document.getElementById('activityFilters');

        // Toggle settings tab visibility
        settingsBtn.addEventListener('click', () => {
            if (!uiEnabled) return;
            showSidebarTab('settings');
        });

        // Function to reload data based on current filters and date range
        const reloadData = () => {
            if (!uiEnabled) return;
            const startDate = new Date(document.getElementById('startDatePicker').value);
            const endDate = new Date(document.getElementById('endDatePicker').value);
            loadTimelineDataInDateRange(startDate, endDate, false);
        };

        // Reload data when "Show Visits" changes
        showVisitsCheckbox.addEventListener('change', reloadData);

        // Handle "Show Activities" master checkbox change
        showActivitiesCheckbox.addEventListener('change', function() {
            if (!uiEnabled) return;
            const isChecked = this.checked;
            // Check/uncheck all individual activity filters
            activityFiltersDiv.querySelectorAll('.activity-filter-checkbox').forEach(checkbox => checkbox.checked = isChecked);
            // Reload data
            reloadData();
        });
    }

    // Initializes the "Fit Map" button
    function initFitMapButton() {
        document.getElementById('fitMapBtn').addEventListener('click', fitMapToData);
    }

    // Initializes the Summary View buttons and interactions
    function initSummaryView() {
        const summaryBtn = document.getElementById('summaryBtn');
        const closeSummaryBtn = document.getElementById('closeSummaryBtn');
        const summaryView = document.getElementById('summaryView');
        const mapElement = document.getElementById('map');
        const mapBtn = document.getElementById('mapBtn'); // Get map button
        const backBtn = document.getElementById('backToYearsBtn');

        // Toggle Summary View on button click
        summaryBtn.addEventListener('click', () => {
            if (!uiEnabled) return;

            if (!summaryViewVisible) {
                // Calculate summaries if not already done
                if (!allYearlySummaries) {
                    calculateSummaries();
                }
                // Display the summary sections
                displaySelectedDatesSummary( // Display selected range summary
                    new Date(document.getElementById('startDatePicker').value),
                    new Date(document.getElementById('endDatePicker').value)
                );
                // Display years, reset expanded view state
                displayYearSummary();
                summaryView.classList.remove('expanded-year-active'); // Ensure not expanded initially

                summaryView.style.display = 'block';
                mapElement.classList.add('hidden');
                summaryViewVisible = true;
            }
            updateViewToggleButtons(); // Update button active state

            const mobileSwitcher = document.getElementById('mobile-view-switcher');
            if (window.getComputedStyle(mobileSwitcher).display === 'flex') { // Check if on mobile
                document.getElementById('show-map-btn').click();
            }
        });

        // Close Summary View
        closeSummaryBtn.addEventListener('click', () => {
            summaryView.style.display = 'none';
            mapElement.classList.remove('hidden');
            summaryViewVisible = false;
            updateViewToggleButtons(); // Update button active state
        });

        // Switch to Map View using Map button
        mapBtn.addEventListener('click', () => {
            if (!uiEnabled) return; // Only if UI is enabled
            if (summaryViewVisible) { // Only act if summary is currently visible
                summaryView.style.display = 'none';
                mapElement.classList.remove('hidden');
                summaryViewVisible = false;
                updateViewToggleButtons(); // Update button active state
            }
        });

        // Back to Years button listener
        backBtn.addEventListener('click', () => {
            summaryView.classList.remove('expanded-year-active');
            // Remove specific selected class from the year item
            const selectedYearItem = summaryView.querySelector('.summary-year-item.is-selected-year');
            if (selectedYearItem) {
                selectedYearItem.classList.remove('is-selected-year');
            }
            // No need to re-display years, they are just hidden/shown by CSS
            document.getElementById('summary-months').innerHTML = '<p>Select a year above.</p>'; // Clear months
            document.getElementById('summary-selected-year').textContent = ''; // Clear month header
            document.getElementById('backToYearsBtn').style.display = 'none';
        });
    }

    // Updates the active state of the Map/Summary toggle buttons
    function updateViewToggleButtons() {
        const summaryBtn = document.getElementById('summaryBtn');
        const mapBtn = document.getElementById('mapBtn');

        if (summaryViewVisible) {
            summaryBtn.classList.add('active');
            mapBtn.classList.remove('active');
        } else {
            summaryBtn.classList.remove('active');
            mapBtn.classList.add('active');
        }
    }

    function initCacheControls() {
        const disableApiBtn = document.getElementById('disableApiBtn');
        const saveCacheBtn = document.getElementById('saveCacheBtn');

        disableApiBtn.addEventListener('click', () => {
            apiCallsDisabled = !apiCallsDisabled;
            disableApiBtn.textContent = apiCallsDisabled ? 'API Disabled' : 'Disable API';
            disableApiBtn.classList.toggle('active', apiCallsDisabled);
            console.log(`API calls ${apiCallsDisabled ? 'disabled' : 'enabled'}.`);
            if (!apiCallsDisabled){
                document.getElementById('goBtn').click();
            }
        });

        saveCacheBtn.addEventListener('click', () => {
            if (Object.keys(placeDetailsCache).length === 0) {
                alert("Cache is empty. Nothing to save.");
                return;
            }
            try {
                const jsonData = JSON.stringify(placeDetailsCache, null, 2); // Pretty print JSON
                const blob = new Blob([jsonData], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'TimelinePlaceCache.json';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                console.log("Place details cache saved.");
            } catch (error) {
                console.error("Error saving cache:", error);
                alert("Could not save cache data. See console for details.");
            }
        });
    }

    // Enables or disables UI controls based on whether data is loaded
    function setUIEnabled(enabled) {
        uiEnabled = enabled;
        const elementsToToggle = [
            document.getElementById('calendarBtn'),
            document.getElementById('startDatePicker'),
            document.getElementById('endDatePicker'),
            document.getElementById('prevDayBtn'),
            document.getElementById('nextDayBtn'),
            document.getElementById('goBtn'),
            document.getElementById('settingsBtn'),
            document.getElementById('fitMapBtn'),
            document.getElementById('areaBtn'),
            document.getElementById('summaryBtn'),
            document.getElementById('mapBtn'),
            document.getElementById('kmlBtn'),
            document.getElementById('reloadBtn'),
            document.getElementById('searchBtn')
        ];
        elementsToToggle.forEach(el => {
            if (el) el.disabled = !enabled;
        });

        document.getElementById('saveCacheBtn').disabled = !enabled || (Object.keys(placeDetailsCache).length - initialCacheSizeFromFile <= 0);

        if (enabled && storedDirHandle) {
            document.getElementById('reloadBtn').disabled = false;
        } else {
            document.getElementById('reloadBtn').disabled = true;
        }

        const settingsCheckboxes = document.querySelectorAll('#settingsView input[type="checkbox"]');
        settingsCheckboxes.forEach(cb => cb.disabled = !enabled);
        document.getElementById('timezone-select').disabled = !enabled;
        document.getElementById('distance-unit-select').disabled = !enabled;

        if (!enabled) {
            // Reset state when UI is disabled (e.g., no data loaded)
            document.getElementById('data-source-indicator').textContent = 'No data loaded. Use "Load Data".';
            document.getElementById('cache-indicator').style.display = 'none';
            clearMap();
            clearTimeline();
            document.getElementById('summaryView').style.display = 'none'; // Hide summary view
            document.getElementById('map').classList.remove('hidden'); // Ensure map is visible
            summaryViewVisible = false;
            updateViewToggleButtons(); // Ensure map button is active
            allYearlySummaries = null; // Clear summary data
            allMonthlySummaries = null;
            selectedSummaryYear = null;
            updateApiCallDisplay();
            document.getElementById('activityFilters').innerHTML = ''; // Clear activity filters
            document.getElementById('date-range-info').innerHTML = ''; // Clear date range info
            // Reset summary view state
            document.getElementById('summaryView').classList.remove('expanded-year-active');
            document.getElementById('summary-months').style.display = 'none';
            document.getElementById('backToYearsBtn').style.display = 'none';
        } else {
            // Update the cache button state whenever UI is enabled
            const newCount = Object.keys(placeDetailsCache).length - initialCacheSizeFromFile;
            document.getElementById('saveCacheBtn').disabled = newCount <= 0;
            updateViewToggleButtons();
        }
    }

    // Reads files from the selected directory (handles Takeout structure and single Timeline.json)
    async function readFilesFromDirectory(dirHandle, isRecursive=false) {
        let timelineJsonFile = null;
        let dataSourceText = 'Unknown';
        let placeCacheFile = null;
        let latestLocation = null;

        // Reset global state ONLY on the initial, non-recursive call
        if (!isRecursive) {
            console.log("Initial call to readFilesFromDirectory, resetting globals...");
            globalIndex = 0;
            timelineData = {};
            activityTypes = new Set();
            allYearlySummaries = null;
            allMonthlySummaries = null;
            selectedSummaryYear = null;
            globalMinDate = null;
            globalMaxDate = null;
            locationBias = null;
            lastAreaSearchResults = [];
            placeApiCallCount = 0;
            initialCacheSizeFromFile = 0;
            updateApiCallDisplay();
            // Show loading overlay and disable UI only on initial call
            document.getElementById('loading-overlay').style.display = "flex";
            setUIEnabled(false);
        }

        try {
            // --- Step 1: Scan for Timeline.json and TimelinePlaceCache.json at current level (non-recursive) ---
            if (!isRecursive) {
                for await (const entry of dirHandle.values()) {
                    if (entry.kind === 'file') {
                        if (entry.name.toLowerCase() === 'timeline.json') {
                            timelineJsonFile = entry;
                        } else if (entry.name.toLowerCase() === 'timelineplacecache.json') {
                            placeCacheFile = entry;
                        }
                    }
                    if (timelineJsonFile && placeCacheFile) break; // Found both, no need to look further
                }

                // Load Place Details Cache if found
                if (placeCacheFile) {
                    console.log("Found TimelinePlaceCache.json, attempting to load...");
                    try {
                        const file = await placeCacheFile.getFile();
                        const content = await file.text();
                        const cachedData = JSON.parse(content);
                        if (typeof cachedData === 'object' && cachedData !== null) {
                            placeDetailsCache = cachedData;
                            // Set initial cache size from file
                            initialCacheSizeFromFile = Object.keys(placeDetailsCache).length;
                            console.log(`Successfully loaded ${initialCacheSizeFromFile} entries from cache.`);
                        } else {
                            console.warn("TimelinePlaceCache.json does not contain a valid JSON object. Ignoring.");
                            placeDetailsCache = {};
                            initialCacheSizeFromFile = 0;
                        }
                    } catch (cacheError) {
                        console.error("Error reading or parsing TimelinePlaceCache.json:", cacheError);
                        alert("Error loading TimelinePlaceCache.json. It might be corrupted.");
                        placeDetailsCache = {};
                        initialCacheSizeFromFile = 0;
                    }
                } else {
                    console.log("TimelinePlaceCache.json not found.");
                    if (!isRecursive) {
                        placeDetailsCache = {};
                        initialCacheSizeFromFile = 0;
                    }
                }
            }

            // --- Step 2: Process single Timeline.json if found ---
            if (timelineJsonFile) {
                console.log("Found Timeline.json, attempting to parse...");
                const file = await timelineJsonFile.getFile();
                const content = await file.text();
                const jsonData = JSON.parse(content); // Renamed to jsonData to avoid conflict
                const processedData = {};

                // --- Handle iOS JSON Array Format ---
                if (Array.isArray(jsonData)) {
                    dataSourceText = 'Timeline.json (iOS)';
                    console.log('Processing iOS Format Timeline.json...');

                    // --- Step 1 - Pre-process timelinePath objects ---
                    console.log("Pre-processing timelinePath objects...");
                    const allPathPoints = [];
                    jsonData.forEach(item => {
                        if (item.timelinePath && Array.isArray(item.timelinePath)) {
                            // Use moment.js to parse the start time of the path chunk
                            const pathStartTime = moment(item.startTime);
                            if (!pathStartTime.isValid()) return; // Skip if start time is invalid

                            item.timelinePath.forEach(point => {
                                const offsetMinutes = parseInt(point.durationMinutesOffsetFromStartTime, 10);
                                if (isNaN(offsetMinutes)) return; // Skip if offset is not a number

                                // The existing geo string parser works perfectly here
                                const geo = parseGeoString(point.point);
                                if (!geo) return;

                                // Calculate the absolute timestamp for this specific point
                                const pointTimestamp = pathStartTime.clone().add(offsetMinutes, 'minutes');

                                allPathPoints.push({
                                    timestamp: pointTimestamp,
                                    lat: geo.lat,
                                    lng: geo.lng
                                });
                            });
                        }
                    });

                    // Sort all points by time to ensure they are in chronological order
                    allPathPoints.sort((a, b) => a.timestamp - b.timestamp);
                    console.log(`Found and processed ${allPathPoints.length} total points from timelinePath.`);
                    let pathPointPointer = 0; // An optimizer for our search loop


                    jsonData.forEach(item => {
                        if (!item || !item.startTime || !item.endTime) return; // Basic check

                        const startTimestamp = item.startTime;
                        const date = new Date(startTimestamp);
                        if (isNaN(date.getTime())) return;

                        // Update min/max dates
                        if (!globalMinDate || date < globalMinDate) globalMinDate = date;
                        if (!globalMaxDate || date > globalMaxDate) {
                            globalMaxDate = date;
                            // Capture location from the latest item
                            if (item.visit?.topCandidate?.placeLocation) {
                                latestLocation = parseGeoString(item.visit.topCandidate.placeLocation);
                            } else if (item.activity?.end) {
                                latestLocation = parseGeoString(item.activity.end);
                            }
                        }

                        const key = `${date.getFullYear()}_${moment(date).format('MMMM').toUpperCase()}`;
                        if (!processedData[key]) processedData[key] = { timelineObjects: [] };

                        let processedItem = { ...item }; // Clone item to avoid modifying original if needed elsewhere

                        if (item.visit) { // iOS Visit Object
                            // No specific transformation needed here for 'visit' itself,
                            // downstream functions (createTimelineItem, renderPlaceVisit) will handle its structure.
                            // Ensure lat/lng parsing happens in renderPlaceVisit for 'geo:' string
                            if (item.visit.topCandidate?.placeLocation) {
                                // console.log("iOS visit with placeLocation:", item.visit.topCandidate.placeLocation);
                            }
                        } else if (item.activity) { // iOS Activity Object
                            const activityData = item.activity;
                            const transformedActivity = {
                                duration: { startTimestamp: item.startTime, endTimestamp: item.endTime },
                                activityType: activityData.topCandidate?.type?.toUpperCase() || 'UNKNOWN',
                                distance: activityData.distanceMeters ? parseFloat(activityData.distanceMeters) : 0,
                                startLocation: {},
                                endLocation: {},
                                // No direct path data in iOS spec, so simplifiedRawPath will be empty or rely on start/end
                                simplifiedRawPath: { points: [] }
                            };

                            // --- NEW: Step 2 - Associate path points with this activity ---
                            const activityStartTime = moment(item.startTime);
                            const activityEndTime = moment(item.endTime);

                            // Efficiently find all points from the master list that fall within this activity's timeframe
                            for (let i = pathPointPointer; i < allPathPoints.length; i++) {
                                const point = allPathPoints[i];

                                // Since the list is sorted, we can advance our pointer past points that are too old
                                if (point.timestamp.isBefore(activityStartTime)) {
                                    pathPointPointer = i + 1;
                                    continue;
                                }

                                // If the point is after the activity, we can stop searching for this activity
                                if (point.timestamp.isAfter(activityEndTime)) {
                                    break;
                                }

                                // This point belongs to the current activity, so add it to the path
                                transformedActivity.simplifiedRawPath.points.push({
                                    lat: point.lat,
                                    lng: point.lng
                                });
                            }

                            const startGeo = parseGeoString(activityData.start);
                            if (startGeo) {
                                transformedActivity.startLocation = { latitudeE7: startGeo.lat * 1e7, longitudeE7: startGeo.lng * 1e7, lat: startGeo.lat, lng: startGeo.lng };
                                transformedActivity.simplifiedRawPath.points.push({lat: startGeo.lat, lng: startGeo.lng});
                            }
                            const endGeo = parseGeoString(activityData.end);
                            if (endGeo) {
                                transformedActivity.endLocation = { latitudeE7: endGeo.lat * 1e7, longitudeE7: endGeo.lng * 1e7, lat: endGeo.lat, lng: endGeo.lng };
                                // Ensure end point is added to path if different from start
                                if (!startGeo || (startGeo.lat !== endGeo.lat || startGeo.lng !== endGeo.lng)) {
                                    transformedActivity.simplifiedRawPath.points.push({lat: endGeo.lat, lng: endGeo.lng});
                                }
                            }
                            // Replace the original item with the transformed activitySegment structure
                            processedItem = { activitySegment: transformedActivity };
                            activityTypes.add(transformedActivity.activityType);
                        }
                        processedData[key].timelineObjects.push(processedItem);
                    });
                    timelineData = processedData;
                    console.log('iOS Format Timeline.json processed successfully.');


                    // --- Handle Standard Timeline Object Format ---
                } else if (jsonData.timelineObjects) {
                    dataSourceText = 'Timeline.json (Standard)';
                    console.log('Processing Standard Format Timeline.json...');
                    jsonData.timelineObjects.forEach(item => {
                        const endTimestamp = item.placeVisit?.duration?.endTimestamp || item.activitySegment?.duration?.endTimestamp;
                        if (!endTimestamp) return;
                        const date = new Date(endTimestamp);
                        if (isNaN(date.getTime())) return;

                        const startTimestamp = item.placeVisit?.duration?.startTimestamp || item.activitySegment?.duration?.startTimestamp;
                        if(startTimestamp) {
                            const startDate = new Date(startTimestamp);
                            if (!globalMinDate || startDate < globalMinDate) globalMinDate = startDate;
                        }

                        if (!globalMaxDate || date > globalMaxDate) {
                            globalMaxDate = date;
                            if (item.placeVisit?.location) {
                                latestLocation = { lat: item.placeVisit.location.latitudeE7 / 1e7, lng: item.placeVisit.location.longitudeE7 / 1e7 };
                            } else if (item.activitySegment?.endLocation) {
                                latestLocation = { lat: item.activitySegment.endLocation.latitudeE7 / 1e7, lng: item.activitySegment.endLocation.longitudeE7 / 1e7 };
                            }
                        }

                        const key = `${new Date(startTimestamp).getFullYear()}_${moment(new Date(startTimestamp)).format('MMMM').toUpperCase()}`;
                        if (!processedData[key]) processedData[key] = { timelineObjects: [] };
                        processedData[key].timelineObjects.push(item);
                        if (item.activitySegment?.activityType) activityTypes.add(item.activitySegment.activityType);
                        else if (item.activitySegment?.activities && item.activitySegment.activities[0]?.activityType) {
                            activityTypes.add(item.activitySegment.activities[0].activityType);
                        }
                    });
                    timelineData = processedData; // Assign grouped data
                    console.log('Standard Format Timeline.json processed successfully.');

                    // --- Handle Semantic History Format ---
                } else if (jsonData.semanticSegments) {
                    dataSourceText = 'Timeline.json (Semantic)';
                    console.log('Processing Semantic History format...');
                    // Populate the timelinePath points from every timelinePath object first
                    const allPathPoints = []; // Array to hold all path points with time
                    jsonData.semanticSegments.forEach(segment => {

                        const startTime = segment.startTime;
                        const endTime = segment.endTime;
                        if (!startTime || !endTime) return;

                        const startDate = new Date(startTime);
                        const endDate = new Date(endTime);
                        if (isNaN(startDate.getTime()) || isNaN(endDate.getTime())) return;

                        // Update min/max dates and capture latest location
                        if (!globalMinDate || startDate < globalMinDate) globalMinDate = startDate;
                        if (!globalMaxDate || endDate > globalMaxDate) {
                            globalMaxDate = endDate;
                            // Capture location from the latest item
                            if (segment.visit?.topCandidate?.placeLocation?.latLng) {
                                const latLngMatch = segment.visit.topCandidate.placeLocation.latLng.match(/(-?\d+\.\d+)\s*¬∞,\s*(-?\d+\.\d+)/);
                                if (latLngMatch) {
                                    const lat = parseFloat(latLngMatch[1]);
                                    const lng = parseFloat(latLngMatch[2]);
                                    if (!isNaN(lat) && !isNaN(lng)) {
                                        latestLocation = { lat, lng };
                                    }
                                }
                            } else if (segment.activity?.end?.latLng) {
                                const latLngMatch = segment.activity.end.latLng.match(/(-?\d+\.\d+)\s*¬∞,\s*(-?\d+\.\d+)/);
                                if (latLngMatch) {
                                    const lat = parseFloat(latLngMatch[1]);
                                    const lng = parseFloat(latLngMatch[2]);
                                    if (!isNaN(lat) && !isNaN(lng)) {
                                        latestLocation = { lat, lng };
                                    }
                                }
                            }
                        }

                        if (segment.timelinePath) {
                            segment.timelinePath.forEach(point => {
                                try {
                                    const latLngMatch = point.point?.match(/(-?\d+\.\d+)\s*¬∞,\s*(-?\d+\.\d+)/);
                                    const time = point.time;
                                    if (latLngMatch && time) {
                                        const lat = parseFloat(latLngMatch[1]);
                                        const lng = parseFloat(latLngMatch[2]);
                                        if (!isNaN(lat) && !isNaN(lng)) {
                                            allPathPoints.push({
                                                latE7: Math.round(lat * 1e7),
                                                lngE7: Math.round(lng * 1e7),
                                                time: time // Keep original timestamp string
                                            });
                                        }
                                    }
                                } catch (e) {
                                    console.warn("Error parsing timelinePath point:", point, e);
                                }
                            });
                        }
                    });
                    // Sort path points by time
                    allPathPoints.sort((a, b) => moment(a.time).valueOf() - moment(b.time).valueOf());
                    let pathPointPointer = 0; // Pointer for efficient matching

                    const processedTimelineObjects = jsonData.semanticSegments.map(segment => {
                        const startTime = segment.startTime;
                        const endTime = segment.endTime;
                        if (!startTime || !endTime) return null;

                        // Process Place Visit Segment
                        if (segment.visit?.topCandidate?.placeLocation?.latLng && segment.visit?.topCandidate?.placeId) {
                            const latLngMatch = segment.visit.topCandidate.placeLocation.latLng.match(/(-?\d+\.\d+)\s*¬∞,\s*(-?\d+\.\d+)/);
                            if (!latLngMatch) return null;
                            const lat = parseFloat(latLngMatch[1]);
                            const lng = parseFloat(latLngMatch[2]);
                            if (isNaN(lat) || isNaN(lng)) return null;
                            return {
                                placeVisit: { // Create standard placeVisit structure
                                    location: {
                                        latitudeE7: Math.round(lat * 1e7),
                                        longitudeE7: Math.round(lng * 1e7),
                                        placeId: segment.visit.topCandidate.placeId,
                                        semanticType: segment.visit.topCandidate.semanticType || null,
                                        name: segment.visit.topCandidate.name || 'Unknown Location'
                                    },
                                    duration: { startTimestamp: startTime, endTimestamp: endTime },
                                    editConfirmationStatus: segment.visit.editConfirmationStatus
                                }
                            };
                            // Process Activity Segment
                        } else if (segment.activity?.topCandidate?.type && segment.activity?.start?.latLng && segment.activity?.end?.latLng) {
                            const startLatLngMatch = segment.activity.start.latLng.match(/(-?\d+\.\d+)\s*¬∞,\s*(-?\d+\.\d+)/);
                            const endLatLngMatch = segment.activity.end.latLng.match(/(-?\d+\.\d+)\s*¬∞,\s*(-?\d+\.\d+)/);
                            if (!startLatLngMatch || !endLatLngMatch) return null;
                            const startLat = parseFloat(startLatLngMatch[1]);
                            const startLng = parseFloat(startLatLngMatch[2]);
                            const endLat = parseFloat(endLatLngMatch[1]);
                            const endLng = parseFloat(endLatLngMatch[2]);
                            if (isNaN(startLat) || isNaN(startLng) || isNaN(endLat) || isNaN(endLng)) return null;

                            const activitySegment = { // Create standard activitySegment structure
                                activityType: segment.activity.topCandidate.type || 'UNKNOWN',
                                duration: { startTimestamp: startTime, endTimestamp: endTime },
                                distance: segment.activity.distanceMeters, // Use provided distance
                                startLocation: { latitudeE7: Math.round(startLat * 1e7), longitudeE7: Math.round(startLng * 1e7) },
                                endLocation: { latitudeE7: Math.round(endLat * 1e7), longitudeE7: Math.round(endLng * 1e7) },
                                editConfirmationStatus: segment.activity.editConfirmationStatus,
                                simplifiedRawPath: { // Structure expected by rendering function
                                    distanceMeters: segment.activity.distanceMeters, // Include distance here too
                                    points: []
                                }
                            };
                            // Efficiently find associated path points
                            const segmentStartMoment = moment(startTime);
                            const segmentEndMoment = moment(endTime);
                            for (let i = pathPointPointer; i < allPathPoints.length; i++) {
                                const pointTime = moment(allPathPoints[i].time);
                                if (pointTime.isBefore(segmentStartMoment)) {
                                    pathPointPointer = i + 1; continue; // Advance pointer past old points
                                }
                                if (pointTime.isAfter(segmentEndMoment)) {
                                    break; // Done finding points for this segment
                                }
                                // Point is within the segment's time range
                                activitySegment.simplifiedRawPath.points.push({ // Ensure E7 format for points
                                    latE7: allPathPoints[i].latE7,
                                    lngE7: allPathPoints[i].lngE7,
                                });
                            }
                            activityTypes.add(activitySegment.activityType);
                            return { activitySegment: activitySegment };
                        }
                        return null; // Return null for segments that can't be processed
                    }).filter(Boolean); // Remove null entries

                    // Group by year and month
                    processedTimelineObjects.forEach(item => {
                        const timestamp = item.placeVisit ? item.placeVisit.duration.startTimestamp : item.activitySegment.duration.startTimestamp;
                        const date = new Date(timestamp);
                        if (isNaN(date.getTime())) return;
                        const key = `${date.getFullYear()}_${moment(date).format('MMMM').toUpperCase()}`;
                        if (!processedData[key]) processedData[key] = { timelineObjects: [] };
                        processedData[key].timelineObjects.push(item);
                        if (item.activitySegment) activityTypes.add(item.activitySegment.activityType);
                    });
                    timelineData = processedData; // Assign grouped data
                    console.log('Semantic Timeline.json processed successfully.');

                } else {
                    throw new Error("Timeline.json does not contain known data structure (timelineObjects, semanticSegments, or iOS array).");
                }

            } else {
                // --- Step 3: Fallback to recursive directory reading (Takeout Monthly Files) ---
                dataSourceText = 'Google Takeout';
                console.log("Timeline.json not found at top level, scanning for YYYY_MONTH.json files...");
                let fileFoundInThisLevel = false; // Track if files are found at the current level/recursion

                for await (const entry of dirHandle.values()) {
                    if (entry.kind === 'file' && entry.name.endsWith('.json') && /^\d{4}_\w+\.json$/i.test(entry.name)) {
                        // Process monthly file directly (YYYY_MONTH.json)
                        fileFoundInThisLevel = true; // Mark that we found a file here
                        console.log(`Processing ${entry.name}`);
                        const file = await entry.getFile();
                        const content = await file.text();
                        try {
                            const data = JSON.parse(content);
                            const fileNameKey = entry.name.split('.')[0].toUpperCase(); // Use YYYY_MONTH as key
                            if (data.timelineObjects) {
                                // Directly add to the global timelineData object
                                timelineData[fileNameKey] = data;
                                // Collect activity types and min/max dates
                                data.timelineObjects.forEach(item => {
                                    const endTimestamp = item.placeVisit?.duration?.endTimestamp || item.activitySegment?.duration?.endTimestamp;
                                    if (endTimestamp) {
                                        const date = new Date(endTimestamp);
                                        if (!isNaN(date.getTime())) {
                                            if (!globalMaxDate || date > globalMaxDate) {
                                                globalMaxDate = date;
                                                if (item.placeVisit?.location) {
                                                    latestLocation = { lat: item.placeVisit.location.latitudeE7 / 1e7, lng: item.placeVisit.location.longitudeE7 / 1e7 };
                                                } else if (item.activitySegment?.endLocation) {
                                                    latestLocation = { lat: item.activitySegment.endLocation.latitudeE7 / 1e7, lng: item.activitySegment.endLocation.longitudeE7 / 1e7 };
                                                }
                                            }
                                            // Update min date as well
                                            const startTimestamp = item.placeVisit?.duration?.startTimestamp || item.activitySegment?.duration?.startTimestamp;
                                            if(startTimestamp) {
                                                const startDate = new Date(startTimestamp);
                                                if (!globalMinDate || startDate < globalMinDate) globalMinDate = startDate;
                                            }
                                        }
                                    }

                                    if (item.activitySegment?.activityType) {
                                        activityTypes.add(item.activitySegment.activityType);
                                    } else if (item.activitySegment?.activities && item.activitySegment.activities[0]?.activityType) {
                                        activityTypes.add(item.activitySegment.activities[0].activityType.toUpperCase());
                                    }
                                });
                            } else {
                                console.warn(`Skipping file ${entry.name}: Does not contain 'timelineObjects'.`);
                            }
                        } catch (parseError) {
                            console.warn(`Skipping file ${entry.name} due to JSON parsing error:`, parseError.message);
                        }
                    } else if (entry.kind === 'directory') {
                        // Make recursive call for subdirectories (e.g., year folders)
                        console.log(`Recursively checking directory: ${entry.name}`);
                        // Await the recursive call to ensure all subfolders are processed before proceeding
                        await readFilesFromDirectory(entry, true);
                    }
                }

                // Check if *any* valid files were found ONLY on the initial call if no Timeline.json was processed
                if (!isRecursive && !timelineJsonFile && Object.keys(timelineData).length === 0) {
                    throw new Error("No valid timeline data files (Timeline.json or YYYY_MONTH.json) found in the selected folder or subfolders.");
                }
            }

            // --- Step 4: Post Loading (only on initial call) ---
            if (!isRecursive) {
                if (Object.keys(timelineData).length > 0) {
                    // Set the global locationBias from the latest found location
                    locationBias = latestLocation;
                    if (locationBias) {
                        console.log(`Set search location bias to latest data point:`, locationBias);
                    }
                    console.log("Data loading complete. Enabling UI.");

                    // Update the data source indicator text
                    document.getElementById('data-source-indicator').textContent = `Data source: ${dataSourceText}`;
                    updateCacheIndicator(); // Display the initial cache counts

                    await saveDirectoryHandle(dirHandle);
                    storedDirHandle = dirHandle;

                    populateActivityFilters();
                    displayMinMaxDates();
                    setUIEnabled(true);

                    // Perform initial data load for the default date range
                    const startDate = new Date(document.getElementById('startDatePicker').value);
                    const endDate = new Date(document.getElementById('endDatePicker').value);
                    await loadTimelineDataInDateRange(startDate, endDate); // Await initial load

                } else {
                    // No data was successfully loaded
                    document.getElementById('data-source-indicator').innerHTML = 'No valid timeline data found.';
                    setUIEnabled(false);
                    alert("No valid timeline data could be loaded from the selected folder.");
                }
            }

        } catch (err) {
            console.error('Error processing directory:', err);
            if (!isRecursive) { // Show error and disable UI on initial call failure
                alert(`Error processing folder: ${err.message}`);
                setUIEnabled(false);
            }
            // Don't re-throw if recursive, allow parent to handle
        } finally {
            // Hide loading overlay ONLY on the initial, non-recursive call completion
            if (!isRecursive) {
                document.getElementById('loading-overlay').style.display = "none";
            }
        }
    }

    // Initializes the "Load Data" button
    async function initFolderPicker() {
        const folderPicker = document.getElementById('folderPicker');
        const reloadBtn = document.getElementById('reloadBtn');

        // Check if showDirectoryPicker is supported
        if ('showDirectoryPicker' in window) {
            folderPicker.addEventListener('click', async () => {
                try {
                    // Options for directory picker
                    const opts = {
                        mode: 'read',
                        startIn: storedDirHandle || 'documents' // Suggest last used handle or a default
                    };
                    // Show the directory picker dialog
                    const dirHandle = await window.showDirectoryPicker(opts);
                    // Start processing the selected directory
                    await readFilesFromDirectory(dirHandle); // Pass the handle to the processing function
                } catch (err) {
                    // Handle errors, including user cancellation
                    if (err.name === 'AbortError') {
                        console.log('Folder selection cancelled by user.');
                    } else {
                        console.error('Error selecting folder:', err);
                        alert(`Could not select folder: ${err.message}`);
                    }
                    // Ensure loading overlay is hidden if selection fails/is cancelled before processing starts
                    document.getElementById('loading-overlay').style.display = "none";
                    // Keep UI disabled if it failed before any data was loaded
                    if(Object.keys(timelineData).length === 0) setUIEnabled(false);
                }
            });

            // Add listener for the reload button
            reloadBtn.addEventListener('click', async () => {
                if (storedDirHandle) {
                    console.log("Reloading from stored directory handle.");
                    // Verify permission - this will re-prompt the user if needed
                    if (await verifyPermission(storedDirHandle, false)) { // Ask for READ-ONLY
                        await readFilesFromDirectory(storedDirHandle);
                    } else {
                        console.warn("Permission to reload directory was denied.");
                        alert("Permission to access the previous folder was denied. Please choose the folder again.");
                    }
                } else {
                    alert("No previous folder is stored. Please choose a folder first.");
                }
            });

        } else {
            // Fallback or message for unsupported browsers
            folderPicker.disabled = true;
            folderPicker.textContent = 'Folder Picker Not Supported';
            console.warn('window.showDirectoryPicker is not supported in this browser.');
            alert('Your browser does not support the File System Access API needed to select folders. Please try a different browser (like Chrome or Edge).');
        }
    }

    // --- IndexedDB Functions for Directory Handle & Settings ---
    const DB_NAME = 'TimelineViewerDB';
    const STORE_NAME = 'settings';

    function openDB() {
        return new Promise((resolve, reject) => {
            const request = indexedDB.open(DB_NAME, 1);
            request.onupgradeneeded = event => {
                const db = event.target.result;
                if (!db.objectStoreNames.contains(STORE_NAME)) {
                    db.createObjectStore(STORE_NAME);
                }
            };
            request.onsuccess = event => resolve(event.target.result);
            request.onerror = event => reject(event.target.error);
        });
    }

    async function saveSetting(key, value) {
        try {
            const db = await openDB();
            const tx = db.transaction(STORE_NAME, 'readwrite');
            const store = tx.objectStore(STORE_NAME);
            store.put(value, key);
            await new Promise(resolve => tx.oncomplete = resolve);
            console.log(`Setting '${key}' saved to IndexedDB.`);
        } catch (error) {
            console.error(`Error saving setting '${key}' to IndexedDB:`, error);
        }
    }

    async function getSetting(key) {
        try {
            const db = await openDB();
            const tx = db.transaction(STORE_NAME, 'readonly');
            const store = tx.objectStore(STORE_NAME);
            const request = store.get(key);
            return new Promise((resolve, reject) => {
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        } catch (error) {
            console.error(`Error getting setting '${key}' from IndexedDB:`, error);
            return undefined;
        }
    }

    async function saveDirectoryHandle(dirHandle) {
        await saveSetting('lastDirectoryHandle', dirHandle);
    }

    async function getDirectoryHandle() {
        return await getSetting('lastDirectoryHandle');
    }

    async function verifyPermission(fileHandle, readWrite) {
        const options = {};
        if (readWrite) {
            options.mode = 'readwrite';
        } else {
            options.mode = 'read';
        }
        // Check if permission was already granted. If so, return true.
        if ((await fileHandle.queryPermission(options)) === 'granted') {
            return true;
        }
        // Request permission. If the user grants it, return true.
        if ((await fileHandle.requestPermission(options)) === 'granted') {
            return true;
        }
        // The user didn't grant permission, so return false.
        return false;
    }

    // --- Timezone and Units Functions ---
    function populateTimezoneSelector() {
        const select = document.getElementById('timezone-select');
        select.innerHTML = ''; // Clear existing

        const defaultOption = document.createElement('option');
        defaultOption.value = 'default';
        defaultOption.textContent = `System Default (${moment.tz.guess()})`;
        select.appendChild(defaultOption);

        if (typeof Intl.supportedValuesOf === 'function') {
            const timezones = Intl.supportedValuesOf('timeZone');
            timezones.forEach(tz => {
                const option = document.createElement('option');
                option.value = tz;
                option.textContent = tz;
                select.appendChild(option);
            });
        } else {
            console.warn("Intl.supportedValuesOf('timeZone') is not supported. Using moment-timezone's list.");
            moment.tz.names().forEach(tz => {
                const option = document.createElement('option');
                option.value = tz;
                option.textContent = tz;
                select.appendChild(option);
            });
        }

        // Apply the loaded or default setting to the UI
        select.value = displayTimezone;

        select.addEventListener('change', async (e) => {
            displayTimezone = e.target.value;
            await saveSetting('displayTimezone', displayTimezone);
            console.log(`Timezone changed and saved: ${displayTimezone}`);
            if (uiEnabled) {
                displayMinMaxDates();
                document.getElementById('goBtn').click();
            }
        });
    }

    function initDistanceUnitSelector() {
        const select = document.getElementById('distance-unit-select');
        // Apply the loaded or default setting to the UI
        select.value = distanceUnit;

        select.addEventListener('change', async (e) => {
            distanceUnit = e.target.value;
            await saveSetting('distanceUnit', distanceUnit);
            console.log(`Distance unit changed and saved: ${distanceUnit}`);
            if (uiEnabled) {
                document.getElementById('goBtn').click();
                if (summaryViewVisible) {
                    displaySelectedDatesSummary(
                        new Date(document.getElementById('startDatePicker').value),
                        new Date(document.getElementById('endDatePicker').value)
                    );
                    displayYearSummary();
                    if (selectedSummaryYear !== null) {
                        displayMonthSummary(selectedSummaryYear);
                    }
                }
            }
        });
    }

    // --- Min/Max Date Display ---
    function displayMinMaxDates() {
        const container = document.getElementById('date-range-info');
        if (globalMinDate && globalMaxDate) {
            const minStr = formatTimestamp(globalMinDate, 'YYYY-MM-DD');
            const maxStr = formatTimestamp(globalMaxDate, 'YYYY-MM-DD');
            container.innerHTML = `Data available from <span id="min-date-link" class="date-link" data-date="${minStr}">${minStr}</span> to <span id="max-date-link" class="date-link" data-date="${maxStr}">${maxStr}</span>`;

            // Add event listeners to both links
            document.querySelectorAll('.date-link').forEach(link => {
                link.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation(); // Prevent global click from hiding it immediately
                    showDateContextMenu(e, link.dataset.date);
                });
            });

        } else {
            container.innerHTML = '';
        }
    }

    function showDateContextMenu(event, dateStr) {
        const menu = document.getElementById('date-context-menu');
        menu.style.display = 'block';
        menu.style.left = `${event.pageX}px`;
        menu.style.top = `${event.pageY}px`;

        // Store the date on the menu itself to be used by the action listeners
        menu.dataset.date = dateStr;
    }


    // --- KML Export ---
    function getFilteredDataForRange(startDateStr, endDateStr) {
        const tz = getSelectedTimezone();
        const startOfDay = moment.tz(startDateStr, tz).startOf('day');
        const endOfDay = moment.tz(endDateStr, tz).endOf('day');
        let allItemsInRange = [];

        let currentDate = startOfDay.clone();
        // Create a set to avoid processing the same month's data multiple times
        const monthsToProcess = new Set();
        while (currentDate.isSameOrBefore(endOfDay, 'day')) {
            const dataKey = `${currentDate.year()}_${currentDate.format('MMMM').toUpperCase()}`;
            monthsToProcess.add(dataKey);
            currentDate.add(1, 'days');
        }

        monthsToProcess.forEach(dataKey => {
            if (timelineData[dataKey] && timelineData[dataKey].timelineObjects) {
                const monthItems = timelineData[dataKey].timelineObjects.filter(item => {
                    let itemStartTime, itemEndTime;
                    if (item.placeVisit) {
                        itemStartTime = item.placeVisit.duration?.startTimestamp;
                        itemEndTime = item.placeVisit.duration?.endTimestamp;
                    } else if (item.activitySegment) {
                        itemStartTime = item.activitySegment.duration?.startTimestamp;
                        itemEndTime = item.activitySegment.duration?.endTimestamp;
                    } else if (item.visit || item.activity) {
                        itemStartTime = item.startTime;
                        itemEndTime = item.endTime;
                    }
                    if (!itemStartTime || !itemEndTime) return false;
                    const itemStartMoment = moment(itemStartTime);
                    const itemEndMoment = moment(itemEndTime);
                    // Check for overlap with the total date range
                    return itemEndMoment.isSameOrAfter(startOfDay) && itemStartMoment.isSameOrBefore(endOfDay);
                });
                allItemsInRange.push(...monthItems);
            }
        });

        // Sort the final combined list chronologically
        allItemsInRange.sort((a, b) => {
            const timeA = moment(a.placeVisit?.duration?.startTimestamp || a.activitySegment?.duration?.startTimestamp || a.startTime);
            const timeB = moment(b.placeVisit?.duration?.startTimestamp || b.activitySegment?.duration?.startTimestamp || b.startTime);
            return timeA - timeB;
        });
        return allItemsInRange;
    }


    function exportToKML() {
        if (!uiEnabled) return;

        const startDateStr = document.getElementById('startDatePicker').value;
        const endDateStr = document.getElementById('endDatePicker').value;
        // Get all the raw data items for the selected date range
        const itemsToExport = getFilteredDataForRange(startDateStr, endDateStr);

        if (itemsToExport.length === 0) {
            alert("No data available in the selected range to export.");
            return;
        }

        let kmlPlacemarks = '';

        itemsToExport.forEach(item => {
            // --- Logic for Place Visits ---
            if (item.placeVisit) {
                const place = item.placeVisit;
                const placeId = place.location.placeId;
                const lat = place.location.latitudeE7 / 1e7;
                const lng = place.location.longitudeE7 / 1e7;
                if (isNaN(lat) || isNaN(lng)) return; // Skip if no valid coordinates

                // Determine the best available name
                let placeName = place.location.name || 'Unknown Location'; // Default name from file
                const semanticType = place.location.semanticType;

                // 1. Check for special "Home" or "Work" semantic types
                if (semanticType === "TYPE_HOME" || placeName.toLowerCase() === "home") {
                    placeName = "Home";
                } else if (semanticType === "TYPE_WORK" || placeName.toLowerCase() === "work") {
                    placeName = "Work";
                }
                // 2. If not Home/Work, check the cache for an API-fetched name
                else if (placeId && placeDetailsCache[placeId]) {
                    placeName = placeDetailsCache[placeId].displayName;
                }

                const name = escapeHtml(placeName);
                const start = formatTimestamp(place.duration.startTimestamp, 'YYYY-MM-DD HH:mm');
                const end = formatTimestamp(place.duration.endTimestamp, 'HH:mm');

                kmlPlacemarks += `
					  <Placemark>
						<name>${name}</name>
						<description>Arrived: ${start}&#10;Departed: ${end}</description>
						<styleUrl>#placeVisitStyle</styleUrl>
						<Point>
						  <coordinates>${lng},${lat},0</coordinates>
						</Point>
					  </Placemark>`;

                // --- Logic for Activity Segments (no changes needed here) ---
            } else if (item.activitySegment) {
                const activity = item.activitySegment;
                const activityType = activity.activityType || (activity.activities && activity.activities[0]?.activityType) || 'UNKNOWN';
                const groupedType = getGroupedActivityType(activityType);
                const name = escapeHtml(formatActivityType(activityType));
                const distanceMeters = activity.distance || 0;

                let coords = [];
                // This handles multiple path formats from different data sources
                let path = activity.waypointPath?.waypoints || activity.simplifiedRawPath?.points || activity.path;
                if (path) {
                    path.forEach(p => {
                        const pLat = p.latE7 / 1e7 || p.lat;
                        const pLng = p.lngE7 / 1e7 || p.lng;
                        if (!isNaN(pLat) && !isNaN(pLng)) coords.push(`${pLng},${pLat},0`);
                    });
                }
                // If no detailed path, create a simple line between start and end
                if (coords.length < 2) {
                    const startLat = activity.startLocation?.latitudeE7 / 1e7;
                    const startLng = activity.startLocation?.longitudeE7 / 1e7;
                    const endLat = activity.endLocation?.latitudeE7 / 1e7;
                    const endLng = activity.endLocation?.longitudeE7 / 1e7;
                    if (!isNaN(startLat) && !isNaN(startLng) && !isNaN(endLat) && !isNaN(endLng)) {
                        coords = [`${startLng},${startLat},0`, `${endLng},${endLat},0`];
                    } else {
                        return; // Cannot create a line for this segment
                    }
                }

                kmlPlacemarks += `
					  <Placemark>
						<name>${name}</name>
						<description>Distance: ${formatDistance(distanceMeters)}</description>
						<styleUrl>#${groupedType}</styleUrl>
						<LineString>
						  <tessellate>1</tessellate>
						  <coordinates>
							${coords.join('\n                ')}
						  </coordinates>
						</LineString>
					  </Placemark>`;
            }
        });

        let kmlStyles = '';
        const usedGroups = new Set(itemsToExport
            .filter(i => i.activitySegment)
            .map(i => getGroupedActivityType(i.activitySegment.activityType || 'UNKNOWN'))
        );

        usedGroups.forEach(group => {
            const color = getActivityColor(group).replace('#', ''); // Get hex color without #
            const kmlColor = `cc${color.substring(4, 6)}${color.substring(2, 4)}${color.substring(0, 2)}`; // 80% opacity, BGR format
            kmlStyles += `
					<Style id="${group}">
					  <LineStyle>
						<color>${kmlColor}</color>
						<width>4</width>
					  </LineStyle>
					</Style>`;
        });

        kmlStyles += `
					<Style id="placeVisitStyle">
					  <IconStyle>
						<scale>1.1</scale>
						<Icon>
						  <href>http://maps.google.com/mapfiles/kml/pushpin/red-pushpin.png</href>
						</Icon>
						<hotSpot x="20" y="2" xunits="pixels" yunits="pixels"/>
					  </IconStyle>
					</Style>`;

        const kmlContent = `<?xml version="1.0" encoding="UTF-8"?>
				<kml xmlns="http://www.opengis.net/kml/2.2" xmlns:gx="http://www.google.com/kml/ext/2.2">
				  <Document>
					<name>Timeline Export ${startDateStr} to ${endDateStr}</name>
					${kmlStyles}
					${kmlPlacemarks}
				  </Document>
				</kml>`;

        const blob = new Blob([kmlContent], { type: 'application/vnd.google-earth.kml+xml' });
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = `Timeline-Export-${startDateStr}-to-${endDateStr}.kml`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(a.href);
    }


    async function initializeApp() {
        // Check if the API key placeholder is still present
        if (window.GOOGLE_MAPS_API_KEY === "YOUR_API_KEY" || window.GOOGLE_MAPS_API_KEY === "") {
            alert("Please replace 'YOUR_API_KEY' in the HTML (near the top of the <script> block) with your actual Google Maps API Key.");
            // Optionally, disable functionality or hide the map
            document.getElementById('howToMessage').innerHTML = "<h3>Configuration Error</h3><p>Please set your Google Maps API key in the HTML file to use this tool.</p>";
            document.getElementById('howToMessage').style.display = "block";
            // Disable controls if API key is not set
            setUIEnabled(false);
            const folderPicker = document.getElementById('folderPicker');
            if(folderPicker) folderPicker.disabled = true; // Also disable folder picker explicitly
            return; // Stop further execution
        }

        try {
            // Load stored settings from IndexedDB first
            const storedTimezone = await getSetting('displayTimezone');
            if (storedTimezone) {
                displayTimezone = storedTimezone;
                console.log(`Loaded timezone setting from DB: ${displayTimezone}`);
            }
            const storedUnit = await getSetting('distanceUnit');
            if (storedUnit) {
                distanceUnit = storedUnit;
                console.log(`Loaded distance unit setting from DB: ${distanceUnit}`);
            }

            // Initialize the map and all UI components
            await initMap();
            initDatePicker();
            initFolderPicker();
            initSettingsButton();
            initFitMapButton();
            initSummaryView();
            initCacheControls();
            initSearch();
            initCurrentLocationButton();
            populateTimezoneSelector();
            initDistanceUnitSelector();
            setUIEnabled(false);
            showSidebarTab('date');
            updateApiCallDisplay();

            // --- Attach event listeners ---
            document.getElementById('calendarBtn').addEventListener('click', () => showSidebarTab('date'));
            document.getElementById('areaBtn').addEventListener('click', () => showSidebarTab('area'));
            document.getElementById('findInAreaBtn').addEventListener('click', findPlacesInMapArea);
            document.getElementById('newAreaSearchBtn').addEventListener('click', () => {
                document.getElementById('areaResults').innerHTML = '<p class="area-placeholder">Pan and zoom the map to your desired location, then click the button above to find all recorded visits in that area.</p>';
                document.getElementById('newAreaSearchBtn').style.display = 'none';
                document.getElementById('area-options-container').style.display = 'flex';
                document.getElementById('findInAreaBtn').style.display = 'flex';
                clearMap();
            });

            // Check for stored directory handle
            storedDirHandle = await getDirectoryHandle();
            if (storedDirHandle) {
                console.log("Found stored directory handle.");
            }

            // Add global key listeners for date navigation
            document.addEventListener('keydown', (e) => {
                if (!uiEnabled) return;
                // Check if the event target is an input field to avoid interference
                const targetTagName = e.target.tagName.toLowerCase();
                if (targetTagName === 'input' || targetTagName === 'textarea' || targetTagName === 'select') {
                    return; // Don't navigate if typing in an input
                }
                // Navigate using arrow keys
                if (e.key === 'ArrowLeft') {
                    e.preventDefault();
                    document.getElementById("prevDayBtn").click();
                } else if (e.key === 'ArrowRight') {
                    e.preventDefault();
                    document.getElementById("nextDayBtn").click();
                }
            });

            const contextMenu = document.getElementById('date-context-menu');
            contextMenu.addEventListener('click', (e) => {
                const action = e.target.dataset.action;
                const date = contextMenu.dataset.date;
                if (!action || !date) return;
                if (action === 'set-start') {
                    document.getElementById('startDatePicker').value = date;
                } else if (action === 'set-end') {
                    document.getElementById('endDatePicker').value = date;
                } else if (action === 'set-both') {
                    document.getElementById('startDatePicker').value = date;
                    document.getElementById('endDatePicker').value = date;
                }
                contextMenu.style.display = 'none';
            });

            // Add a global listener to hide the menu when clicking elsewhere
            document.addEventListener('click', () => {
                contextMenu.style.display = 'none';
            });

            // kml export button
            const kmlBtn = document.getElementById('kmlBtn');
            kmlBtn.addEventListener('click', () => {
                exportToKML()
            });

        } catch (error) {
            console.error("Error during initialization:", error);
            const modal = document.getElementById('apiKeyModal');
            if (modal.style.display !== 'flex') { // Only alert if the modal isn't already showing
                alert("An error occurred during map initialization. Your API key may be invalid or missing required permissions (Maps JavaScript API). Please check the console for details.");
            }
        }
    }

    window.onload = function() {
        initializeApp();
    };

</script>




<div id="mobile-view-switcher">
    <button id="show-sidebar-btn" class="active">üìã Controls & Details</button>
    <button id="show-map-btn">üåç Visual</button>
</div>

<script>
	// --- Mobile View Switcher Logic ---
	document.addEventListener('DOMContentLoaded', () => {
		const showSidebarBtn = document.getElementById('show-sidebar-btn');
		const showMapBtn = document.getElementById('show-map-btn');
		const sidebar = document.getElementById('sidebar');
		const mapContainer = document.getElementById('map');

		// This logic only applies if the switcher elements are present
		if (!showSidebarBtn || !showMapBtn || !sidebar || !mapContainer) {
			return;
		}

		const switchView = (viewToShow) => {
			// This function should only run on mobile-sized screens where the switcher is visible
			if (window.getComputedStyle(showSidebarBtn.parentElement).display !== 'flex') {
				return;
			}

			if (viewToShow === 'map') {
				sidebar.classList.add('mobile-hidden');
				mapContainer.classList.remove('mobile-hidden');
				showMapBtn.classList.add('active');
				showSidebarBtn.classList.remove('active');
			} else { // 'sidebar'
				sidebar.classList.remove('mobile-hidden');
				mapContainer.classList.add('mobile-hidden');
				showMapBtn.classList.remove('active');
				showSidebarBtn.classList.add('active');
			}
		};
		
		showSidebarBtn.addEventListener('click', () => switchView('sidebar'));
		showMapBtn.addEventListener('click', () => switchView('map'));

		// Set the initial view state when the page loads on a mobile device
		if (window.innerWidth <= 768) {
			mapContainer.classList.add('mobile-hidden');
		}
	});
</script>

</body>
</html>
